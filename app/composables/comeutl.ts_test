
// ------------------------------------------------------------------
//              Siavcom Software S. de R. L. de C.V.
// ------------------------------------------------------------------
// Autor    : Ing. Fernando Cuadras Angulo
// Sistema  : Comercializadoras                    Version : 8.0
// Programa : Utilerias del Sistema      Mnemo   : comeutl
// Ult. mod.: Fernando Cuadras Angulo    Fecha : Septiembre/1997ge
//            -17/FEB/2009. Fdo Cuadras. Quitamos transacciones de indices
//            -19/May/2014. Fdo Cuadras. Se aumenta la justificacion a ceros en los códigos de clientes y preoveedores
//            - Generacion de vista sql actualizable
//            - 01/01/2015. Fdo Cuadras. Actualizacion completa para utilizar PostgreSQL
//   - 09/Octubre/2017. Fdo. Cuadras . Actualizacion ver 10
//           20/Feb/2022 .- Se aumenta m.glo_xml
// ------------------------------------------------------------------
// -----------------------<  Calcula saldo por cliente o proveedor>---------------------

export async function cal_sal_nom(cop_nom1: string, cod_nom1: string, mon_doc1: number, fec_sal1: string) {
  let m = {}   // inicializamos m
  let cop_nom2 = cop_nom1
  let cod_nom2 = cop_nom1
  let mon_doc2 = mon_doc1
  let fec_sal2 = fec_sal1
  let are_tra = await select()
  let ins_sql = ''
  switch (true) {
    case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
      // Si es MSSQL o Sybase
      ins_sql = upper("set dateformat 'DMY'  select [dbo].[F_CAL_SAL_NOM]( '" + cop_nom1 + "','" + cod_nom1 + "'," + str(mon_doc1, 2) + ",'" + dateToString(fec_sal1) + "') as sal_tot")
      break
    case Public.value.ndb_emp == 4:
      // Si es PostgreSQL
      ins_sql = upper(" select F_cal_sal_nom( '" + cop_nom1 + "','" + cod_nom1 + "'," + str(mon_doc1, 2) + ",'" + dateToString(fec_sal1) + "') as sal_tot")
  } // End case 

  if (await SQLExec(ins_sql, 'resultado') > 0) {
    if (await recNo() > 0) {
      m = appendM(m, await scatter(m))// scatter 

    } else {

      m.sal_tot = 0
    } // End If 

    releaseUse('resultado') // use 

    await select(are_tra)

    if (Public.value.ndb_emp == 2) {
      // Sqlcommit ( Public.value.num_dbs ) 

      await SQLExec("commit work;")

    } // End If 

    return m.sal_tot

  } // End If 

  return err_sql()
  // ejecutamos rutina de error

}   // Fin Procedure
// -------------------------------< Calcula saldo general >-------------------------------------

export async function cal_sal_gen(cop_nom1: string, fec_sal: string, mon_sal: number) {
  let m = {}   // inicializamos m
  let are_tra = await select()

  switch (true) {
    case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
      // Si es MSSQL o Sybase
      let fec_sal1 = "'" + dateToString(fec_sal) + "'"
      // convertimos la fecha a string
      let ins_sql = upper("exec P_cal_sal_gen '" + cop_nom1 + "'," + fec_sal1 + "," + str(mon_sal, 1))
      break
    case Public.value.ndb_emp == 2:
      // Si es Firebird
      fec_sal1 = fec_ib6(fec_sal)
      // convertimos la fecha a string
      ins_sql = "select sal_tot from P_cal_sal_gen ('" + cop_nom1 + "'," + fec_sal1 + "," + str(mon_sal, 1) + ")"
      break
    case Public.value.ndb_emp == 4:
      // Si es PostgreSQL
      fec_sal1 = "'" + dateToString(fec_sal) + "'"
      // convertimos la fecha a string
      ins_sql = "select F_cal_sal_gen( '" + cop_nom1 + "'," + fec_sal1 + "," + str(mon_sal, 1) + ")"
  } // End case 

  let a = ins_sql
  if (await SQLExec(ins_sql, 'resultado')
    > 0) {
    if (await recNo() > 0) {
      m = appendM(m, await scatter(m))// scatter 

    } else {

      m.sal_tot = 0
    } // End If 

    releaseUse() // use 

    await select(are_tra)

    if (Public.value.ndb_emp == 2) {
      // Sqlcommit ( Public.value.num_dbs ) 

      await SQLExec("commit work;")

    } // End If 

    return m.sal_tot

  } // End If 

  return err_sql()
  // ejecutamos rutina de error

}   // Fin Procedure
// -----------------------< Calcula existencia de productos >-------------------------------
// parametros : cla_con  Clave de consulta
//    fec_con  Fecha de consulta
//    alm_con  Almacen de consulta
//    ped_con  Pedimento de consulta
//    ser_con  Serie de consulta
//    cod_nom  Codigo del cliente el cual tiene almacen de seguridad
//-------------------------------------------------------------------------------------------
//         (m.cla_isu,m.fec_mov,m.alm_mov,m.ped_ped,m.ser_mov,m.cod_nom)

export async function cal_exi_gen(cla_con: string, fec_con: any, alm_con: string, ped_con: string, ser_con: string, cod_con: string) {
  let m = {}   // inicializamos m
  let are_tra = await select()
  // obtiene la area de trabajo actual

  switch (true) {
    case Parameters() == 2:
      let alm_con = 'NULL'
      let ped_con = 'NULL'
      let ser_con = 'NULL'
      let cod_con = 'NULL'
      break
    case Parameters() == 3:
      ped_con = 'NULL'
      ser_con = 'NULL'
      cod_con = 'NULL'
      break
    case Parameters() == 4:
      ser_con = 'NULL'
      cod_con = 'NULL'
  } // End case 

  if (len(rTrim(ser_con)) == 0) {
    ser_con = 'NULL'
  } // End If 

  if (alm_con == '??' || upper(alm_con) == 'NULL' || isNull(alm_con)) {
    alm_con = 'NULL'
  } else {

    alm_con = "'" + alm_con + "'"
  } // End If 

  ser_con = iif(upper(ser_con) != 'NULL', "'" + ser_con + "'", ser_con)
  ped_con = iif(upper(ped_con) != 'NULL', "'" + ped_con + "'", ped_con)
  cod_con = iif(upper(cod_con) != 'NULL', "'" + cod_con + "'", cod_con)
  cla_con = "'" + cla_con + "'"
  await select('0')
  // utilizamos el store procedure cal_exi_gen

  switch (true) {
    case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
      // Si es MSSQL o Sybase
      let fec_con1 = "'" + dateToString(fec_con) + "'"
      // convertimos la fecha a string
      let ins_sql = upper(" declare @exi_tot numeric(20,6) " + " exec P_cal_exi_gen " + cla_con + ",0" + "," + fec_con1 + "," + alm_con + "," + ser_con + "," + ped_con + "," + cod_con + ",@exi_tot  OUTPUT " + " select @exi_tot as exi_tot")
      break
    case Public.value.ndb_emp == 4:
      // Si es PostgreSQL
      fec_con1 = "'" + dateToString(fec_con) + "'"
      // convertimos la fecha a string
      ins_sql = " select  P_cal_exi_gen  as exi_tot from P_cal_exi_gen( " + cla_con + ",0" + "," + fec_con1 + "," + alm_con + "," + ser_con + "," + ped_con + "," + cod_con + ")"
  } // End case 

  let a = ins_sql
  if (await SQLExec(ins_sql, 'resultado')
    > 0) {
    // ejecuta instrucción SQL
    if (await recNo() > 0) {
      m = appendM(m, await scatter(m))// scatter 

      releaseUse() // use 

    } else {

      m.exi_tot = 0
    } // End If 

    releaseUse() // use 

  } else {

    await MessageBox('No pudo calcular existencia')

    a = ins_sql
    m.exi_tot = 0
  } // End If 

  await select(are_tra)

  if (Public.value.ndb_emp == 2) {
    // Sqlcommit ( Public.value.num_dbs ) 

    await SQLExec("commit work;")

  } // End If 

  return m.exi_tot
  // Retornamos la existencia del producto

}   // Fin Procedure
//------------------------< Convierte una fecha a formato IBase 6>------------------------

export async function fec_ib6(fec_fue: string) {
  let m = {}   // inicializamos m
  let fec_des = dateToString(fec_fue)
  fec_des = "'" + position.Left(fec_des, 4) + '-' + substr(fec_des, 5, 2) + '-' + right(fec_des, 2) + "'"
  //fec_des="'"+substr(fec_des,5,2)+'/'+right(fec_des,2)+'/'+left(fec_des,4)+"'"
  return fec_des

}   // Fin Procedure
// -----------------------< Calcula existencia de toma de inventario fisico >-------------------------------
// parametros : cla_con  Clave de consulta
//    fec_con  Fecha de consulta
//    alm_con  Almacen de consulta
//    ser_con  Serie de consulta
//-------------------------------------------------------------------------------------------
//!// procedure cal_exi_tif
//!// parameters cla_con,fec_con,alm_con,ser_con,ped_con
//!// IF PARAMETERS()<3
//!//    SET STEP ON
//!// endif
//!// are_tra=select()     && obtiene la area de trabajo actual
//!// do case
//!//  case parameters()=3
//!//   ser_con='NULL'
//!//         ped_con='NULL'
//!//  case parameters()=4
//!//   ped_con='NULL'
//!// endcase
//!// if alm_con='??' .or. UPPER(alm_con)='NULL'
//!//    alm_con='NULL'
//!// else
//!//    alm_con="'"+alm_con+"'"
//!// endif
//!// ser_con=iif(UPPER(ser_con)<>'NULL',"'"+ser_con+"'",ser_con)
//!// cla_con="'"+cla_con+"'"
//!//          && utilizamos el store procedure cal_exi_gen
//!// select 0
//!// fec_con1="'"+Left(dateToString(fec_con),10)+"'"
//!// do case
//!//    case m.ndb_emp=1 OR m.ndb_emp=3    && Si es MSSQL o Sybase
//!//
//!//        ins_sql=" select dbo.P_cal_exi_tif( "+cla_con+
//         ","+fec_con1+","+alm_con+","+ser_con+","+ped_con+")"
//!//    case m.ndb_emp=2    && Si es Firebird
//!//       fec_con1=fec_ib6(fec_con)
//!//       ins_sql=" select // from P_cal_exi_tif( "+cla_con+
//         ","+fec_con1+","+alm_con+","+ser_con+","+ped_con+")"
//!//  case m.ndb_emp=4    && Si es PostgreSQL
//!//       ins_sql=" select f_cal_exi_tif as exi_pro from f_cal_exi_tif( "+cla_con+
//         ","+fec_con1+","+alm_con+","+ser_con+","+ped_con+") "
//!//
//!// endcase
//!// A=INS_SQL
//!// if sqlexec(num_dbs,ins_sql,'resultado')>0  && ejecuta instrucción SQL
//!//     if recno()>0
//!//       scatter memvar
//!//       use
//!//  else
//!//      m.exi_pro=0
//!//    endif
//!//    use
//!// else
//!//  messagebox('No pudo calcular existencia de toma de inventario fisico')
//!//  select (are_tra)
//!//     suspend
//!//  return 0
//!// endif
//!// select (are_tra)
//!// if  m.ndb_emp=2
//!//     SQLCOMMIT(NUM_DBS)
//!//     Sqlexec(num_dbs,"commit work;")
//!// endif
//!// return m.exi_pro   && Retornamos la existencia del producto
// ---------------< Consulta de existencia por pedimentos de productos >--------------------
// parametros : cla_con  Clave de consulta
//    fec_con  Fecha de consulta
//    alm_con  Almacen de consulta
//-------------------------------------------------------------------------------------------

export async function con_exi_ped(cla_con: string, fec_con: any, alm_con: string) {
  let m = {}   // inicializamos m
  let are_tra = await select()
  // obtiene la area de trabajo actual

  await select('0')
  // utilizamos el store procedure

  let fec_con1 = dateToString(fec_con)
  // convertimos la fecha a string
  switch (true) {
    case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
      // Si es MSSQL o Sybase
      let ins_sql = upper(" exec P_con_exi_ped '" + cla_con + "',0" + ",'" + fec_con1 + "','" + alm_con + "'")
      break
    case Public.value.ndb_emp == 2:
      // Si es Firebird
      ins_sql = " select ped_ped,fec_ped,exi_ped from P_con_exi_ped ('" + cla_con + "',0" + "," + fec_ib6(fec_con) + ",'" + alm_con + "')"
      break
    case Public.value.ndb_emp == 4:
      // Si es PosgreSQL
      ins_sql = " select CAST(ped_ped as char(15)) as ped_ped,fec_ped,exi_ped from  P_con_exi_ped ('" + cla_con + "',0" + ",'" + fec_con1 + "','" + alm_con + "')"
  } // End case 

  let a = ins_sql
  m.ped_ped = 0
  if (await SQLExec(ins_sql, 'resultado')
    > 0) {
    // ejecuta instrucción SQL
    if (Public.value.ndb_emp == 2) {
      // Sqlcommit ( Public.value.num_dbs ) 

      await SQLExec("commit work;")

    } // End If 

    await select('resultado')

    if (await recNo('resultado') > 0) {
      //VFP  Windows Windows lista From 0 , 4 To 17 , 80 Title 'Pedimentos aduanales ' Noclose style.font "Arial" , 9

      //VFP  Fields Fields ped_ped :h = 'Pedimento  ' , fecha = position.Left ( Transform ( fec_ped , '@e' ) , 10 ) :h = 'fecha' , exi_ped :h = 'Existencia':P = '99,999,999.99999' noappend noedit nodelete last window lista

      m.ped_ped = ped_ped
    } // End If 

  } else {

    await MessageBox('No pudo consultar los pedimentos')

    await select(are_tra)

    return ' '

  } // End If 

  await select(are_tra)

  //VFP  Window Window lista

  return m.ped_ped

}   // Fin Procedure
// ---------------< Consulta de existencia por serie o lote de productos >--------------------
// parametros : cla_con  Clave de consulta
//    fec_con  Fecha de consulta
//    alm_con  Almacen de consulta
//-------------------------------------------------------------------------------------------

export async function con_exi_ser(cla_con: string, fec_con: any, alm_con: string) {
  let m = {}   // inicializamos m
  let are_tra = await select()
  // obtiene la area de trabajo actual

  await select('0')
  // utilizamos el store procedure

  switch (true) {
    case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
      // Si es MSSQL o Sybase
      let fec_con1 = "'" + dateToString(fec_con) + "'"
      // convertimos la fecha a string
      let ins_sql = upper(" exec P_con_exi_ser '" + cla_con + "',0," + fec_con1 + ",'" + alm_con + "'")
      break
    case Public.value.ndb_emp == 2:
      // Si es Firebird
      ins_sql = " select  ser_mov,fpo_lot,fca_lot,exi_ser from P_con_exi_ser ('" + cla_con + "',0" + "," + fec_ib6(fec_con) + ",'" + alm_con + "')"
      break
    case Public.value.ndb_emp == 4:
      // Si es PosgreSQL
      fec_con1 = "'" + dateToString(fec_con) + "'"
      // convertimos la fecha a string
      ins_sql = upper(" SELECT  CAST(ser_mov as char(20)) as ser_mov, fpo_lot, fca_lot, exi_ser from P_con_exi_ser( '" + cla_con + "',0," + fec_con1 + ",'" + alm_con + "')")
  } // End case 
  // ins_sql=Upper(" SELECT  // from  P_con_exi_ser( '"+cla_con+"',0,"+fec_con1+",'"+alm_con+"')")

  let a = ins_sql
  m.ser_mov = ''
  if (await SQLExec(ins_sql, 'resultado')
    > 0) {
    // ejecuta instrucción SQL
    if (Public.value.ndb_emp == 2) {
      // Sqlcommit ( Public.value.num_dbs ) 

      await SQLExec("commit work;")

    } // End If 

    await select('resultado')

    if (await recNo('resultado') > 0) {
      //VFP  Windows Windows lista From 0 , 4 To 17 , 100 Title 'Lotes de productos' Panel Grow Zoom style.font "Arial" , 9

      //VFP  Fields Fields ser_mov :h = 'Serie o lote ' , fec_pro = position.Left ( Transform ( fpo_lot , '@e' ) , 10 ) :h = 'Fecha elaboración' , fec_cad = position.Left ( Transform ( fca_lot , '@e' ) , 10 ) :h = 'Fecha caducidad' , exi_ser :h = 'Existencia':P = '99,999,999.99999' noappend noedit nodelete last window lista

      m.ser_mov = ser_mov
    } // End If 

  } else {

    await MessageBox('Error al consultar los números de serie o lotes')

    await select(are_tra)

    return space(15)

  } // End If 

  await select(are_tra)

  //VFP  Window Window lista

  return m.ser_mov

}   // Fin Procedure
// ---------------< Consulta de pedidos por surtir >--------------------
// parametros : cop_con  Cliente o proveedor
//    cod_con  Codigo del cliente o proveedor o trabajador
//    alm_con  Almacen de consulta
// parametros pasados por referncia
//    dpe_con  Documento del pedido
//    npe_con  Número del documento del pedido
//    mpe_con  Movimiento del documento del pedido
//    por_con  Por entregar
//-------------------------------------------------------------------------------------------

export async function con_pdo_sur(cop_con: string, cod_con: string, alm_con: string, dpe_con: any, npe_con: any, mpe_con: any, por_con: any) {
  let m = {}   // inicializamos m
  let are_tra = await select()
  // obtiene la area de trabajo actual

  await select('0')
  //fec_con1=dateToString(fec_con)  && convertimos la fecha a string
  // utilizamos el store procedure

  switch (true) {
    case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
      // Si es MSSQL o Sybase
      let ins_sql = upper(" exec P_con_pdo_sur '" + cop_con + "','" + cod_con + "',0,'" + alm_con + "'")
      break
    case Public.value.ndb_emp == 2:
      // Si es Firebird
      ins_sql = " select des_tdo,tdo_tdo,ndo_doc,mov_mov,cla_isu,des_isu," + "por_ent,un1_isu,fec_mov,fme_mov from " + "P_con_pdo_sur ('" + cop_con + "','" + cod_con + "',0,'" + alm_con + "')"
      break
    case Public.value.ndb_emp == 4:
      // Si es PosgreSQL
      ins_sql = upper(" SELECT  CAST(des_tdo as char(20)) as des_tdo,tdo_tdo,ndo_doc,mov_mov,cla_isu,CAST(des_isu as char(60)) as des_isu,por_ent,un1_isu,fec_mov,fme_mov,CAST(des_tda as char(40)) as des_tda,key_pri  FROM P_con_pdo_sur( '" + cop_con + "','" + cod_con + "',0,'" + alm_con + "')")
  } // End case 

  let a = ins_sql
  if (await SQLExec(ins_sql, 'resultado')
    > 0) {
    // ejecuta instrucción SQL
    if (Public.value.ndb_emp == 2) {
      // Sqlcommit ( Public.value.num_dbs ) 

      await SQLExec("commit work;")

    } // End If 

    await select('resultado')

    if (await recNo('resultado') > 0) {
      //VFP  Windows Windows lista From 0 , 4 To 17 , 100 Title 'Pedidos por surtir ' Panel Grow Zoom style.font "Arial" , 9

      //VFP  Fields Fields des_tda :h = 'Almacen' , des_tdo :h = 'Documento' , ndo_doc :h = 'Número' : P = '999999' , mov_mov :h = 'movimiento': P = '999' , cla_isu :h = 'Clave' , des = position.Left ( des_isu , 100 ) :h = 'Descripción' , por_ent :h = 'Por entregar' :P = '99,999,999.9999' , un1_isu :h = 'Unidad' , fec_min = position.Left ( Transform ( fec_mov , '@e' ) , 10 ) :h = 'Fecha minima' , fec_max = position.Left ( Transform ( fme_mov , '@e' ) , 10 ) :h = 'Fecha maxima' noappend noedit nodelete last window lista

      let dpe_con = tdo_tdo
      // asigna resultado a las variables que se pasaron por referencia
      let npe_con = ndo_doc
      let mpe_con = mov_mov
      let por_con = por_ent
    } // End If 

    if (Public.value.ndb_emp == 2) {
      // Sqlcommit ( Public.value.num_dbs ) 

      await SQLExec("commit work;")

    } // End If 

  } else {

    await MessageBox('No pudo consultar los pedidos')

    await select(are_tra)

    return false

  } // End If 

  await select(are_tra)

  //VFP  Window Window lista

  return

}   // Fin Procedure
// -----------------------< Calcula pedidos de productos >-------------------------------
// parametros : cla_con  Clave de consulta
//    fec_con  Fecha de consulta
//    alm_con  Almacen de consulta
//    cop_nom  Clientes o proveedores
//-------------------------------------------------------------------------------------------

export async function cal_pdo_gen(cla_con: string, fec_con: any, alm_con: string, cop_con: string) {
  let m = {}   // inicializamos m
  let are_tra = await select()
  // obtiene la area de trabajo actual

  if (alm_con == '??') {
    let alm_con = 'NULL'
  } else {

    alm_con = "'" + alm_con + "'"
  } // End If 

  await select('0')
  // utilizamos el store procedure

  switch (true) {
    case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
      // Si es MSSQL o Sybase
      let fec_con1 = dateToString(fec_con)
      // convertimos la fecha a string
      let ins_sql = upper(" declare @tot_mov numeric(20,6) " + " exec P_cal_pdo_gen '" + cla_con + "','" + fec_con1 + "'," + alm_con + ",'" + cop_con + "',@tot_mov  OUTPUT " + " select @tot_mov as tot_mov")
      break
    case Public.value.ndb_emp == 2:
      // Si es Firebird
      ins_sql = " select tot_mov from P_cal_pdo_gen ('" + cla_con + "'," + fec_ib6(fec_con) + "," + alm_con + ",'" + cop_con + "')"
      break
    case Public.value.ndb_emp == 4:
      // Si es PosgreSQL
      fec_con1 = dateToString(fec_con)
      // convertimos la fecha a string
      ins_sql = upper(" SELECT P_cal_pdo_gen AS TOT_MOV FROM  cal_pdo_gen ('" + cla_con + "','" + fec_con1 + "'," + alm_con + ",'" + cop_con + "')")
  } // End case 

  if (await SQLExec(ins_sql, 'resultado')
    > 0) {
    // ejecuta instrucción SQL
    if (await recNo() > 0) {
      m = appendM(m, await scatter(m))// scatter 

      releaseUse() // use 

    } else {

      m.tot_mov = 0
    } // End If 

    releaseUse() // use 

  } else {

    await MessageBox('No pudo calcular pedidos')

    await select(are_tra)

    return false

  } // End If 

  if (Public.value.ndb_emp == 2) {
    // Sqlcommit ( Public.value.num_dbs ) 

    await SQLExec("commit work;")

  } // End If 

  await select(are_tra)

  return m.tot_mov
  // Retornamos la existencia del producto

}   // Fin Procedure
// -----------------------< Calcula costo de productos >-------------------------------
// parametros : cla_con  Clave de consulta
//    fec_con  Fecha de consulta
//    alm_con  Almacen de consulta
//-------------------------------------------------------------------------------------------

export async function cal_cos_gen(cla_con: string, fec_con: any, alm_con: string) {
  let m = {}   // inicializamos m
  let are_tra = await select()
  // obtiene la area de trabajo actual

  if (Parameters() == 2 || alm_con == '??') {
    let alm_con = 'NULL'
  } else {

    alm_con = "'" + alm_con + "'"
  } // End If 

  switch (true) {
    // utilizamos el store procedure cal_cos_gen
    case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
      // Si es MSSQL o Sybase
      let fec_con1 = dateToString(fec_con)
      // convertimos la fecha a string
      let ins_sql = upper(" declare @cos_pro numeric(20,6) " + " exec P_cal_cos_gen '" + cla_con + "','" + fec_con1 + "'," + alm_con + ",@cos_pro  OUTPUT " + " select @cos_pro as cos_pro")
      break
    case Public.value.ndb_emp == 2:
      // Si es Firebird
      ins_sql = "select L_cos_tot as  cos_pro  FROM  P_cal_cos_gen ('" + cla_con + "'," + fec_ib6(fec_con) + "," + alm_con + ")"
      break
    case Public.value.ndb_emp == 4:
      // Si es PosgreSQL
      fec_con1 = dateToString(fec_con)
      // convertimos la fecha a string
      ins_sql = upper(" SELECT P_cal_cos_gen AS COS_PRO FROM cal_cos_gen ('" + cla_con + "','" + fec_con1 + "'," + alm_con + ")")
  } // End case 

  let a = ins_sql
  if (await SQLExec(ins_sql, 'resultado')
    > 0) {
    // ejecuta instrucción SQL
    if (await recNo() > 0) {
      m = appendM(m, await scatter(m))// scatter 

    } else {

      m.cos_pro = 0
    } // End If 

    releaseUse() // use 

  } else {

    await MessageBox('No pudo calcular el costo del producto ' + cla_con)

    err_sql()
    // ejecutamos rutina de error
    await select(are_tra)

    return false

  } // End If 

  if (Public.value.ndb_emp == 2) {
    // Sqlcommit ( Public.value.num_dbs ) 

    await SQLExec("commit work;")

  } // End If 

  await select(are_tra)

  return m.cos_pro
  // Retornamos la existencia del producto

}   // Fin Procedure
// -------------------------< Cancelación de un documento >-----------------------------

export async function can_doc(tdo_tdo: string, ndo_doc: any) {
  let m = {}   // inicializamos m
  let are_tra = await select()

  await select('vi_lla1_doc')

  m = appendM(m, await scatter(m))// scatter 

  let ins_sql = "select CAST(max(key_pri) as int) as key_pri from man_comepag where tdo_tdo='" + m.tdo_tdo + "' and ndo_doc=" + str(m.ndo_doc)
  // busca pagos asignados
  if (await SQLExec(ins_sql, 'resultado') < 0) {
      =err_sql()
    return

  } // End If 

  if (!isNull(KEY_PRI) && await recCount() > 0 && await MessageBox(iif(await recCount() > 0, ' Tiene pagos asignados ', '') + "Seguro que desea cancelar este documento", 4 + 32)
    != 6) {

    releaseUse() // use 

    await select(are_tra)

    return

  } // End If 

  releaseUse() // use 

  m.fca_xml = {}
  m.cfd_xml = ''
  m.emt_xml = ''
  let est_can = ''
  ins_sql = [select cfd_xml, emt_xml, FCA_XML, sta_doc  from man_comexml where tdo_tdo = ']+vi_lla1_doc.tdo_tdo+[' and ndo_doc =] + allTrim(str(vi_lla1_doc.ndo_doc))
  // busca el cfdi en el xml
  if (await SQLExec(ins_sql, 'sqlresult')
    > 0) {
    if (await recCount('sqlresult') > 0) {
      // tiene cfdi en xml
      m = appendM(m, await scatter(m))// scatter 

      m.cer_cer = obt_cam_xml(m.cfd_xml, ' ', 'noCertificado')
    } else {

      m.sta_doc = 'P'
    } // End If 

  } else {

    err_sql()
    return

  } // End If 

  if (m.sta_doc == 'T') {
    // si es un cfdi timbrado obtiene todos sus atributos
    let res_tim = ''
    await select('cometdo')
    // arc_env=Sys(2023)+'\'+Substr(Sys(2015), 3)+'.XML'  && envelope 1

    m = appendM(m, await scatter(m))// scatter 
    // lee a variables de memoria

    if (m.cer_cer > ' ') {
      let cer_ori = m.cer_cer
      m.cer_cer = enc_pal(cer_ori)
      if (await select('vi_lla1_cer')
        < 1) {
        await select('0')

        await useNodata('vi_lla1_cer') // use vi_lla1_cer vi_lla1_cer Nodata

      } // End If 

      await select('vi_lla1_cer')

      if (await requery()
        > 0) {
        if (Field('PEM_CER') == 'PEM_CER') {
          m.pem_cer = space(4096)
          m.pem_cer = vi_lla1_cer.pem_cer
          let pas_cer = position.Left(des_pas(rTrim(vi_lla1_cer.pwd_cer)) + space(20), 20)
          let key_cer = position.Left(des_pas(rTrim(vi_lla1_cer.ubi_cer)) + space(120), 120)
        } // End If 

      } else {

        await MessageBox('No existe datos del certificado para poder cancelar el documento', 16)

        return false

      } // End If 

      m.cer_cer = cer_ori
      // recuperamos el valor del certificado
      m = appendM(m, await scatter(m))// scatter 
      //ins_sql=[select cfd_xml,emt_xml,FCA_XML  from comexml where tdo_tdo=']+vi_lla1_doc.tdo_tdo+[' and ndo_doc=]+Alltrim(Str(vi_lla1_doc.ndo_doc))
      //=Iif(SQLExec(num_dbs,ins_sql)>0,.T.,err_sql())

      if (len(allTrim(m.cfd_xml)) > 100) {
        if (m.fca_xml > {}) {
          // si ya tiene el recibo de cancelacion del SAT
          let err_tim = 'CFDI Previamente cancelado en el SAT: Â¿Cancelamos en Siavcom?'
          if (await MessageBox(err_tim, 4)
            == 7) {
            return false

          } // End If 

          ins_sql = upper("exec P_can_doc '" + tdo_tdo + "'," + allTrim(str(ndo_doc)))
          if (Public.value.ndb_emp == 4) {
            // Si es Po
            ins_sql = upper("SELECT  p_can_doc ('" + tdo_tdo + "'," + allTrim(str(ndo_doc))) + ")"
          } // End If 

          if (await SQLExec(ins_sql)
            > 0) {
            await select(are_tra)

            return

          } // End If 

          await select(are_tra)

          return err_sql()
          // ejecutamos rutina de error

        } // End If 

        let UUID = allTrim(obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'UUID'))
        let rfcEmisor = obt_cam_xml(m.cfd_xml, 'cfdi:Emisor', 'rfc')
        let noCertificado = obt_cam_xml(m.cfd_xml, 'cfdi:Comprobante', 'noCertificado')
        let rfcReceptor = obt_cam_xml(m.cfd_xml, 'cfdi:Receptor', 'Rfc')
      } // End If 

      await select('vi_lla1_doc')
      //////////////////////
      // comenzar transaccion cambiando el estatus a cancelado

      m = appendM(m, await scatter(m))// scatter 

      // Inicio replace VFP
      const Recno = await recNo()
      const Alias = await alias()
      await localAlaSql(`update ${Alias} set sta_doc=?  where recno=${Recno} `, ['N'])

      if (!gra_reg()) {
        await MessageBox('Error al tratar de cancelar el documento')

        return false

      } // End If 

    } else {

      await MessageBox('No existe archivo xml para cancelar el documento', 16)

      await select(are_tra)

      return false

    } // End If 

    if (len(allTrim(m.emt_xml)) > 8 && File('timbrado\'+allTrim(m.emt_xml))){
  // si tenemos rutina de cancelacion de timbrado
        let pro_tim = 'timbrado\'+allTrim(m.emt_xml)
        // Set Procedure To ( pro_tim ) Additive 
  // indicamos cual el procedimiento de la empresa de timbrado

        err_tim = cancela_timbrado()
  // ejecutamos la cancelacion por el web service
        //VFP  Procedure Procedure ( pro_tim )
  // liberamos el procedure

        if (upper(position.Left(err_tim, 5)) == 'ERROR') {
        // Si hay error
        await MessageBox(err_tim, 16)

        await select(are_tra)

        return false

      } // End If 

    await select('vi_lla1_doc')

    await requery()

    m = appendM(m, await scatter(m))// scatter 

    est_can = obt_cam_xml(res_tim, 'codEstatus', '')
    // obtiene el cfdi ya timbrado
    let est_UUID = obt_cam_xml(res_tim, 'estatusUUID', '')
    // estatus UUID
    if (est_UUID == '201') {
      est_can = '201'
    } // End If 

    switch (true) {
      //   est_can=obt_cam_xml(res_tim,'estatusUUID','')  && obtiene el cfdi ya timbrado
      case est_can < '0':
        err_tim = 'Error al tratar de cancelar en el SAT'
        await MessageBox(err_tim, 0, 16)

        await select(are_tra)

        return false

        break
      case est_can == '202':
        err_tim = 'UUID Previamente cancelado. Â¿Cancelamos en Siavcom?'
        if (await MessageBox(err_tim, 4)
          == 7) {
          await select(are_tra)

          return false

        } // End If 

        switch (true) {
          case Public.value.ndb_emp == 1:
            // Set Textmerge On 
            //                   exec p_can_doc ?m.tdo_tdo,?m.ndo_doc

            let variable = `				    UPDATE man_comexml SET sta_doc='C' WHERE  tdo_tdo=?m.tdo_tdo AND ndo_doc=?m.ndo_doc\
				`
            // EndText
            est_can = '201'
            break
          case Public.value.ndb_emp == 4:
            //  en funciones en postgres hay que pasar exactamente el tipo de dato ya que si no no encuentra la funcion
            // Set Textmerge On 
            //    ins_sql=" SELECT  p_can_doc ('"+m.tdo_tdo+"',"+Alltrim(Str(m.ndo_doc))+");commit;"

            let variable = `				    UPDATE man_comexml SET sta_doc='C' WHERE  tdo_tdo=?m.tdo_tdo AND ndo_doc=?m.ndo_doc ;\
				    commit;\
				`
          // EndText

        } // End case 

        break
      // Delete File (arc_env)
      case est_can == '203':
        err_tim = 'Folio Fiscal no encontrado.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '204':
        err_tim = 'Folio Fiscal no aplicable o cancelación.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '205':
        err_tim = 'Folio Fiscal No existe.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '206':
        err_tim = 'UUID no corresponde a un CFDI del Sector Primario.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '207':
        err_tim = 'No se especificó el motivo de cancelación o el motivo no es valido.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '208':
        err_tim = 'Folio Sustitución invalido.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '209':
        err_tim = 'Folio Sustitución no requerido.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '210':
        err_tim = 'La fecha de solicitud de cancelación es mayor a la fecha de declaración.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '211':
        err_tim = 'La fecha de solicitud de cancelación lÃ­mite para factura global.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '212':
        err_tim = 'Relación no valida o inexistente.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '300':
        err_tim = 'Usuario no vÃ¡lido.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '301':
        err_tim = 'XML mal formado.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '302':
        err_tim = 'Sello mal formado o invÃ¡lido.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '303':
        err_tim = 'Sello no corresponde a emisor o caducó.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '304':
        err_tim = 'Certificado revocado o caduco.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '305':
        err_tim = 'La fecha de emisión no esta dentro de la vigencia del CSD del Emisor.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '306':
        err_tim = 'EL certificado no es de tipo CSD.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '307':
        err_tim = ' El CFDI contiene un timbre previo.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '308':
        err_tim = 'Certificado no expedido por el SAT.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '309':
        err_tim = 'El patrón de folios para registro fiscal no coincide.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '310':
        err_tim = 'CSD invÃ¡lido.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '401':
        err_tim = 'La fecha y hora de generación se encuentra fuera de rango.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '402':
        err_tim = 'RFC del emisor no se encuentra en el rÃ©gimen de contribuyentes.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '403':
        err_tim = 'La fecha de emisión debe ser posterior al 01 de enero 2011.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '999':
        err_tim = 'Este mensaje es una emulación del ambiente de pruebas de Cancelación.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '1422':
        err_tim = 'Este mensaje es una emulación del ambiente de pruebas de Cancelación.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '1000':
        err_tim = 'Se recibió la respuesta de la petición de forma exitosa.'
        await MessageBox(err_tim, 16)

        break
      case est_can == '1001':
        err_tim = ' No existen peticiones de cancelación en espera de respuesta para el uuid.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '1002':
        err_tim = 'Ya se recibió una respuesta para la petición de cancelación del uuid.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '1003':
        err_tim = 'Sello no norresponde al RFC receptor.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '1004':
        err_tim = 'Existen mÃ¡s de una petición de cancelación para el mismo uuid.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '1005':
        err_tim = 'El uuid es nulo no posee el formato correcto.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '1006':
        err_tim = 'Se rebaso el número mÃ¡ximo de solicitudes permitidas.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '1100':
        err_tim = 'Se obtuvieron las peticiones del RFC Receptor de forma exitosa.'
        await MessageBox(err_tim, 16)

        break
      case est_can == '1101':
        err_tim = 'No existen peticiones para el RFC Receptor.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '2000':
        err_tim = 'Existen cfdi relacionados al folio fiscal.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '2001':
        err_tim = 'No Existen cfdi relacionados al folio fiscal.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '2002':
        err_tim = 'El folio fiscal no pertenece al receptor.'
        await MessageBox(err_tim, 16)

        return false

        break
      case est_can == '201':
        // en proceso de cancelacion
        let acuse = obt_cam_xml(res_tim, 'acuse', '')
        // obtiene el acuse de recibo
        let fca_can = position.Left(obt_cam_xml(acuse, '', 'Fecha'), 19)
        await MessageBox('El cfdi queda con estatus de solicitud de cancelacion ante el SAT :' + fca_can)
        // Messagebox('CFDI en proceso de cancelacion en hacienda :'+fca_can)

        acuse = strtran(acuse, "'", "''")
        // trasfomamos comillas sencilas para poder grabar en MSSQL
        // Set Textmerge On 

        let variable = `	           UPDATE man_COMEXML SET fca_XML='${fca_can}',arc_xml='${acuse}',sta_doc='N' WHERE tdo_tdo=?m.tdo_tdo AND ndo_doc=?m.ndo_doc ;\
			`
        // EndText
        let a = ins_sql
        // Set Safety Off 


        // ejecutamos la instrucicon sql generada
        if (await SQLExec(ins_sql) < 0) {
          err_sql()
          await select(are_tra)
          // seleccionamos el area de trabajo actual

          return false

        } // End If 


        // cerramos transaccion de MSSQL
        if (est_can == '201' && Public.value.ndb_emp == 1 && await SQLExec('commit transaction')
          < 0) {
            =err_sql()
        } // End If 

    } // End case 

  } else {
    // Delete File (arc_env)

    if (await MessageBox('No existe programa para cancelar ' + allTrim(m.emt_xml) + ',Â¿Cancelamos en siavcom?', 4, 'Pregunta')
      == 7) {
      await select(are_tra)

      return

    } // End If 

    switch (true) {
      case Public.value.ndb_emp == 1:
        ins_sql = upper("exec p_can_doc '" + m.tdo_tdo + "'," + allTrim(str(m.ndo_doc)))
        break
      case Public.value.ndb_emp == 4:
        ins_sql = upper("SELECT p_can_doc ('" + m.tdo_tdo + "'," + allTrim(str(m.ndo_doc))) + ")"
    } // End case 

  } // End If 

} else {

  // si no es documento timbrado
  ins_sql = upper("exec P_can_doc '" + tdo_tdo + "'," + allTrim(str(ndo_doc)))
  if (Public.value.ndb_emp == 4) {
    // Si es Po
    ins_sql = upper("SELECT  p_can_doc ('" + tdo_tdo + "'," + allTrim(str(ndo_doc))) + ")"
  } // End If 

  if (await SQLExec(ins_sql)
    > 0) {
    await select(are_tra)

    return

  } // End If 

  await select(are_tra)

  return err_sql()
  // ejecutamos rutina de error

} // End If 

await select(are_tra)

return 

  }   // Fin Procedure
//Return err_sql()   && ejecutamos rutina de error
// ---------------< Consulta de claves alternas >--------------------
// parametros : cop_con  Cliente o proveedor
//    cod_con  Codigo del cliente o proveedor
//    cla_con  Clave de consulta
//    cad_con  cadena de la consulta
// Ult.Mod    : 18/05/2007 Fdo Cuadras
//              - Se cambia la manera de consulta de claves alternas aumentando el tipo de cliente y
//                la fecha de consulta
//-------------------------------------------------------------------------------------------

export async function cla_alt(cop_con: any, cod_con: any, cla_con: any, cad_con: any, tip_con: any, fec_con: any) {
  let m = {}   // inicializamos m
  if (vi_cap_mov.sw_tca == 1) {
    return true

  } // End If 

  return false

}   // Fin Procedure


//!// If Parameters()>4           && SI SE BUSCA PRECIO ESPECIAL
//!//  m.tip_tdn=tip_con
//!//  Select vi_lla1_tca
//!//  Use
//!//  ins_sql="exec P_CAL_PRE_ISU_N '"+m.cla_isu+"','"+m.cop_nom+"','"+m.cod_nom+"','"+m.tip_tdn+"','"+dateToString(m.fec_con)+"'"
//!//  If m.ndb_emp=4 && Si es PostgreSQL
//!//   ins_sql="select P_CAL_PRE_ISU_N ('"+m.cla_isu+"','"+m.cop_nom+"','"+m.cod_nom+"','"+m.tip_tdn+"','"+dateToString(m.fec_con)+"')"
//!//  Endif
//!//  =Iif(SQLExec(num_dbs,ins_sql,'vi_LLA1_TCA')>0,0,err_sql())
//!//  a=ins_sql
//!//  If sw_tca=0   && si no hay datos
//!//   Use  vi_lla1_tca Nodata
//!//  Endif
//!//  Scatter Memvar
//!// //use vi_lla1_tca    && abre la tabla de claves alternas
//!//  res_con=Iif(Reccount()>0,.T.,.F.)
//!// Else                        && UNICAMENTE BUSCA CLAVES ALTERNAS
//!//  Select vi_lla1_tca
//!//  Use vi_lla1_tca    && abre la tabla de claves alternas
//!//  res_con=Iif(Reccount()>0,.T.,.F.)
//!// Endif
// ---------------< Consulta de claves alternas >--------------------
// parametros : cop_con  Cliente o proveedor
//    cod_con  Codigo del cliente o proveedor
//    cla_con  Clave de consulta
//    cad_con  cadena de la consulta
// Ult.Mod    : 18/05/2007 Fdo Cuadras
//              - Se cambia la manera de consulta de claves alternas aumentando el tipo de cliente y
//                la fecha de consulta
//-------------------------------------------------------------------------------------------
export async function cla_alt_des(cop_con: any, cod_con: any, cla_con: any, tip_con: any, for_tie: any) {
  let m = {}   // inicializamos m
  return cla_alt

}   // Fin Procedure
//!// are_tra=Select()   && obtiene la area de trabajo actual
//!// m.cop_nom=cop_con
//!// m.cod_nom=cod_con
//!// m.cla_isu=cla_con
//!// m.tip_tdn='  '
//!// m.fti_con=for_tie
//!// Select vi_lla1_tca
//!// Requery()
//!// //use vi_lla1_tca    && abre la tabla de claves alternas
//!// res_con=Iif(Reccount()>0,.T.,.F.)
//!// Select (are_tra)
//!// Return res_con
// ---------------< Consulta de pedimentos aduanales >--------------------
// parametros : ped_con  Pedimento aduanal
//-------------------------------------------------------------------------------------------

export async function ped_adu(ped_con: any) {
  let m = {}   // inicializamos m
  if (len(Trim(ped_con)) == 0) {
    return false

  } // End If 

  let are_tra = await select()
  // obtiene la area de trabajo actual

  m.ped_ped = ped_con
  await select('vi_lla1_ped')

  await use('vi_lla1_ped', m) // use vi_lla1_ped vi_lla1_ped
  // abre la tabla de pedimentos

  let res_con = iif(await recCount() > 0, true, false)
  await select(are_tra)

  return res_con

}   // Fin Procedure
// ---------------< Consulta de lotes de productos >--------------------
// parametros : lot_con  lote de consulta
//-------------------------------------------------------------------------------------------

export async function con_lot(lot_con: any) {
  let m = {}   // inicializamos m
  if (len(Trim(lot_con)) == 0) {
    return false

  } // End If 

  let are_tra = await select()
  // obtiene la area de trabajo actual

  m.ser_mov = lot_con
  await select('vi_lla1_lot')

  await use('vi_lla1_lot', m) // use vi_lla1_lot vi_lla1_lot
  // abre la tabla de lotes

  let res_con = iif(await recCount() > 0, true, false)
  await select(are_tra)

  return res_con

}   // Fin Procedure
// ---------------< Consulta de insumos >--------------------
// parametros : con_isu  clave del insumo
//-------------------------------------------------------------------------------------------

export async function con_isu(cla_con: any) {
  let m = {}   // inicializamos m
  if (len(Trim(cla_con)) == 0) {
    return false

  } // End If 

  let are_tra = await select()
  // obtiene la area de trabajo actual

  m.cla_isu = cla_con
  await select('vi_lla1_isu')
  // lee datos de insumos

  await use('vi_lla1_isu', m) // use vi_lla1_isu vi_lla1_isu

  await select('vi_lla1_pro')

  await use('vi_lla1_pro', m) // use vi_lla1_pro vi_lla1_pro
  // lee datos de productos

  let res_con = iif(await recCount() > 0, true, false)
  await select(are_tra)

  return res_con

}   // Fin Procedure
// ---------------< ejecucion de query >--------------------
// parametros : ins_sql  instruccion sql a ejecutar
//-------------------------------------------------------------------------------------------


// instrucción a ejecutar
export async function sql_exec(ins_sql: string) {
  let m = {}   // inicializamos m
  // Private are_tra 

  if (Public.value.ndb_emp == 4) {
    let ins_sql = traduce_tsql(ins_sql)
  } // End If 

  let a = ins_sql
  let are_tra = await select()
  // obtiene la area de trabajo actual

  await select('0')

  if (await SQLExec(ins_sql, 'RESULTADO')
    < 0) {
    err_sql()
    await select(are_tra)

    return 0

  } // End If 

  await select('resultado')

  const res_que = await scatter()// scatter 
  // resultado del query

  releaseUse() // use 

  await select(are_tra)

  if (Public.value.ndb_emp == 2) {
    // Sqlcommit ( Public.value.num_dbs ) 

    await SQLExec("commit work;")

  } // End If 

  return res_que(1)

}   // Fin Procedure
////////////////////////// FACTURACION ELECTRONICA ///////////////////////////////////////
// ---------------< detalle de la cadena >--------------------
// parametros : des_det   Header del documento
//-------------------------------------------------------------------------------------------

export async function lim_det() {
  let m = {}   // inicializamos m
  m.det_ori = ' '
  return true

}   // Fin Procedure
//!// // ---------------< genera descripcion del detalle >--------------------
//!// // parametros : des_det   Header del documento
//!// //-------------------------------------------------------------------------------------------
//!// Procedure gen_des_det
//!// Parameters Descri
//!// m.des_det=Descri
//!// Return .T.
// ---------------< genera conceptos CFD >--------------------
// Genera el nodo XML de los conceptos del cfdi de la facturacion electronica
// segun lo definido en el archivo comecfd
//-------------------------------------------------------------------------------------------

export async function gen_con_cfd() {
  let m = {}   // inicializamos m
  // Private are_tra , tdo_ori , sw_err 

  if (m.sel_dig > '  ') {
    // ya esta generado el cfd
    return m.con_xml

  } // End If 

  m.num_det = m.num_det + 1
  let are_tra = await select()

  await select('vi_cap_mov')

  m = appendM(m, await scatter(m))// scatter 

  if (sw_con) {
    // si es nuevo el archivo inicializamos variables
    m.con_cad = ''
    // conceptos para cadena original
    m.con_xml = '<Conceptos> '
    // conceptos para archivo XML
    m.cad_ori = '||'
    // cadena original
    m.cad_XML = ''
    // cadena XML
    let sw_con = false
    // apagamos la bandera
  } // End If 

  m.cod_nom = '000000'
  // asignamos el valores
  m.tdo_tdo = vi_lla1_doc.tdo_tdo
  m.blo_cfd = 'Conceptos'
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

  await select('vi_cap_cfd')

  await goto('TOP')
  //!// If Select('vi_cap_cfd')<=0   && si no esta abierta la vista de definicion del comprobante fiscal digital
  //!//  Select 0
  //!//  Use vi_cap_cfd
  //!// Else
  //!//  Select vi_cap_cfd
  //!//  Requery()
  //!// Endif

  m.con_xml = m.con_xml + '<Concepto '
  // calculo de precio y descuentos
  m.des_tot = 100 - ((100 - m.de1_mov) * ((100 - m.de2_mov) / 100) * ((100 - m.de3_mov) / 100) * ((100 - m.de4_mov) / 100) * ((100 - m.de5_mov) / 100))
  m.des_mov = m.pve_mov * (m.des_tot / 100)
  // Calculamos el monto del descuento
  m.pve_mov = m.pve_mov - m.des_mov
  // VFP SCAN 
  // generación de conceptos
  while (!eof()) {
    m = appendM(m, await scatter(m))// scatter 
    let sw_err = false      let ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
    // si genera xml y no permite blancos y su resultado es blanco
    if (no_colapsa()) {
      await MessageBox('Error en la clave=' + allTrim(m.cla_isu) + ', bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

      m.con_xml = m.con_xml + 'Error >>>> campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd)
      sw_err = true
    } // End If 

    // Si aparece en el xml
    if (!sw_err && si_colapsa()) {
      // y se incluye en el xml o cadena original
      if (m.cao_cfd == 1) {
        // pertenece a la cadena original
        m.con_cad = m.con_cad + rTrim(lTrim(val_res)) + '|'
        // cadena original
      } // End If 

      m.con_xml = m.con_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
    } // End If 

    skip()
  } // End while 

  m.con_xml = rTrim(m.con_xml) + '> '
  m.blo_cfd = 'Impuesto/Traslado'
  ////////////////////  Impuestos por detalle de movimiento Traslados
  Public.value.sw_imp = false
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom AND ( cao_cfd = 1 OR xml_cfd = 1 ) Order By ord_cfd")

  await select('vi_cap_cfd')

  if (await recCount() > 0) {

    // Select vi_cap_cfd
    // Requery()
    if (cometdo.dba_tdo == 'CFG' || cometdo.dba_tdo == 'CG4') {
      await select('vi_cap_mov')

      let reg_act = await recNo()

      // Calculamos el total los impuestos de traslados
      if (sep_ieps == 'SI') {
        let res = await localAlaSql("INSERT INTO traslados_con select max(cl0_sat) As impuesto , Max ( fa0_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa0_imp ) ) = 'TASA' , im0_mov / 100 , im0_mov ) ) As TasaOCuota , Sum ( ba0_mov ) As Base , Sum ( ii0_mov ) As Importe , TA0_ISU As tar_isu From vi_cap_mov Where im0_mov > = 0 AND ba0_mov != 0 AND TA0_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA0_ISU UNION Select Max ( Public.value.cl1_sat ) As impuesto , Max ( fa1_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa1_imp ) ) = 'TASA' , im1_mov / 100 , im1_mov ) ) As TasaOCuota , Sum ( ba1_mov ) As Base , Sum ( ii1_mov ) As Importe , TA1_ISU As tar_isu From vi_cap_mov Where im1_mov > = 0 AND ba1_mov != 0 AND TA1_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA1_ISU UNION SELECT Max ( Public.value.cl2_sat ) As impuesto , Max ( fa2_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa2_imp ) ) = 'TASA' , im2_mov / 100 , im2_mov ) ) As TasaOCuota , Sum ( ba2_mov ) As Base , Sum ( ii2_mov ) As Importe , TA2_ISU As tar_isu From vi_cap_mov Where im2_mov > = 0 AND ba2_mov != 0 AND TA2_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA2_ISU UNION SELECT Max ( Public.value.cl3_sat ) As impuesto , Max ( fa3_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa3_imp ) ) = 'TASA' , im3_mov / 100 , im3_mov ) ) As TasaOCuota , Sum ( ba3_mov ) As Base , Sum ( ii3_mov ) As Importe , TA3_ISU As tar_isu From vi_cap_mov Where im3_mov > = 0 AND ba3_mov != 0 AND TA3_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA3_ISU UNION SELECT Max ( Public.value.cl4_sat ) As impuesto , Max ( fa4_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa4_imp ) ) = 'TASA' , im4_mov / 100 , im4_mov ) ) As TasaOCuota , Sum ( ba4_mov ) As Base , Sum ( ii4_mov ) As Importe , TA4_ISU As tar_isu From vi_cap_mov Where im4_mov > = 0 AND ba4_mov != 0 AND TA4_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA4_ISU UNION SELECT Max ( Public.value.cl5_sat ) As impuesto , Max ( fa5_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa5_imp ) ) = 'TASA' , im5_mov / 100 , im5_mov ) ) As TasaOCuota , Sum ( ba5_mov ) As Base , Sum ( ii5_mov ) As Importe , TA5_ISU As tar_isu From vi_cap_mov Where im5_mov > = 0 AND ba5_mov != 0 AND TA5_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA5_ISU")

      } else {

        let res = await localAlaSql("INSERT INTO traslados_con select max(cl0_sat) As impuesto , Max ( fa0_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa0_imp ) ) = 'TASA' , im0_mov / 100 , im0_mov ) ) As TasaOCuota , Sum ( ba0_mov ) As Base , Sum ( ii0_mov ) As Importe , TA0_ISU As tar_isu From vi_cap_mov Where im0_mov > = 0 AND ba0_mov != 0 AND TA0_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA0_ISU UNION Select Max ( Public.value.cl1_sat ) As impuesto , Max ( fa1_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa1_imp ) ) = 'TASA' , im1_mov / 100 , im1_mov ) ) As TasaOCuota , Sum ( ba1_mov ) As Base , Sum ( ii1_mov ) As Importe , TA1_ISU As tar_isu From vi_cap_mov Where im1_mov > = 0 AND ba1_mov != 0 AND TA1_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA1_ISU UNION SELECT Max ( Public.value.cl3_sat ) As impuesto , Max ( fa3_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa3_imp ) ) = 'TASA' , im3_mov / 100 , im3_mov ) ) As TasaOCuota , Sum ( ba3_mov ) As Base , Sum ( ii3_mov ) As Importe , TA3_ISU As tar_isu From vi_cap_mov Where im3_mov > = 0 AND ba3_mov != 0 AND TA3_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA3_ISU UNION SELECT Max ( Public.value.cl4_sat ) As impuesto , Max ( fa4_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa4_imp ) ) = 'TASA' , im4_mov / 100 , im4_mov ) ) As TasaOCuota , Sum ( ba4_mov ) As Base , Sum ( ii4_mov ) As Importe , TA4_ISU As tar_isu From vi_cap_mov Where im4_mov > = 0 AND ba4_mov != 0 AND TA4_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA4_ISU UNION SELECT Max ( Public.value.cl5_sat ) As impuesto , Max ( fa5_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa5_imp ) ) = 'TASA' , im5_mov / 100 , im5_mov ) ) As TasaOCuota , Sum ( ba5_mov ) As Base , Sum ( ii5_mov ) As Importe , TA5_ISU As tar_isu From vi_cap_mov Where im5_mov > = 0 AND ba5_mov != 0 AND TA5_ISU > '  ' AND dpe_mov = dpe_pub AND npe_mov = npe_pub Group By TA5_ISU")

      } // End If 

      await select('traslados_con')
      //////////////////////////

      // VFP SCAN 
      while (!eof()) {
        m = appendM(m, await scatter(m))// scatter 
        await select('vi_cap_cfd')
        await goto('TOP')
        //Requery()
        if (!Public.value.sw_imp) {
          Public.value.sw_imp = true
          m.con_xml = m.con_xml + '<Impuestos><Traslados> '
        } // End If 
        let sw_tra = true          m.con_xml = m.con_xml + '<Traslado '          // VFP SCAN 
        while (!eof()) {
          sw_err = false            m = appendM(m, await scatter(m))// scatter 
          ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
          // si genera xml y no permite blancos y su resultado es blanco
          if (no_colapsa()) {
            await MessageBox('Error en la clave=' + allTrim(m.cla_isu) + ', bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

            m.con_xml = m.con_xml + 'Error >>>> campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd)
            sw_err = true
          } // End If 
          if (!sw_err && si_colapsa()) {
            // y se incluye en el xml o cadena original
            if (m.cao_cfd == 1) {
              m.con_cad = m.con_cad + rTrim(val_res) + '|'
              // cadena original
            } // End If 

            m.con_xml = m.con_xml + rTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
          } // End If 

          skip()
        } // End while 
        await select('traslados_con')
        m.con_xml = m.con_xml + '></Traslado>'
        skip()
      } // End while 

      await select('vi_cap_mov')

      await goto(reg_act)

    } else {
      //////////////////////////

      for (let num_imp = 0; num_imp < 5; num_imp++) {
        let tar_bas = '   '
        // tarifa base
        let bas_imp = 0
        // importe base para el calculo del impuesto
        let cla_imp = '   '
        // clave del impiuesto segun el sat
        let fac_imp = '    '
        // Tipo de calculo Tasa , Cuota o Exento
        let toc_imp = 0
        // Importe tasa o cuota del impuesto . expresado en decimales cuando es un porcentaje
        let iim_imp = 0
        // importe del impuesto en dinero del movimiento
        switch (true) {
          case num_imp == 0:
            tar_bas = TA0_ISU
            // tarifa base en la tabla de impuestos
            bas_imp = ba0_mov
            // importe base para el calculo del impuesto
            cla_imp = cl0_sat
            // clave del impiuesto segun el sat
            fac_imp = fa0_imp
            // Tipo de calculo Tasa , Cuota o Exento
            toc_imp = im0_mov
            // Importe tasa o cuota del impuesto
            iim_imp = ii0_mov
            // importe del impuesto en dinero del movimiento
            break
          case num_imp == 1:
            tar_bas = TA1_ISU
            // tarifa base en la tabla de impuestos
            bas_imp = ba1_mov
            // importe base para el calculo del impuesto
            cla_imp = Public.value.cl1_sat
            // clave del impiuesto segun el sat
            fac_imp = fa1_imp
            // Tipo de calculo Tasa , Cuota o Exento
            toc_imp = im1_mov
            // Importe tasa o cuota del impuesto
            iim_imp = ii1_mov
            // importe del impuesto en dinero del movimiento
            break
          case num_imp == 2 && sep_ieps == 'SI':
            tar_bas = TA2_ISU
            // tarifa base en la tabla de impuestos
            bas_imp = iif(sep_ieps == 'NO', 0, ba2_mov)
            // importe base para el calculo del impuesto
            cla_imp = Public.value.cl2_sat
            // clave del impuesto segun el sat
            fac_imp = fa2_imp
            // Tipo de calculo Tasa , Cuota o Exento
            toc_imp = im2_mov
            // Importe tasa o cuota del impuesto
            iim_imp = ii2_mov
            // importe del impuesto en dinero del movimiento
            break
          case num_imp == 3:
            tar_bas = TA3_ISU
            // tarifa base en la tabla de impuestos
            bas_imp = ba3_mov
            // importe base para el calculo del impuesto
            cla_imp = Public.value.cl3_sat
            // clave del impuesto segun el sat
            fac_imp = fa3_imp
            // Tipo de calculo Tasa , Cuota o Exento
            toc_imp = (im3_mov)
            // Importe tasa o cuota del impuesto
            iim_imp = (ii3_mov)
            // importe del impuesto en dinero del movimiento
            break
          case num_imp == 4:
            tar_bas = TA4_ISU
            // tarifa base en la tabla de impuestos
            bas_imp = ba4_mov
            // importe base para el calculo del impuesto
            cla_imp = Public.value.cl4_sat
            // clave del impuesto segun el sat
            fac_imp = fa4_imp
            // Tipo de calculo Tasa , Cuota o Exento
            toc_imp = (im4_mov)
            // Importe tasa o cuota del impuesto
            iim_imp = (ii4_mov)
            // importe del impuesto en dinero del movimiento
            break
          case num_imp == 5:
            tar_bas = TA5_ISU
            // tarifa base en la tabla de impuestos
            bas_imp = ba5_mov
            // importe base para el calculo del impuesto
            cla_imp = Public.value.cl5_sat
            // clave del impuesto segun el sat
            fac_imp = fa5_imp
            // Tipo de calculo Tasa , Cuota o Exento
            toc_imp = (im5_mov)
            // Importe tasa o cuota del impuesto
            iim_imp = (ii5_mov)
          // importe del impuesto en dinero del movimiento
        } // End case 

        toc_imp = iif(allTrim(upper(fac_imp)) == 'TASA', toc_imp / 100, toc_imp)
        // si la base del calculo del impuesto en en base a una tas( %) se divide entre 100
        await goto('TOP')
        //  bas_imp=Iif(cla_imp='003',m.vol_pro,bas_imp)   && tarifa base en la tabla de impuestos si es por volumen la cambia

        if (tar_bas > '  ' && toc_imp >= 0 && bas_imp != 0) {
          // si hay tarifa base se presenta
          if (!Public.value.sw_imp) {
            Public.value.sw_imp = true
            m.con_xml = m.con_xml + '<Impuestos><Traslados> '
          } // End If 

          sw_tra = true
          m.con_xml = m.con_xml + '<Traslado '
          // VFP SCAN 
          while (!eof()) {
            sw_err = false              m = appendM(m, await scatter(m))// scatter 
            ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
            // si genera xml y no permite blancos y su resultado es blanco
            if (no_colapsa()) {
              await MessageBox('Error en la clave=' + allTrim(m.cla_isu) + ', bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

              m.con_xml = m.con_xml + 'Error >>>> campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd)
              sw_err = true
            } // End If 
            if (!sw_err && si_colapsa()) {
              // y se incluye en el xml o cadena original
              if (m.cao_cfd == 1) {
                m.con_cad = m.con_cad + rTrim(val_res) + '|'
                // cadena original
              } // End If 

              m.con_xml = m.con_xml + rTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
            } // End If 

            skip()
          } // End while 

          m.con_xml = m.con_xml + '></Traslado>'
        } // End If 

      } // End For; 
      num_imp
    } // End If 

    if (Public.value.sw_imp) {
      m.con_xml = rTrim(m.con_xml) + '</Traslados>'
    } // End If 

  } // End If 

  m.blo_cfd = 'Impuesto/Retencion'
  //////////////////////////////////////////////////////////////
  ////////////////////  Impuestos por detalle de movimiento Traslados
  let sw_ret = false
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom AND ( cao_cfd = 1 OR xml_cfd = 1 ) Order By ord_cfd")

  await select('vi_cap_cfd')

  if (await recCount() > 0) {
    for (let num_imp = 0; num_imp < 5; num_imp++) {
      tar_bas = '   '
      // tarifa base
      bas_imp = 0
      // importe base para el calculo del impuesto
      cla_imp = '   '
      // clave del impiuesto segun el sat
      fac_imp = '    '
      // Tipo de calculo Tasa , Cuota o Exento
      toc_imp = 0
      // Importe tasa o cuota del impuesto
      iim_imp = 0
      // importe del impuesto en dinero del movimiento
      switch (true) {
        case num_imp == 0:
          tar_bas = TA0_ISU
          // tarifa base en la tabla de impuestos
          bas_imp = ba0_mov
          // importe base para el calculo del impuesto
          cla_imp = cl0_sat
          // clave del impiuesto segun el sat
          fac_imp = fa0_imp
          // Tipo de calculo Tasa , Cuota o Exento
          toc_imp = (im0_mov)
          // Importe tasa o cuota del impuesto
          iim_imp = Abs(ii0_mov)
          // importe del impuesto en dinero del movimiento
          break
        case num_imp == 1:
          tar_bas = TA1_ISU
          // tarifa base en la tabla de impuestos
          bas_imp = ba1_mov
          // importe base para el calculo del impuesto
          cla_imp = Public.value.cl1_sat
          // clave del impiuesto segun el sat
          fac_imp = fa1_imp
          // Tipo de calculo Tasa , Cuota o Exento
          toc_imp = (im1_mov)
          // Importe tasa o cuota del impuesto
          iim_imp = Abs(ii1_mov)
          // importe del impuesto en dinero del movimiento
          break
        case num_imp == 2:
          tar_bas = TA2_ISU
          // tarifa base en la tabla de impuestos
          bas_imp = ba2_mov
          // importe base para el calculo del impuesto
          cla_imp = Public.value.cl2_sat
          // clave del impuesto segun el sat
          fac_imp = fa2_imp
          // Tipo de calculo Tasa , Cuota o Exento
          toc_imp = (im2_mov)
          // Importe tasa o cuota del impuesto
          iim_imp = Abs(ii2_mov)
          // importe del impuesto en dinero del movimiento
          break
        case num_imp == 3:
          tar_bas = TA3_ISU
          // tarifa base en la tabla de impuestos
          bas_imp = ba3_mov
          // importe base para el calculo del impuesto
          cla_imp = Public.value.cl3_sat
          // clave del impuesto segun el sat
          fac_imp = fa3_imp
          // Tipo de calculo Tasa , Cuota o Exento
          toc_imp = (im3_mov)
          // Importe tasa o cuota del impuesto
          iim_imp = Abs(ii3_mov)
          // importe del impuesto en dinero del movimiento
          break
        case num_imp == 4:
          tar_bas = TA4_ISU
          // tarifa base en la tabla de impuestos
          bas_imp = ba4_mov
          // importe base para el calculo del impuesto
          cla_imp = Public.value.cl4_sat
          // clave del impuesto segun el sat
          fac_imp = fa4_imp
          // Tipo de calculo Tasa , Cuota o Exento
          toc_imp = (im4_mov)
          // Importe tasa o cuota del impuesto
          iim_imp = Abs(ii4_mov)
          // importe del impuesto en dinero del movimiento
          break
        case num_imp == 5:
          tar_bas = TA5_ISU
          // tarifa base en la tabla de impuestos
          bas_imp = ba5_mov
          // importe base para el calculo del impuesto
          cla_imp = Public.value.cl5_sat
          // clave del impuesto segun el sat
          fac_imp = fa5_imp
          // Tipo de calculo Tasa , Cuota o Exento
          toc_imp = (im5_mov)
          // Importe tasa o cuota del impuesto
          iim_imp = Abs(ii5_mov)
        // importe del impuesto en dinero del movimiento
      } // End case 

      toc_imp = iif(allTrim(upper(fac_imp)) == 'TASA', toc_imp / 100, toc_imp)
      // si la base del calculo del impuesto en en base a una tas( %) se divide entre 100
      bas_imp = iif(cla_imp == '003', m.vol_pro, bas_imp)
      // tarifa base en la tabla de impuestos si es por volumen la cambia
      await goto('TOP')

      if (tar_bas > '  ' && toc_imp < 0 && bas_imp != 0) {
        // solo si hay tasa y impuesto se genera xml
        toc_imp = Abs(toc_imp)
        if (!sw_ret) {
          if (!Public.value.sw_imp) {

            m.con_xml = m.con_xml + '<Impuestos>'
            Public.value.sw_imp = true
          } // End If 

          m.con_xml = m.con_xml + '<Retenciones>'
          sw_ret = true
        } // End If 

        m.con_xml = m.con_xml + '<Retencion '
        // VFP SCAN 
        while (!eof()) {
          sw_err = false            m = appendM(m, await scatter(m))// scatter 
          ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
          // si genera xml y no permite blancos y su resultado es blanco
          if (no_colapsa()) {
            await MessageBox('Error en la clave=' + allTrim(m.cla_isu) + ', bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

            m.con_xml = m.con_xml + 'Error >>>> campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd)
            sw_err = true
          } // End If 
          if (!sw_err && si_colapsa()) {
            // y se incluye en el xml o cadena original
            if (m.cao_cfd == 1) {
              m.con_cad = m.con_cad + rTrim(val_res) + '|'
              // cadena original
            } // End If 

            m.con_xml = m.con_xml + rTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
          } // End If 

          skip()
        } // End while 

        m.con_xml = m.con_xml + '></Retencion>'
      } // End If 

    } // End For; 
    num_imp
    if (sw_ret) {
      m.con_xml = rTrim(m.con_xml) + '</Retenciones>'
    } // End If 

  } // End If 


  //////////////////////////////////////////// Fin Retenciones //////////////////////////////////////////////////////
  if (Public.value.sw_imp) {
    m.con_xml = rTrim(m.con_xml) + '</Impuestos> '
  } // End If 

  m.blo_cfd = 'InformacionAduanera'
  ////////////////////////////////////////// Fin Impuestos por concepto ////////////////////////////////
  //////////////// < Pedimentos y cuentas prediales
  ////////////////////////////////////// < Pedimentos aduanales
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

  await select('vi_cap_cfd')


  // Requery()
  if (await recCount() > 0) {
    if (len(rTrim(m.ped_ped)) > 6) {
      m.con_xml = m.con_xml + '<InformacionAduanera '
      await goto('TOP')
      // Select vi_cap_cfd
      // Requery()

      // VFP SCAN 
      //        ren_esc=ren_esc+'<InformacionAduanera '
      while (!eof()) {
        sw_err = false          m = appendM(m, await scatter(m))// scatter 
        ins_fox = 'val_res=ALLTRIM(' + m.var_cfd + ')' & ins_fox
        // se quita la eliminacion de caracteres extraÃ±os  cfdi 3.3
        //     ins_fox='val_res=mod_car('+Alltrim(m.var_cfd)+')'
        // si genera xml y no permite blancos y su resultado es blanco
        if (no_colapsa()) {
          await MessageBox('Error en la clave=' + allTrim(m.cla_isu) + ', bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

          m.con_xml = m.con_xml + 'Error >>>> campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd)
          sw_err = true
        } // End If 
        if (!sw_err && si_colapsa()) {
          // y se incluye en el xml o cadena original
          if (m.cao_cfd == 1) {
            m.con_cad = m.con_cad + rem_car(rTrim(lTrim(val_res))) + '|'
            // cadena original se le quitamos los caracteres raros
          } // End If 

          m.con_xml = m.con_xml + rTrim(m.cam_cfd) + '="' + allTrim(val_res) + '" '
          // xml original no le quitamos los caracteres raros
        } // End If 

        skip()
      } // End while 

      m.con_xml = rTrim(m.con_xml) + '/> '
    } // End If 

  } // End If 

  m.blo_cfd = 'CuentaPredial'
  //////////////////////////////////// Predial
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

  await select('vi_cap_cfd')

  await goto('TOP')
  //Requery()

  let inisca = 0
  // VFP SCAN 
  while (!eof()) {
    sw_err = false      m = appendM(m, await scatter(m))// scatter 
    ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox      if (len(rTrim(val_res)) > 0) {
      if (inisca == 0) {
        m.con_xml = m.con_xml + '<CuentaPredial '
      } // End If 

      inisca = inisca + 1

      // si genera xml y no permite blancos y su resultado es blanco
      if (no_colapsa()) {
        await MessageBox('Error en la en la clave=' + allTrim(m.cla_isu) + ', bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

        m.con_xml = m.con_xml + 'Error >>>> campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd)
        sw_err = true
      } // End If 

      if (!sw_err && si_colapsa()) {
        // y se incluye en el xml o cadena original
        if (m.cao_cfd == 1) {
          m.con_cad = m.con_cad + rTrim(lTrim(val_res)) + '|'
          // cadena original
        } // End If 

        m.con_xml = m.con_xml + rTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
      } // End If 

    } // End If 

    skip()
  } // End while 

  if (inisca > 0) {
    m.con_xml = rTrim(m.con_xml) + '/> '
  } // End If 

  m.con_xml = rTrim(m.con_xml) + '</Concepto> '
  //////////////////////////////////////////////////////////////////////////////
  // cierra la estrcutura concepto
  await select(are_tra)
  //Do det_add  && Genera el detalle de la addenda

  return m.con_xml

}   // Fin Procedure
////////////////////////////< Funcionea que revisa si no permite colapsarse el campo>--------------

export async function no_colapsa() {
  let m = {}   // inicializamos m
  return m.xml_cfd = 1 && m.cll_cfd=0 && ((m.dbl_cfd = 0 && len(rTrim(lTrim(val_res)))= 0) || (m.dbl_cfd = 1 && val(rTrim(lTrim(val_res)))=0))

}   // Fin Procedure

export async function si_colapsa() {
  let m = {}   // inicializamos m
  return m.xml_cfd = 1 && (m.cll_cfd = 0 || (m.cll_cfd = 1 && ((m.dbl_cfd = 0 && position.Left(val_res, 2) != '" "' && position.Left(val_res, 2) != '""' && len(allTrim(val_res)) > 0) || (m.dbl_cfd = 1 && val(strtran(allTrim(val_res), '"', '')) > 0))))
  // dato numerico y valor mayor que cero

}   // Fin Procedure
//? VAL(STRTRAN(ALLTRIM(val_res),'"',''))
// ---------------< genera cadena original >--------------------
//  Genera el XML del CFDI Header
// parametros : key_cer   Nombre de la llave privada segun la genero el solcedi
//                pas_cer   Password del certificado
//-------------------------------------------------------------------------------------------


// incluye addenda
export async function gen_cadena(inc_addenda: string) {
  let m = {}   // inicializamos m
  // Public inc_ade 

  // Private sw_pmu 
  // sw pago multiple

  let sw_pmu = false
  m.xml_doctos = ''
  // cuando timbramos varios pagos aqui va el xml de todos los complemetos de pago
  if (Parameters() == 1 && inc_addenda == 'PM') {
    // PM indica pago multiple
    sw_pmu = true
    // prendemos sw de pago multiple
  } // End If 

  // Private are_tra 

  let inc_ade = false
  if (Parameters() == 1 && inc_addenda == 'A') {
    inc_ade = true
  } // End If 

  if (m.sel_dig > '  ') {
    // ya esta generado el cfd
    return m.cad_ori

  } // End If 

  m.ver_xml = "3.2"
  let are_tra = await select()
  //,pas_cer

  m.cod_nom = '000000'
  // generamos el header
  // asignamos el valores
  m.tdo_tdo = vi_lla1_doc.tdo_tdo
  m.blo_cfd = 'Comprobante'
  // variable para seleccionar los datos dentro de la definicion
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")
  // del comprobante

  await select('vi_cap_cfd')

  await goto('TOP')
  // aumentar estos caracteres  EF BB BF   chr(239)+chr(187)+chr(191)

  m.cad_XML = char(239) + char(187) + char(191) + '<?xml version="1.0" encoding="UTF-8"?> <Comprobante '
  // VFP SCAN 
  while (!eof()) {
    m = appendM(m, await scatter(m))// scatter 
    if (upper(m.cam_cfd) != 'SELLO') {
      let ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')'
        & ins_fox

      // si genera xml y no permite blancos y su resultado es blanco
      if (no_colapsa()) {
        await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

        await select(are_tra)

        return

      } // End If 

      if (si_colapsa()) {
        // y se incluye en el xml o cadena original
        if (m.cao_cfd == 1) {
          m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
          // cadena original
        } // End If 

        m.cad_XML = m.cad_XML + rTrim(lTrim(m.cam_cfd)) + '="' + rem_car(val_res) + '" '
      } // End If 

      if (allTrim(cam_cfd) == 'Version') {
        // tomamos la version del cfdi para hacer cambios necesarios
        m.ver_xml = val_res
        // version del cfdi
      } // End If 

    } // End If 

    skip()
  } // End while 

  m.tdo_tdo = vi_lla1_doc.tdo_tdo
  //////////////////////////////////////////////////////////////////////////////////////////////
  // Informacion global CFDI ver 4 Factura Global
  // 20/Feb/2022 .- Se aumenta m.glo_xml
  //////////////////////////////////////////////////////////////////////////////////////////////////
  m.blo_cfd = 'InformacionGlobal'
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

  await select('vi_cap_cfd')

  await goto('TOP')
  // Requery()

  let sw_glo = false
  // VFP SCAN 
  while (!eof()) {
    sw_glo = true      m = appendM(m, await scatter(m))// scatter 
    ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
    //         ins_fox='val_res='+m.var_cfd
    // si genera xml y no permite blancos y su resultado es blanco
    if (no_colapsa()) {
      await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

      await select(are_tra)

      return

    } // End If 
    if (si_colapsa()) {
      // y se incluye en el xml o cadena original
      if (m.cao_cfd == 1) {
        m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
        // cadena original
      } // End If 

      m.glo_xml = m.glo_xml + rem_car(allTrim(m.cam_cfd)) + '="' + rem_car(val_res) + '" '
    } // End If 

    skip()
  } // End while 

  if (sw_glo && len(allTrim(m.glo_xml)) > 5) {
    m.glo_xml = '<InformacionGlobal ' + m.glo_xml + '/>'
  } // End If 

  let rel_xml = ''
  //////////////////////////////////////////////////////////////////////////////////
  // TipoRelacion
  await select('vi_lla1_doc')
  //If vi_lla1_doc.tre_sat>' '   && Si hay CFDI relacionados con este CFDI

  if (vi_lla1_doc.tre_sat > ' ') {
    // Si hay Tipo de relacion de CFDI relacionados con este CFDI
    m.dre_doc = ''
    let sw_dre = false
    if (await select('docxml')
      > 0) {
      try {
        m.dre_doc = Strconv(docxml.dre_doc, 14)                    sw_dre = true
      }
      catch (error) {
        sw_dre = false
      } // End Try

    } // End If 

    m.blo_cfd = 'CfdiRelacionados'
    let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

    await select('vi_cap_cfd')

    await goto('TOP')
    // Requery()

    m.rel_xml = '<CfdiRelacionados '
    // VFP SCAN 
    while (!eof()) {
      m = appendM(m, await scatter(m))// scatter 
      ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
      //         ins_fox='val_res='+m.var_cfd
      // si genera xml y no permite blancos y su resultado es blanco
      if (no_colapsa()) {
        await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

        await select(are_tra)

        return

      } // End If 
      if (si_colapsa()) {
        // y se incluye en el xml o cadena original
        if (m.cao_cfd == 1) {
          m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
          // cadena original
        } // End If 

        m.rel_xml = m.rel_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
      } // End If 

      skip()
    } // End while 

    m.rel_xml = m.rel_xml + '>'
    m.blo_cfd = 'CfdiRelacionados/CfdiRelacionado'
    let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

    await select('vi_cap_cfd')


    // If Select('vi_imp_uuid_rel')=0
    //  Select 0
    // Else
    if (await select('vi_imp_uuid_rel')
      > 0) {
      await select('vi_imp_uuid_rel')

      releaseUse() // use 
      // 4/jun/2018

    } // End If 

    await select('0')

    switch (true) {
      case m.dre_doc > '  ':
        await localAlaSql(' CREATE TABLE vi_imp_uuid_rel (tdo_tdo CHAR(3),ndo_docint,fec_docdate,tot_doccurrency,uuid CHAR(36),ref_doc CHAR(80))')

        Xmltocursor(m.dre_doc, 'vi_imp_uuid_rel', 8192)
        break
      case cometdo.coa_tdo == 'A' && cometdo.tip_cfd != 'P':
        //vi_lla1_doc.tre_sat='01'   && si es un abono que salda documentos
        m.tdo_tdo = vi_lla1_doc.tdo_tdo
        // asignamos el documento relacionado
        m.ndo_doc = vi_lla1_doc.ndo_doc
        let ins_sql = 'select SUM(mon_pag) as mon_pag from vi_imp_pag where tdo_tdo=?m.tdo_tdo and ndo_doc=?m.ndo_doc'
        if (await SQLExec(ins_sql)
          < 0) {
          =err_sql()
          await MessageBox('No se pudo obtener los uuid relacionados de este documento', 16, 'Error', 5000)

          return false

        } // End If 

        if (sqlresult.mon_pag + .045 < vi_lla1_doc.imp_doc + vi_lla1_doc.im0_doc + vi_lla1_doc.im1_doc + vi_lla1_doc.im2_doc + vi_lla1_doc.im3_doc + vi_lla1_doc.im4_doc + vi_lla1_doc.im5_doc) {
          await MessageBox('El abono no esta totalmente asignado', 16, 'Error', 5000)

          return false

        } // End If 

        ins_sql = 'select UUID_FAC as UUID from vi_imp_pag where tdo_tdo=?m.tdo_tdo and ndo_doc=?m.ndo_doc'
        if (await SQLExec(ins_sql, 'vi_imp_uuid_rel')
          < 0) {
          =err_sql()
          await MessageBox('No se pudo obtener los uuid relacionados de este documento', 16, 'Error', 5000)

          return false

        } // End If 

        break        default: m.tdo_tdo = vi_lla1_doc.tdr_doc
        // asignamos el documento relacionado
        m.ndo_doc = vi_lla1_doc.ndr_doc
        await use('vi_lla1_xmlaliasvi_imp_uuid_rel', m) // use vi_lla1_xml vi_lla1_xml

    } // End case 

    await select('vi_imp_uuid_rel')

    await goto('TOP')

    // VFP SCAN 
    while (!eof()) {
      m.rel_xml = m.rel_xml + '<CfdiRelacionado '        await select('vi_cap_cfd')
      await goto('TOP')
      //   Select vi_imp_rel_uuid
      // VFP SCAN 
      while (!eof()) {
        m = appendM(m, await scatter(m))// scatter 
        ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
        //         ins_fox='val_res='+m.var_cfd
        // si genera xml y no permite blancos y su resultado es blanco
        if (no_colapsa()) {
          await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

          await select(are_tra)

          return

        } // End If 
        if (si_colapsa()) {
          // y se incluye en el xml o cadena original
          if (m.cao_cfd == 1) {
            m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
            // cadena original
          } // End If 

          m.rel_xml = m.rel_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
        } // End If 

        skip()
      } // End while 
      m.rel_xml = m.rel_xml + '/>'        await select('vi_imp_uuid_rel')
      // Cierra la etiqueta

      skip()
    } // End while 

    m.rel_xml = m.rel_xml + '</CfdiRelacionados>  '
  } // End If 

  m.blo_cfd = 'Emisor'
  //Fin tipo de relacion
  ////////////////////////////////////
  // emisor
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

  await select('vi_cap_cfd')

  await goto('TOP')
  // Requery()

  m.emi_xml = '<Emisor '
  // VFP SCAN 
  while (!eof()) {
    m = appendM(m, await scatter(m))// scatter 
    ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
    //         ins_fox='val_res='+m.var_cfd
    // si genera xml y no permite blancos y su resultado es blanco
    if (no_colapsa()) {
      await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

      await select(are_tra)

      return

    } // End If 
    if (si_colapsa()) {
      // y se incluye en el xml o cadena original
      if (m.cao_cfd == 1) {
        m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
        // cadena original
      } // End If 

      m.emi_xml = m.emi_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
    } // End If 

    skip()
  } // End while 

  m.emi_xml = m.emi_xml + iif(m.ver_xml >= '3.3', '/> ', '> ')
  if (m.ver_xml == '3.2') {
    m.blo_cfd = 'DomicilioFiscal'
    // Domicilio fiscal
    let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

    await select('vi_cap_cfd')

    if (await recCount() > 0) {
      m.emi_xml = m.emi_xml + '<DomicilioFiscal '
      await goto('TOP')
      //Requery()

      // VFP SCAN 
      while (!eof()) {
        m = appendM(m, await scatter(m))// scatter 
        ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
        //         ins_fox='val_res='+m.var_cfd
        // si genera xml y no permite blancos y su resultado es blanco
        if (no_colapsa()) {
          await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

          await select(are_tra)

          return

        } // End If 
        if (si_colapsa()) {
          // y se incluye en el xml o cadena original
          if (m.cao_cfd == 1 && len(rTrim(lTrim(val_res))) > 0) {
            m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
            // cadena original
          } // End If 

          m.emi_xml = m.emi_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
        } // End If 

        skip()
      } // End while 

      m.emi_xml = rTrim(m.emi_xml) + '/> '
    } // End If 

    m.blo_cfd = 'ExpedidoEn '
    // Expedido en
    let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

    await select('vi_cap_cfd')

    if (await recCount() > 0) {
      m.emi_xml = m.emi_xml + '<ExpedidoEn  '
      await goto('TOP')
      // Requery()

      // VFP SCAN 
      while (!eof()) {
        m = appendM(m, await scatter(m))// scatter 
        ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
        //         ins_fox='val_res='+m.var_cfd
        // si genera xml y no permite blancos y su resultado es blanco
        if (no_colapsa()) {
          await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

          await select(are_tra)

          return

        } // End If 
        if (si_colapsa()) {
          // y se incluye en el xml o cadena original
          if (m.cao_cfd == 1) {
            m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
            // cadena original
          } // End If 

          m.emi_xml = m.emi_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
        } // End If 

        skip()
      } // End while 

      m.emi_xml = rTrim(m.emi_xml) + '/> '
    } // End If 

    m.blo_cfd = 'RegimenFiscal '
    // RegimenFiscal
    let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

    await select('vi_cap_cfd')


    //Requery()
    if (await recCount() > 0) {
      await goto('TOP')

      // VFP SCAN 
      while (!eof()) {
        m = appendM(m, await scatter(m))// scatter 
        ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
        //         ins_fox='val_res='+m.var_cfd
        // si genera xml y no permite blancos y su resultado es blanco
        if (no_colapsa()) {
          await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

          await select(are_tra)

          return

        } // End If 
        if (si_colapsa()) {
          // y se incluye en el xml o cadena original
          if (m.cao_cfd == 1) {
            m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
            // cadena original
          } // End If 

          m.emi_xml = m.emi_xml + '<RegimenFiscal  '
          // aumentamos el atributo del regimen fiscal
          m.emi_xml = m.emi_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
          m.emi_xml = rTrim(m.emi_xml) + '/> '
        } // End If 

        skip()
      } // End while 

    } // End If 

    m.emi_xml = m.emi_xml + '</Emisor>'
    // ver 3.2
  } // End If 

  m.blo_cfd = 'Receptor'
  //m.emi_xml=m.emi_xml+'/>'   && ver 3.3
  // Fin de datos del emisor
  // Receptor
  m.rec_xml = '<Receptor  '
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

  await select('vi_cap_cfd')

  await goto('TOP')
  //Requery()

  // VFP SCAN 
  while (!eof()) {
    m = appendM(m, await scatter(m))// scatter 
    ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
    //         ins_fox='val_res='+m.var_cfd
    // si genera xml y no permite blancos y su resultado es blanco
    if (no_colapsa()) {
      await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

      await select(are_tra)

      return

    } // End If 
    if (si_colapsa()) {
      // y se incluye en el xml o cadena original
      if (m.cao_cfd == 1) {
        m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
        // cadena original
      } // End If 

      m.rec_xml = m.rec_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
    } // End If 

    skip()
  } // End while 

  m.rec_xml = m.rec_xml + iif(m.ver_xml >= '3.3', '/> ', '> ')
  if (m.ver_xml == '3.2') {
    m.blo_cfd = 'Domicilio'
    let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom Order By ord_cfd")

    await select('vi_cap_cfd')


    //Requery()
    if (await recCount() > 0) {
      m.rec_xml = m.rec_xml + '<Domicilio  '
      await goto('TOP')

      // VFP SCAN 
      while (!eof()) {
        m = appendM(m, await scatter(m))// scatter 
        ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
        //         ins_fox='val_res='+m.var_cfd
        // si genera xml y no permite blancos y su resultado es blanco
        if (no_colapsa()) {
          await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

          await select(are_tra)

          return

        } // End If 
        if (si_colapsa()) {
          // y se incluye en el xml o cadena original
          if (m.cao_cfd == 1) {
            m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
            // cadena original
          } // End If 

          m.rec_xml = m.rec_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
        } // End If 

        skip()
      } // End while 

      m.rec_xml = rTrim(m.rec_xml) + '/>'
    } // End If 

    m.rec_xml = rTrim(m.rec_xml) + '</Receptor> '
  } // End If 

  // fin
  m.cad_ori = m.cad_ori + m.con_cad
  // anexamos los conceptos a la cadena original y generamos el detalle de la factura
  let res = await localAlaSql("INSERT INTO retenciones select max(cl0_sat) As impuesto , Max ( fa0_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa0_imp ) ) = 'TASA' , im0_mov / 100 , im0_mov ) ) As TasaOCuota , Sum ( ba0_mov ) As Base , Sum ( ii0_mov ) As Importe , TA0_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im0_mov < 0 AND ba0_mov != 0 AND TA0_ISU > '  ' Group By TA0_ISU union Select Max ( Public.value.cl1_sat ) As impuesto , Max ( fa1_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa1_imp ) ) = 'TASA' , im1_mov / 100 , im1_mov ) ) As TasaOCuota , Sum ( ba1_mov ) As Base , Sum ( ii1_mov ) As Importe , TA1_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im1_mov < 0 AND ba1_mov != 0 AND TA1_ISU > '  ' Group By TA1_ISU union SELECT Max ( Public.value.cl2_sat ) As impuesto , Max ( fa2_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa2_imp ) ) = 'TASA' , im2_mov / 100 , im2_mov ) ) As TasaOCuota , Sum ( ba2_mov ) As Base , Sum ( ii2_mov ) As Importe , TA2_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im2_mov < 0 AND ba2_mov != 0 AND TA2_ISU > '  ' Group By TA2_ISU UNION SELECT Max ( Public.value.cl3_sat ) As impuesto , Max ( fa3_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa3_imp ) ) = 'TASA' , im3_mov / 100 , im3_mov ) ) As TasaOCuota , Sum ( ba3_mov ) As Base , Sum ( ii3_mov ) As Importe , TA3_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im3_mov < 0 AND ba3_mov != 0 AND TA3_ISU > '  ' Group By TA3_ISU UNION SELECT Max ( Public.value.cl4_sat ) As impuesto , Max ( fa4_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa4_imp ) ) = 'TASA' , im4_mov / 100 , im4_mov ) ) As TasaOCuota , Sum ( ba4_mov ) As Base , Sum ( ii4_mov ) As Importe , TA4_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im4_mov < 0 AND ba4_mov != 0 AND TA4_ISU > '  ' Group By TA4_ISU UNION SELECT Max ( Public.value.cl5_sat ) As impuesto , Max ( fa5_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa5_imp ) ) = 'TASA' , im5_mov / 100 , im5_mov ) ) As TasaOCuota , Sum ( ba5_mov ) As Base , Sum ( ii5_mov ) As Importe , TA5_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im5_mov < 0 AND ba5_mov != 0 AND TA5_ISU > '  ' Group By TA5_ISU")
  //////////////////////////////////////////////////////////< Impuestos Totales >//////////////////////////////////////////////////////////
  // Calculamos el total los impuestos de retenciones
  //###############


  // Calculamos el total los impuestos de traslados
  if (sep_ieps == 'SI') {
    let res = await localAlaSql("INSERT INTO traslados select max(cl0_sat) As impuesto , Max ( fa0_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa0_imp ) ) = 'TASA' , im0_mov / 100 , im0_mov ) ) As TasaOCuota , Sum ( ba0_mov ) As Base , Sum ( ii0_mov ) As Importe , TA0_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im0_mov > = 0 AND ba0_mov != 0 AND TA0_ISU > '  ' Group By TA0_ISU UNION Select Max ( Public.value.cl1_sat ) As impuesto , Max ( fa1_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa1_imp ) ) = 'TASA' , im1_mov / 100 , im1_mov ) ) As TasaOCuota , Sum ( ba1_mov ) As Base , Sum ( ii1_mov ) As Importe , TA1_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im1_mov > = 0 AND ba1_mov != 0 AND TA1_ISU > '  ' Group By TA1_ISU UNION SELECT Max ( Public.value.cl2_sat ) As impuesto , Max ( fa2_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa2_imp ) ) = 'TASA' , im2_mov / 100 , im2_mov ) ) As TasaOCuota , Sum ( ba2_mov ) As Base , Sum ( ii2_mov ) As Importe , TA2_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im2_mov > = 0 AND ba2_mov != 0 AND TA2_ISU > '  ' Group By TA2_ISU UNION SELECT Max ( Public.value.cl3_sat ) As impuesto , Max ( fa3_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa3_imp ) ) = 'TASA' , im3_mov / 100 , im3_mov ) ) As TasaOCuota , Sum ( ba3_mov ) As Base , Sum ( ii3_mov ) As Importe , TA3_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im3_mov > = 0 AND ba3_mov != 0 AND TA3_ISU > '  ' Group By TA3_ISU UNION SELECT Max ( Public.value.cl4_sat ) As impuesto , Max ( fa4_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa4_imp ) ) = 'TASA' , im4_mov / 100 , im4_mov ) ) As TasaOCuota , Sum ( ba4_mov ) As Base , Sum ( ii4_mov ) As Importe , TA4_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im4_mov > = 0 AND ba4_mov != 0 AND TA4_ISU > '  ' Group By TA4_ISU UNION SELECT Max ( Public.value.cl5_sat ) As impuesto , Max ( fa5_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa5_imp ) ) = 'TASA' , im5_mov / 100 , im5_mov ) ) As TasaOCuota , Sum ( ba5_mov ) As Base , Sum ( ii5_mov ) As Importe , TA5_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im5_mov > = 0 AND ba5_mov != 0 AND TA5_ISU > '  ' Group By TA5_ISU")

  } else {

    let res = await localAlaSql("INSERT INTO traslados select max(cl0_sat) As impuesto , Max ( fa0_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa0_imp ) ) = 'TASA' , im0_mov / 100 , im0_mov ) ) As TasaOCuota , Sum ( ba0_mov ) As Base , Sum ( ii0_mov ) As Importe , TA0_ISU As tar_isu From vi_cap_mov Where im0_mov > = 0 AND ba0_mov != 0 AND TA0_ISU > '  ' Group By TA0_ISU UNION Select Max ( Public.value.cl1_sat ) As impuesto , Max ( fa1_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa1_imp ) ) = 'TASA' , im1_mov / 100 , im1_mov ) ) As TasaOCuota , Sum ( ba1_mov ) As Base , Sum ( ii1_mov ) As Importe , TA1_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im1_mov > = 0 AND ba1_mov != 0 AND TA1_ISU > '  ' Group By TA1_ISU UNION SELECT Max ( Public.value.cl3_sat ) As impuesto , Max ( fa3_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa3_imp ) ) = 'TASA' , im3_mov / 100 , im3_mov ) ) As TasaOCuota , Sum ( ba3_mov ) As Base , Sum ( ii3_mov ) As Importe , TA3_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im3_mov > = 0 AND ba3_mov != 0 AND TA3_ISU > '  ' Group By TA3_ISU UNION SELECT Max ( Public.value.cl4_sat ) As impuesto , Max ( fa4_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa4_imp ) ) = 'TASA' , im4_mov / 100 , im4_mov ) ) As TasaOCuota , Sum ( ba4_mov ) As Base , Sum ( ii4_mov ) As Importe , TA4_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im4_mov > = 0 AND ba4_mov != 0 AND TA4_ISU > '  ' Group By TA4_ISU UNION SELECT Max ( Public.value.cl5_sat ) As impuesto , Max ( fa5_imp ) As TipoFactor , Max ( iif ( Alltrim ( Upper ( fa5_imp ) ) = 'TASA' , im5_mov / 100 , im5_mov ) ) As TasaOCuota , Sum ( ba5_mov ) As Base , Sum ( ii5_mov ) As Importe , TA5_ISU As tar_isu From vi_cap_mov With ( Buffering = true ) Where im5_mov > = 0 AND ba5_mov != 0 AND TA5_ISU > '  ' Group By TA5_ISU")

  } // End If 
  //   Se quita el impuesto IEPS de los totales
  //        Select  Max(cl2_sat) As impuesto, Max(fa2_imp) As TipoFactor,Max(IIF(ALLTRIM(UPPER(fa2_imp))='TASA',im2_mov/100,im2_mov)) As TasaOCuota,Sum(ba2_mov) As Base ,Sum(ii2_mov) As Importe,TA2_ISU As tar_isu From vi_cap_mov Where im2_mov>=0 And ba2_mov>0 And TA2_ISU>'  ' Group By TA2_ISU 
  //  UNION 
  //

  let tot_imp_ret = ''
  let tot_imp_tra = ''
  m.blo_cfd = 'Impuestos'
  Public.value.sw_imp = false
  m.imp_xml = ''
  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom AND ( cao_cfd = 1 OR xml_cfd = 1 ) Order By ord_cfd")

  await select('vi_cap_cfd')

  await goto('TOP')
  //Requery()

  if (!Eof()) {
    m.imp_xml = '<Impuestos  '
    // VFP SCAN 
    while (!eof()) {
      m = appendM(m, await scatter(m))// scatter 
      ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
      // si genera xml y no permite blancos y su resultado es blanco
      if (no_colapsa()) {
        await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

        await select(are_tra)

        return

      } // End If 
      if (si_colapsa()) {
        // y se incluye en el xml o cadena original
        if (m.cao_cfd == 1) {
          // si afecta a la cadena original
          if (await recCount('traslados') > 0 && upper(m.cam_cfd) == upper('totalImpuestosTrasladados')) {
            tot_imp_tra = rTrim(val_res) + '|'
            // cadena original
            m.imp_xml = m.imp_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
          } // End If 

          if (await recCount('retenciones') > 0 && upper(m.cam_cfd) == upper('totalImpuestosRetenidos')) {
            tot_imp_ret = rTrim(val_res) + '|'
            // cadena original
            m.imp_xml = m.imp_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
          } // End If 

        } // End If 

      } // End If 

      skip()
    } // End while 

    m.imp_xml = m.imp_xml + '> '
  } // End If 

  m.blo_cfd = 'Retenciones'
  //////////////////////////////////////////////////////////////< Retenciones
  m.ret_xml = ''
  let sw_ret = false
  // inicializamos switch
  let sw_tra = false
  await select('retenciones')

  if (await recCount() > 0) {
    // si hay retenciones buscamos definicion
    let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom AND ( cao_cfd = 1 OR xml_cfd = 1 ) Order By ord_cfd")

    await select('vi_cap_cfd')

    if (await recCount() > 0) {
      // si hay definicion
      await select('retenciones')

      await goto('TOP')

      // VFP SCAN 
      while (!eof()) {
        if (!sw_ret) {
          m.ret_xml = '<Retenciones> '
          sw_ret = true
        } // End If 
        m.ret_xml = m.ret_xml + '<Retencion '          m = appendM(m, await scatter(m))// scatter 
        await select('vi_cap_cfd')
        await goto('TOP')
        // VFP SCAN 
        while (!eof()) {
          m = appendM(m, await scatter(m))// scatter 
          ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
          // si genera xml y no permite blancos y su resultado es blanco
          if (no_colapsa()) {
            await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

            await select(are_tra)

            return

          } // End If 
          if (si_colapsa()) {
            // y se incluye en el xml o cadena original
            if (m.cao_cfd == 1) {
              m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
              // cadena original
            } // End If 

            m.ret_xml = m.ret_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
          } // End If 

          skip()
        } // End while 
        let retenciones = await localAlaSql("select * From retenciones")
        m.ret_xml = m.ret_xml + '/>'          await select('retenciones')

        skip()
      } // End while 


      //    m.tra_xml=RTRIM(m.tra_xml)+'/> '
      if (sw_ret) {
        m.ret_xml = m.ret_xml + '</Retenciones> '
        m.cad_ori = m.cad_ori + tot_imp_ret
        // pone el total de impuestos retenidos en la cadena original
      } // End If 

    } // End If 

    // Fin si hay definicion de retenciones
  } // End If 

  // Fin si hay total de retenciones
  m.blo_cfd = 'Traslados'
  //////////////////////////////////////////////////////////////< Fin Retenciones
  //////////////////////////////////////////////////////////////< Traslados
  m.tra_xml = m.imp_xml
  if (len(m.ret_xml) > 0) {
    // se aumenta el campo de impuestos
    m.tra_xml = m.tra_xml + m.ret_xml
  } // End If 

  await select('traslados')

  if (await recCount() > 0) {
    // 01/dic/2021
    let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom AND ( cao_cfd = 1 OR xml_cfd = 1 ) Order By ord_cfd")

    await select('vi_cap_cfd')

    if (await recCount() > 0) {
      await select('traslados')

      await goto('TOP')

      // VFP SCAN 
      while (!eof()) {
        if (!sw_tra) {
          m.tra_xml = m.tra_xml + '<Traslados> '
          sw_tra = true
        } // End If 
        m = appendM(m, await scatter(m))// scatter 
        m.tra_xml = m.tra_xml + '<Traslado '          await select('vi_cap_cfd')
        await goto('TOP')
        // VFP SCAN 
        while (!eof()) {
          m = appendM(m, await scatter(m))// scatter 
          ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')' & ins_fox
          // si genera xml y no permite blancos y su resultado es blanco
          if (no_colapsa()) {
            await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

            await select(are_tra)

            return

          } // End If 

          // si  no se puede colapsar o el dato no es vacio
          if (si_colapsa()) {
            // y se incluye en el xml o cadena original
            if (m.cao_cfd == 1) {
              m.cad_ori = m.cad_ori + rTrim(val_res) + '|'
              // cadena original
            } // End If 

            m.tra_xml = m.tra_xml + allTrim(m.cam_cfd) + '="' + rem_car(val_res) + '" '
          } // End If 

          skip()
        } // End while 
        let traslados = await localAlaSql("select * From traslados")
        m.tra_xml = m.tra_xml + '/>'          await select('traslados')

        skip()
      } // End while 

      if (sw_tra) {
        m.tra_xml = m.tra_xml + '</Traslados> '
        m.cad_ori = m.cad_ori + tot_imp_tra
        // pone el total de impuestos trasladados cadena original
      } // End If 

    } // End If 

  } // End If 

  await select(are_tra)

  if (!sw_pmu) {
    // si no es timbrado de un pago multple
    await enc_addenda()
    // Genera el encabezado de la addenda

    await select(are_tra)

    await pie_addenda()
    // Genera el pie de la addenda

  } // End If 

  await select(are_tra)
  // regresamos a la area de trabajo original


  // compone el xml
  if (len(allTrim(m.tra_xml)) > 5) {
    m.tra_xml = m.tra_xml + ' </Impuestos>'
  } // End If 

  m.tra_xml = strtran(m.tra_xml, '<Impuestos  >  </Impuestos>', '')
  // 05/Abr/2022 quita la etiqueta de impuestos si no hay impuestos
  for (let i = 1; i < 10; i++) {
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //IF pago_multiple='PM'
    //   m.tra_xml=m.tra_xml+m.xml_doctos
    //else
    if (m.enc_com(i) > ' ' || m.det_com(i) > ' ' || m.pie_com(i) > ' ') {
      m.tra_xml = m.tra_xml + m.enc_com(i) + m.det_com(i) + m.pie_com(i)
    } // End If 

    m.enc_com(i) = ''
    //########################
    //endif
    m.det_com(i) = ''
    m.pie_com(i) = ''
  } // End For; 

  m.tra_xml = m.tra_xml + iif(inc_ade, +allTrim(m.enc_add + m.det_add + m.pie_add), '') + '</Comprobante>'
  // Incluye addenda
  if (inc_ade) {
    m.enc_add = ''
    m.det_add = ''
    m.pie_add = ''
  } // End If 

  m.num_det = 0
  for (let i = 1; i < 10; i++) {
    //sw_cad=.f.
    if (m.cad_enc(i) > ' ' || m.cad_det(i) > ' ' || m.cad_pie(i) > ' ') {
      // si hay cadena encabezado
      let sw_cad = true
      m.cad_ori = m.cad_ori + m.cad_enc(i) + m.cad_det(i) + m.cad_pie(i) + "|"
      // Compone la cadena original incluyendo los complementos
    } // End If 

    m.cad_enc(i) = ''
    m.cad_det(i) = ''
    m.cad_pie(i) = ''
  } // End For; 

  m.cad_ori = allTrim(m.cad_ori)
  // 01/Dic/2021 Se aumenta pipe si falta en la cadena original
  if (len(m.cad_ori) > 10) {
    if (right(m.cad_ori, 2) != '||') {
      m.cad_ori = m.cad_ori + "|"
    } // End If 

  } // End If 

  let dir_com = Public.value.dir_cfd + "\"+lTrim(str(year(vi_lla1_doc.fec_doc)))
  //IF NOT sw_cad
  //   m.cad_ori=m.cad_ori+'|"
  //endif
  //=STRTOFILE(m.cad_ori,'cadenaOriginal.txt')
  // nombre donde quedara la cadena original
  if (!Directory(dir_com)) {
    // reviza primero si existe el aÃ±o
    Mkdir(dir_com)
  } // End If 

  dir_com = dir_com + '\'+Cmonth(vi_lla1_doc.fec_doc)
  if (!Directory(dir_com)) {
    // reviza si existe el mes
    Mkdir(dir_com)
  } // End If 

  dir_com = dir_com + '\'+allTrim(vi_lla1_doc.cod_nom)
  if (!Directory(dir_com)) {
    // reviza si existe la carpeta del cliente
    Mkdir(dir_com)
  } // End If 

  let arc_cad = dir_com + '\'+allTrim(vi_lla1_doc.tdo_tdo)+lTrim(str(vi_lla1_doc.ndo_doc,8))+'.cad'
  // nombre donde quedara la cadena original
  let num_arc = Fcreate(arc_cad, 0)
  //    arc_cad=".\Comp_Digitales\"+Ltrim(Str(Year(vi_lla1_doc.fec_doc)))+'\'+vi_lla1_doc.tdo_tdo+Ltrim(Str(vi_lla1_doc.ndo_doc,6))+'.cad' && nombre donde quedara la cadena original
  // crea el archivo de cadena original
  if (num_arc <= 0) {
    await select(are_tra)

    return false

  } // End If 

  let res = Fwrite(num_arc, Strconv(m.cad_ori, 9))
  //    res=fwrite(num_arc,m.cad_ori)  && escribimos la cadena original
  // convertimos a UTF-8  30/May/2012
  // escribimos la cadena original en formato UTF-8 ya que el XML esta en formato UTF-8
  Fclose(num_arc)
  await select(are_tra)

  return m.cad_ori
  // STRTOFILE(m.cad_ori,'CadenaOriginal.txt')

}   // Fin Procedure
//-----------------< Generacion de xml>----------------------------------

export async function gen_xml(m: string | object | undefined.blo_cfd: any, detalle: ((arg0: number) => any) | undefined) {
  let m = {}   // inicializamos m
  // Dimension str_xml ( 10 ) 

  // Private are_tra 

  let are_tra = await select()

  m.add_cfd = 0

  // si es un complemento de pago
  if (m.tip_cfd == 'P' || (m.blo_cfd == 'DetalleComp' || m.blo_cfd == 'EncabezadoComp' || m.blo_cfd == 'PieComp')) {

    if (m.tip_cfd == 'P' || m.tip_cfd == 'T' || cometdo.dba_tdo == 'CFC') {
      // Mar/2022
      m.cod_nom = '000000'
      if (m.tip_cfd != 'P') {
        // no es un cfdi de Pago
        if (let res = await localAlaSql("select ('vi_car_por') = 0 OR await recCount ( 'vi_car_por' ) < 1")
  // si no hay vistas de carta porte
) {
          return

        } // End If 

      } // End If 

    } else {

      m.cod_nom = vi_lla1_doc.cod_nom
    } // End If 

  } else {
    //!//  IF m.tip_cfd<>'P'   && no es un cfdi de Pago
    //!//
    //!//  endif

    m.cod_nom = vi_lla1_doc.cod_nom
    // asignamos el valores
    if (m.con_con > 0 && await recCount('vi_lla1_con') > 0) {
      try {
        m.add_cfd = vi_lla1_con.add_cfd
      }
      catch (error) {
        m.add_cfd = 0
      } // End Try

    } // End If 

  } // End If 

  let res = await localAlaSql("INSERT INTO vi_cap_cfd select * From vi_gen_cfd Where blo_cfd = = m.blo_cfd AND cod_nom = m.cod_nom AND m.add_cfd = add_cfd Order By com_cfd , ord_cfd")
  //If m.add_cfd>0

  await select('vi_cap_cfd')

  await goto('TOP')

  let num_com = 0
  // inicilizamos el numero de complemento

  while (!Eof()) {
    num_com = num_com + 1      str_xml(num_com) = ''      let complemento = com_cfd
    while (com_cfd == complemento && !Eof()) {
      m = appendM(m, await scatter(m))// scatter 
      m.var_cfd = Chrtranc(m.var_cfd, '{', "[")        m.var_cfd = Chrtranc(m.var_cfd, '}', "]")        let val_res = ''
      ////////////////////////////////////////////////// Si es una funcion
      if (m.fun_cfd == 1) {
        let ins_fox = 'val_res=' + allTrim(m.var_cfd)
        try {
                        & ins_fox
        }
        catch (error) {
          await MessageBox('Error en ' + m.blo_cfd + ' Campo=' + m.cam_cfd + ' Variable=' + m.var_cfd + '   ' + ins_fox)

        } // End Try

        val_res = strtran(val_res, ",", "',", 1, 1)
        ins_fox = allTrim(cam_cfd) + "('" + val_res + ")"
        ins_fox = strtran(ins_fox, '"', '')
        try {
                        & ins_fox
        }
        catch (error) {
          await MessageBox('Error en ' + m.blo_cfd + ' Campo=' + m.cam_cfd + ' Variable=' + m.var_cfd + '   ' + ins_fox)

        } // End Try

      } else {

        if (right(allTrim(m.var_cfd), 1) > ' ') {
          // si no es final de bloque
          if (m.blo_cfd == 'DetalleComp' || m.blo_cfd == 'EncabezadoComp' || m.blo_cfd == 'PieComp') {

            ins_fox = 'val_res=mod_car(' + m.var_cfd + ')'
          } else {

            ins_fox = 'val_res=' + m.var_cfd
          } // End If 

          try {
                            & ins_fox
          }
          catch (error) {
            await MessageBox('Error en ' + m.blo_cfd + ' Campo=' + m.cam_cfd + ' Variable=' + m.var_cfd + '   ' + ins_fox)

          } // End Try

          val_res = allTrim(val_res)
          // Fernando Cuadras
          // 25/03/2021

          // si genera xml y no permite blancos y su resultado es blanco
          if (no_colapsa()) {
            await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

            await select(are_tra)

            return

          } // End If 


          // si  no se puede colapsar o el dato no es vacio
          if (si_colapsa()) {
            // y se incluye en el xml o cadena original
            if (m.cao_cfd == 1) {
              // si se incluye en la cadena original
              if (right(val_res, 1) == '"') {
                let val_cad = position.Left(val_res, len(val_res) - 1)
                val_cad = right(val_cad, len(val_cad) - 1)
                if (m.blo_cfd == 'EncabezadoComp' || m.blo_cfd == 'DetalleComp' || m.blo_cfd == 'PieComp') {
                  val_res = '"' + rem_car(val_cad) + '"'
                  //  nuevo carta porte cambiamos a utf-8
                } else {

                  val_res = '"' + val_cad + '"'
                } // End If 

              } else {

                val_cad = val_res
              } // End If 

              switch (true) {
                case m.blo_cfd == 'EncabezadoComp':
                  m.cad_enc(num_com) = m.cad_enc(num_com) + rTrim(val_cad) + '|'
                  // cadena original
                  break
                case m.blo_cfd == 'DetalleComp':
                  m.cad_det(num_com) = m.cad_det(num_com) + rTrim(val_cad) + '|'
                  // cadena original
                  break
                case m.blo_cfd == 'PieComp':
                  m.cad_pie(num_com) = m.cad_pie(num_com) + rTrim(val_cad) + '|'
                // cadena original
              } // End case 

            } // End If 

            val_res = allTrim(m.cam_cfd) + val_res
            if (at('CHR(39)', upper(m.var_cfd)) > 0) {
              str_xml(num_com) = str_xml(num_com) + val_res
            } else {

              str_xml(num_com) = str_xml(num_com) + val_res + ' '
            } // End If 

          } // End If 

        } else {

          val_res = allTrim(m.cam_cfd)
          //////////////////////////////////////////  anterior a  Carta Porte
          if (at('CHR(39)', upper(m.var_cfd)) > 0) {
            str_xml(num_com) = str_xml(num_com) + val_res
          } else {

            str_xml(num_com) = str_xml(num_com) + val_res + ' '
          } // End If 

        } // End If 
        //////////////////////////////////////////
        //!//                   // Nuevo carta porte
        //!//     val_res=Alltrim(m.cam_cfd)+val_res
        //!//     If At('CHR(39)',Upper(m.var_cfd))>0  && utilizamos remplaza caracteres a UTF-8
        //!//      str_xml(num_com)= str_xml(num_com)+IIF(m.blo_cfd='EncabezadoComp' OR m.blo_cfd='DetalleComp' OR m.blo_cfd='PieComp',rem_car(val_res),val_res)
        //!//     Else
        //!//      str_xml(num_com)= str_xml(num_com)+IIF(m.blo_cfd='EncabezadoComp' OR m.blo_cfd='DetalleComp' OR m.blo_cfd='PieComp',rem_car(val_res),val_res)+' '
        //!//     Endif

      } // End If 

      // Fin si es una funcion
      if (!Eof()) {
        await skip(1)

      } // End If 
    } // End while 
    str_xml(num_com) = strtran(str_xml(num_com), ' </', '</')      detalle(num_com) = str_xml(num_com)
  } // End while 

  await select(are_tra)

  return str_xml

}   // Fin Procedure
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  genera el detalle de aplicacion de impuestos del pago
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export async function gen_apl_pago(tipo_impuesto: string, m: object | undefined.tdo_tdo: any, m: any.ndo_doc: any, m: any.tia_pag: any, m: any.nua_pag: any) {
  let m = {}   // inicializamos m
  // Private are_tra 

  let are_tra = await select()

  let ins_sql = " Select * From man_comecfd Where tdo_tdo='" + allTrim(cometdo.dba_tdo) + "' AND blo_cfd='" + rTrim(tipo_impuesto) + "' And cod_nom='000000' And add_cfd=0 AND (cao_cfd=1 OR xml_cfd=1 OR mee_cfd='EJE') Order By com_cfd,ord_cfd "
    =iif(await SQLExec(ins_sql, 'comecfd_imp')
    > 0, true, err_sql())
  m.tip_imp = iif(atc('TRASLADO', upper(tipo_impuesto)) > 0, 'T', 'R')

  //!// If Parameters()=3 Then
  //!//  ins_sql="  select sum(bas_imp/fac_tor) base,cla_imp impuesto,CAST(MAX(fac_imp) as varchar(20)) tipoFactor,toc_imp TasaOcuota,SUM(iim_imp/fac_tor) Importe from vi_APL_PAG_IMP WHERE TDO_TDO='"+m.tdo_tdo+"' and ndo_doc="+Str(m.ndo_doc)+" and tip_imp='"+m.tip_imp+
  //   IIF(sep_ieps='NO'," and cla_imp<>'003' "," ")+"' group by cla_imp,toc_imp order by cla_imp,toc_imp "
  //!// Else
  //!//  ins_sql="  select // from vi_APL_PAG_IMP WHERE TDO_TDO='"+m.tdo_tdo+"' and ndo_doc="+Str(m.ndo_doc)+" and tia_pag='"+m.tia_pag+"' and nua_pag="+Str(m.nua_pag)+" and tip_imp='"+m.tip_imp+"' "+
  //   IIF(sep_ieps='NO'," and cla_imp<>'003' "," ")
  //!// Endif
  //!// =Iif(SQLExec(num_dbs,ins_sql,'comeapl')>0,.T.,err_sql())
  if (Parameters() == 3) {

    // 02/Jun/2022
    if (await select('comeapl_1')
      > 0) {
      await select('comeapl_1')

      releaseUse() // use 

    } // End If 

    if (await select('comeapl')
      > 0) {
      await select('comeapl')

      releaseUse() // use 

    } // End If 


    // 03/Jun/2022 al no poder agrupar directamente ya que en postgres da resultados memo , se cambio a dos select
    if (sep_ieps == 'NO') {
      let res = await localAlaSql("INSERT INTO comeapl_1 select cast(cla_imp,'CHAR'(3))cla_imp , cast ( toc_imp as numeric ( 16 , 5 ) ) toc_imp , bas_imp bas_imp , fac_tor fac_tor , CAST ( fac_imp as char ( 32 ) ) fac_imp , iim_imp from vi_imp_pag WHERE TDO_TDO = m.tdo_tdo AND ndo_doc = m.ndo_doc AND tip_imp = m.tip_imp AND position.Left ( cla_imp , 3 ) != '003'")
      //  SELECT CAST(cla_imp as char(3)) as cla_imp,toc_imp as toc_imp, sum(bas_imp/fac_tor) base,cla_imp impuesto,CAST(MAX(fac_imp) as varchar(20)) tipoFactor,toc_imp TasaOcuota,SUM(iim_imp/fac_tor) Importe from vi_imp_pag  WHERE 
      //  TDO_TDO=m.tdo_tdo and ndo_doc=m.ndo_doc and tip_imp=m.tip_imp  and cla_imp<>'003' group by cla_imp,toc_imp order by cla_imp,toc_imp INTO CURSOR comeapl

    } else {

      let res = await localAlaSql("INSERT INTO comeapl_1 select cast(cla_imp,'CHAR'(3))cla_imp , cast ( toc_imp as numeric ( 16 , 5 ) ) toc_imp , bas_imp bas_imp , fac_tor fac_tor , CAST ( fac_imp as char ( 32 ) ) fac_imp , iim_imp from vi_imp_pag WHERE TDO_TDO = m.tdo_tdo AND ndo_doc = m.ndo_doc AND tip_imp = m.tip_imp")

    } // End If 

    let res = await localAlaSql("INSERT INTO comeapl select  sum ( bas_imp / fac_tor ) base , cla_imp impuesto , CAST ( MAX ( fac_imp ) as varchar ( 20 ) ) tipoFactor , toc_imp TasaOcuota , SUM ( iim_imp / fac_tor ) Importe from comeapl_1 group by cla_imp , toc_imp order by cla_imp , toc_imp")

  } else {

    if (sep_ieps == 'NO') {
      let res = await localAlaSql("INSERT INTO comeapl select * from vi_imp_pag WHERE TDO_TDO = m.tdo_tdo AND ndo_doc = m.ndo_doc AND tia_pag = m.tia_pag AND nua_pag = m.nua_pag AND tip_imp = m.tip_imp AND cla_imp != '003'")

    } else {

      let res = await localAlaSql("INSERT INTO comeapl select * from vi_imp_pag WHERE TDO_TDO = m.tdo_tdo AND ndo_doc = m.ndo_doc AND tia_pag = m.tia_pag AND nua_pag = m.nua_pag AND tip_imp = m.tip_imp")

    } // End If 

  } // End If 

  await select('comeapl')

  if (await recCount() > 0) {
    // VFP SCAN 
    while (!eof()) {
      m = appendM(m, await scatter(m))// scatter 
      await select('comecfd_imp')
      await goto('TOP')
      // VFP SCAN 
      while (!eof()) {
        m = appendM(m, await scatter(m))// scatter 
        m.var_cfd = allTrim(m.var_cfd)          m.var_cfd = Chrtranc(m.var_cfd, '{', "[")          m.var_cfd = Chrtranc(m.var_cfd, '}', "]")          let val_res = ''          if (right(allTrim(m.var_cfd), 1) > ' ') {
          // si no es final de bloque
          let ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')'
          try {
                            & ins_fox
          }
          catch (error) {
            await MessageBox('Error en ' + m.blo_cfd + ' Campo=' + m.cam_cfd + ' Variable=' + m.var_cfd + '   ' + ins_fox)

          } // End Try

          val_res = allTrim(val_res)

          // si genera xml y no permite blancos y su resultado es blanco
          if (no_colapsa()) {
            await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

            await select(are_tra)

            return

          } // End If 


          // si  no se puede colapsar o el dato no es vacio
          if (si_colapsa()) {
            // y se incluye en el xml o cadena original
            if (m.cao_cfd == 1) {
              // si se incluye en la cadena original
              if (right(val_res, 1) == '"') {
                let val_cad = position.Left(val_res, len(val_res) - 1)
                val_cad = right(val_cad, len(val_cad) - 1)
                val_res = '"' + rem_car(val_cad) + '"'
                //  nuevo carta porte cambiamos a utf-8
              } else {

                val_cad = val_res
              } // End If 

              switch (true) {
                case atc('Encabezado', m.blo_cfd) > 0:
                  m.cad_enc(num_com) = m.cad_enc(num_com) + rTrim(val_cad) + '|'
                  // cadena original
                  break
                case atc('Detalle', m.blo_cfd) > 0:
                  m.cad_det(num_com) = m.cad_det(num_com) + rTrim(val_cad) + '|'
                  // cadena original
                  break
                case atc('Pie', m.blo_cfd) > 0:
                  m.cad_pie(num_com) = m.cad_pie(num_com) + rTrim(val_cad) + '|'
                // cadena original
              } // End case 

            } // End If 

            val_res = allTrim(m.cam_cfd) + val_res
            if (at('CHR(39)', upper(m.var_cfd)) > 0) {
              str_xml(num_com) = str_xml(num_com) + val_res
            } else {

              str_xml(num_com) = str_xml(num_com) + val_res + ' '
            } // End If 

          } // End If 

        } else {

          val_res = allTrim(m.cam_cfd)
          //////////////////////////////////////////  anterior a  Carta Porte
          if (at('CHR(39)', upper(m.var_cfd)) > 0) {
            str_xml(num_com) = str_xml(num_com) + val_res
          } else {

            str_xml(num_com) = str_xml(num_com) + val_res + ' '
          } // End If 

        } // End If 

        skip()
      } // End while 
      await select('comeapl')

      skip()
    } // End while 

    str_xml(num_com) = strtran(str_xml(num_com), ' </', '</')
    detalle(num_com) = str_xml(num_com)
  } // End If 

  await select(are_tra)

  return

}   // Fin Procedure
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  genera genera ubicaciones complemento cartaporte
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export async function gen_ubi_ccp(bloque: string, m: object | undefined.tdo_tdo: any, m: any.ndo_doc: any) {
  let m = {}   // inicializamos m
  // Private are_tra 

  let are_tra = await select()

  if (await select('comeubi')
    > 0) {
    await select('comeubi')

    releaseUse() // use 

  } // End If 

  if (await select('comecfd_ubi')
    > 0) {
    await select('comecfd_ubi')

    releaseUse() // use 

  } // End If 

  let ins_sql = " Select * From man_comecfd Where tdo_tdo='" + allTrim(cometdo.dba_tdo) + "' AND blo_cfd='" + rTrim(bloque) + "' And cod_nom='000000' And add_cfd=0 AND (cao_cfd=1 OR xml_cfd=1) Order By com_cfd,ord_cfd "
    =iif(await SQLExec(ins_sql, 'comecfd_ubi')
    > 0, true, err_sql())
  let res = await localAlaSql("INSERT INTO comeubi select * from vi_car_por ORDER BY num_ori")

  await select('comeubi')

  if (await recCount() > 0) {
    // VFP SCAN 
    while (!eof()) {
      m = appendM(m, await scatter(m))// scatter 
      await select('comecfd_ubi')
      await goto('TOP')
      // VFP SCAN 
      while (!eof()) {
        m = appendM(m, await scatter(m))// scatter 
        m.var_cfd = allTrim(m.var_cfd)          m.var_cfd = Chrtranc(m.var_cfd, '{', "[")          m.var_cfd = Chrtranc(m.var_cfd, '}', "]")          let val_res = ''          if (right(allTrim(m.var_cfd), 1) > ' ') {
          // si no es final de bloque
          let ins_fox = 'val_res=mod_car(' + allTrim(m.var_cfd) + ')'
          try {
                            & ins_fox
          }
          catch (error) {
            await MessageBox('Error en ' + m.blo_cfd + ' Campo=' + m.cam_cfd + ' Variable=' + m.var_cfd + '   ' + ins_fox)

          } // End Try

          val_res = allTrim(val_res)

          // si genera xml y no permite blancos y su resultado es blanco
          if (no_colapsa()) {
            await MessageBox('Error en bloque=' + allTrim(m.blo_cfd) + ', campo=' + allTrim(m.cam_cfd) + ', valor=' + allTrim(m.var_cfd) + ' :' + m.mee_cfd, 16, 'Error de captura')

            await select(are_tra)

            return

          } // End If 


          // si  no se puede colapsar o el dato no es vacio
          if (si_colapsa()) {
            // y se incluye en el xml o cadena original
            if (m.cao_cfd == 1) {
              // si se incluye en la cadena original
              if (right(val_res, 1) == '"') {
                let val_cad = position.Left(val_res, len(val_res) - 1)
                val_cad = right(val_cad, len(val_cad) - 1)
                val_res = '"' + rem_car(val_cad) + '"'
                //  nuevo carta porte cambiamos a utf-8
              } else {

                val_cad = val_res
              } // End If 

              switch (true) {
                case atc('Encabezado', m.blo_cfd) > 0:
                  m.cad_enc(num_com) = m.cad_enc(num_com) + rTrim(val_cad) + '|'
                  // cadena original
                  break
                case atc('Detalle', m.blo_cfd) > 0:
                  m.cad_det(num_com) = m.cad_det(num_com) + rTrim(val_cad) + '|'
                  // cadena original
                  break
                case atc('Pie', m.blo_cfd) > 0:
                  m.cad_pie(num_com) = m.cad_pie(num_com) + rTrim(val_cad) + '|'
                // cadena original
              } // End case 

            } // End If 

            val_res = allTrim(m.cam_cfd) + val_res
            if (at('CHR(39)', upper(m.var_cfd)) > 0) {
              str_xml(num_com) = str_xml(num_com) + val_res
            } else {

              str_xml(num_com) = str_xml(num_com) + val_res + ' '
            } // End If 

          } // End If 

        } else {

          val_res = allTrim(m.cam_cfd)
          //////////////////////////////////////////  anterior a  Carta Porte
          if (at('CHR(39)', upper(m.var_cfd)) > 0) {
            str_xml(num_com) = str_xml(num_com) + val_res
          } else {

            str_xml(num_com) = str_xml(num_com) + val_res + ' '
          } // End If 

        } // End If 

        skip()
      } // End while 
      await select('comeubi')

      skip()
    } // End while 

    str_xml(num_com) = strtran(str_xml(num_com), ' </', '</')
    detalle(num_com) = str_xml(num_com)
  } // End If 

  await select(are_tra)

  return

}   // Fin Procedure
////////////////////////////////////////// fin generacion ubicaciones complemento carta porte
//-----------------< Generacion del Encabezado de la addenda y complemento>----------------------------------


// pago multiple
export async function enc_addenda(sw_pmu: undefined) {
  let m = {}   // inicializamos m
  // Dimension xml_complemento ( 10 ) , xml_addenda ( 2 ) 

  xml_addenda(1) = ''
  xml_addenda(2) = ''
  for (let i = 1; i < 10; i++) {
    xml_complemento(i) = ''
  } // End For; 

  if (Parameters() == 0) {
    let sw_pmu = false
    // no es complemento de pago
  } // End If 

  let sw_eco = true
  // para poner la etiqueta <Complemento>
  if (sw_pmu && m.det_com ==> ' ') {
    sw_eco = false
  } // End If 

  gen_xml('EncabezadoComp', @xml_complemento)
  for (let i = 1; i < 10; i++) {
    // asignamos todos los complementos
    m.enc_com(i) = m.enc_com(i) + xml_complemento(i)
    if (len(m.enc_com(i)) > 1 && sw_eco) {
      m.enc_com(i) = '<Complemento>' + m.enc_com(i)
    } // End If 

    if (sw_pmu) {
      let eti_pag = 'pago10:'
      // generamos la etiqueta de pago a llevar antes pago10:
      if (cometdo.dba_tdo == 'PG4') {
        eti_pag = 'pago20:'
      } // End If 

      m.det_com(i) = strtran(m.det_com(i), '</' + eti_pag + 'Pagos>', '')
      // eti_pag='pago'+ALLTRIM(STR(VAL(m.ver_xml//10)),2)+':'
      m.det_com(i) = strtran(m.det_com(i), '</Complemento>', '')
      if (m.det_com(i) > ' ') {
        // si no es el primer encabezado le quita etiquetas y valores que no se deben de repetir
        m.enc_com(i) = strtran(m.enc_com(i), '<' + eti_pag + ':Pagos Version="1.0" >', '')
        m.cad_enc(i) = strtran(m.cad_enc(i), '1.0|', '', 1, 1)
      } // End If 

      m.det_com(i) = m.det_com(i) + m.enc_com(i)
      m.cad_det(i) = m.cad_det(i) + m.cad_enc(i)
      m.enc_com(i) = ''
      // limpiamos los encabezados cuando es una impresion multiple y los mandamos a su detalles
      m.cad_enc(i) = ''
    } // End If 

  } // End For; 

  gen_xml('Encabezado', @xml_addenda)
  m.enc_add = xml_addenda(1)
  if (len(m.enc_add) > 1) {
    if (position.Left(m.enc_add, 14) != '<cfdi:Addenda ') {
      m.enc_add = '<Addenda>' + m.enc_add
    } // End If 

  } // End If 
  // m.enc_add='<Addenda>'+m.enc_add

  return

}   // Fin Procedure
//-----------------< Generacion de detalle de la addenda>----------------------------------

export async function det_addenda(tip_det: string) {
  let m = {}   // inicializamos m
  // Dimension xml_complemento ( 10 ) , xml_addenda ( 2 ) 

  xml_addenda(1) = ''
  xml_addenda(2) = ''
  for (let i = 1; i < 10; i++) {
    xml_complemento(i) = ''
  } // End For; 

  if (Parameters() == 0) {
    let tip_det = 'Addenda'
  } // End If 

  if (tip_det == 'DetalleComp') {
    gen_xml('DetalleComp', @xml_complemento)
    // detalle del complemento
    for (let i = 1; i < 10; i++) {
      // asignamos todos los complementos
      m.det_com(i) = m.det_com(i) + xml_complemento(i)
    } // End For; 

  } // End If 

  if (tip_det == 'Addenda') {
    gen_xml('Detalle', @xml_addenda)
    if (xml_addenda(1) > ' ') {
      m.det_add = m.det_add + xml_addenda(1)
      //
    } // End If 

    if (len(m.det_add) > 1 && len(m.enc_add) < 1) {
      m.enc_add = '<Addenda>'
    } // End If 

  } // End If 

  return

}   // Fin Procedure
//-----------------< Generacion del Pie de la addenda>----------------------------------

export async function pie_addenda(sw_pmu: undefined) {
  let m = {}   // inicializamos m
  // Dimension xml_complemento ( 10 ) , xml_addenda ( 2 ) 

  xml_addenda(1) = ''
  xml_addenda(2) = ''
  for (let i = 1; i < 10; i++) {
    xml_complemento(i) = ''
  } // End For; 

  if (Parameters() == 0) {
    let sw_pmu = false
  } // End If 

  gen_xml('PieComp', @xml_complemento)
  for (let i = 1; i < 10; i++) {
    m.pie_com(i) = xml_complemento(i)
    if ((len(m.enc_com(i)) > 1 || len(m.det_com(i)) > 1)) {
      m.pie_com(i) = m.pie_com(i) + '</Complemento>'
    } // End If 

    if (sw_pmu) {
      m.det_com(i) = m.det_com(i) + m.pie_com(i)
      m.cad_det(i) = m.cad_det(i) + m.cad_pie(i)
      m.pie_com(i) = ''
      m.cad_pie(i) = ''
      m.enc_com(i) = ''
      m.cad_enc(i) = ''
    } // End If 

  } // End For; 

  gen_xml('Pie', @xml_addenda)
  m.pie_add = xml_addenda(1)
  if (len(m.enc_add) > 1 || len(m.det_add) > 1) {
    m.pie_add = m.pie_add + '</Addenda>'
  } // End If 

  return

}   // Fin Procedure
//------------------------< Generacion de sello digital >-----


// EL key_cer no se para que lo puse
export async function gen_sello(timbre: string) {
  let m = {}   // inicializamos m
  let gen_tim = false
  let cad_tfd = ''
  // cadena del tfd
  if (Parameters() == 1 && timbre == 'T') {
    gen_tim = true
  } // End If 

  m.sta_doc = vi_lla1_doc.sta_doc
  let dir_com = Public.value.dir_cfd + "\"+lTrim(str(year(vi_lla1_doc.fec_doc)))+'\'+Cmonth(vi_lla1_doc.fec_doc)+'\'+allTrim(vi_lla1_doc.cod_nom)
  let arc_cfd = dir_com + '\'+iif(position.Left(Public.value.nem_pge,8)=='LECHE 19' && substr(vi_lla1_doc.ref_doc,13,8)>'        ',strtran(allTrim(substr(vi_lla1_doc.ref_doc,13,12)),' ','')+'_','')+iif(m.dge_fim<='  ',allTrim(vi_lla1_doc.tdo_tdo)+right('0000000'+allTrim(str(vi_lla1_doc.ndo_doc)),8),allTrim(m.dge_fim)+right("0000000"+allTrim(str(con_des)),8))+'.xml'
  let arc_cad = dir_com + '\'+allTrim(vi_lla1_doc.tdo_tdo)+lTrim(str(vi_lla1_doc.ndo_doc,8))+'.cad'
  // nombre donde esta cadena original

  //!// IF SELECT('timbrado')=0
  //!//    are_tra=SELECT()
  //!//    SELECT 0
  //!//    CREATE CURSOR timbrado (sel_tim c(254),uui_tim c(36),cer_tim c(36),fec_tim c(20),bid_tim GENERAL)
  //!//    SELECT (are_tra)
  //!// ENDIF
  if (m.sel_dig > '  ') {
    // si ya se genero el sello digital se sale sin hacer nada
    return m.sel_dig

  } // End If 

  let are_tra = await select()

  m.cfd_xml = ''
  if (vi_lla1_doc.sta_doc == 'I' || vi_lla1_doc.sta_doc == 'T') {
    // si es un cfdi timbrado obtiene todos sus atributos
    let ins_sql = [select cfd_xml from man_comexml where tdo_tdo = ']+vi_lla1_doc.tdo_tdo+[' and ndo_doc =] + allTrim(str(vi_lla1_doc.ndo_doc))
      =iif(await SQLExec(ins_sql)
      > 0, true, err_sql())
    if (await recCount() > 0) {
      m = appendM(m, await scatter(m))// scatter 

      let UUID = allTrim(obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'UUID'))
      //    UUID=par_XML(m.cfd_xml,'tfd:TimbreFiscalDigital','UUID')
      if (len(UUID) > 5) {
        // si ya hay timbrado por el SAT se trae los datos
        m.ver_xml = obt_cam_xml(m.cfd_xml, 'cfdi:Comprobante', 'Version')
        m.sel_dig = obt_cam_xml(m.cfd_xml, 'cfdi:Comprobante', 'sello')
        //        m.sel_dig=par_XML(m.cfd_xml,'cfdi:Comprobante','sello')
        m.rfc_emi = obt_cam_xml(m.cfd_xml, 'cfdi:Emisor', 'rfc')
        //        m.rfc_emi=par_XML(m.cfd_xml,'cfdi:Emisor','rfc')
        m.rfc_rec = obt_cam_xml(m.cfd_xml, 'cfdi:Receptor', 'rfc')
        //       m.rfc_rec=par_XML(m.cfd_xml,'cfdi:Receptor','rfc')
        let selloSat = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'selloSAT')
        //        selloSat=par_XML(m.cfd_xml,'tfd:TimbreFiscalDigital','selloSat')
        //        selloSat=obt_cam_xml(m.cfd_xml,'tfd:TimbreFiscalDigital','selloSAT')
        let selloCFD = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'selloCFD')
        //           selloCFD=par_XML(m.cfd_xml,'tfd:TimbreFiscalDigital','selloCFD')
        m.sel_dig = iif(len(allTrim(m.sel_dig)) < 2, selloCFD, m.sel_dig)
        let noCertificadoSat = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'noCertificadoSat')
        //       noCertificadoSat=par_XML(m.cfd_xml,'tfd:TimbreFiscalDigital','noCertificadoSat')
        let FechaTimbrado = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'FechaTimbrado')
        //        FechaTimbrado=par_XML(m.cfd_xml,'tfd:TimbreFiscalDigital','FechaTimbrado')
        let No_version = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'version')
        //        No_version=par_XML(m.cfd_xml,'tfd:TimbreFiscalDigital','version')  && obtiene la version
        // obtiene la version
        let RfcProvCertif = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'RfcProvCertif')
        if (No_version == '1.0') {
          cad_tfd = '||' + No_version + '|' + UUID + '|' + FechaTimbrado + '|' + selloCFD + '|' + noCertificadoSat + '||'
        } else {

          cad_tfd = '||' + No_version + '|' + UUID + '|' + FechaTimbrado + '|' + RfcProvCertif + '|' + selloCFD + '|' + noCertificadoSat + '||'
        } // End If 

        if (File(arc_cad)) {
          let ins_dos = 'Delete File ' + arc_cad
            // borramos archivo cadena
            & ins_dos
        } // End If 

        await select(are_tra)

        return m.sel_dig

      } // End If 

    } // End If 

    m.sta_doc = 'P'
  } // End If 

  await select('vi_lla1_cer')

  let cer_ori = allTrim(m.cer_cer)
  m.cer_cer = enc_pal(cer_ori)
  await requery()

  m.cer_cer = cer_ori
  // recuperamos el valor del certificado
  let key_cer = position.Left(des_pas(rTrim(vi_lla1_cer.ubi_cer)) + space(120), 120)
  //login
  let pas_cer = position.Left(des_pas(rTrim(vi_lla1_cer.pwd_cer)) + space(20), 20)
  //nombre
  await select(are_tra)
  //key_cer=des_pas(ubi_cer)
  //pas_cer=des_pas(pwd_cer)

  const bin = [[],];// VFP Dime bin(8,2)

  for (let i = 1; i < 8; i++) {
    if (i == 1) {
      bin(i, 1) = 1
    } else {

      bin(i, 1) = bin(i - 1, 1) * 2
    } // End If 

    bin(i, 2) = position.Left(position.Left('00000000', 8 - i) + '1' + '00000000', 8)
  } // End For; 

  let arc_md5 = dir_com + '\'+allTrim(vi_lla1_doc.tdo_tdo)+lTrim(str(vi_lla1_doc.ndo_doc,8))+'.md5'
  // aumentamos la carpeta del cliente
  //dir_com=m.dir_cfd+"\"+Ltrim(Str(Year(vi_lla1_doc.fec_doc)))+'\'+CMONTH(vi_lla1_doc.fec_doc)+'\'+ALLTRIM(vi_lla1_doc.cod_nom)
  //arc_cfd=dir_com+'\'+IIF(LEFT(m.nem_pge,8)='LECHE 19' and substr(vi_lla1_doc.ref_doc,13,8)>'        ' ,ALLTRIM(substr(vi_lla1_doc.ref_doc,13,8))+'_','')+
  //IIF(m.dge_fim<='  ',vi_lla1_doc.tdo_tdo+RIGHT('0000000'+alLtrim(Str(vi_lla1_doc.ndo_doc)),8),
  //ALLTRIM(m.dge_fim)+RIGHT("0000000"+alLtrim(Str(con_des)),8))+'.xml'
  // generas archivo con la cadena original
  //arc_cad=Sys(2023)+'\'+SUBSTR(SYS(2015), 3)+'.TMP'
  // nombre donde quedo la cadena original
  // arc_cad=dir_com+'\'+Alltrim(vi_lla1_doc.tdo_tdo)+Ltrim(Str(vi_lla1_doc.ndo_doc,6))+'.cad' && nombre donde quedara la cadena original
  // nombre donde quedara el conprobante fiscal digital extendible
  //// arc_cfd=dir_com+'\'+IIF(m.dge_fim<='  ',vi_lla1_doc.tdo_tdo+RIGHT('0000000'+alLtrim(Str(vi_lla1_doc.ndo_doc)),8),
  //// ALLTRIM(m.dge_fim)+RIGHT("0000000"+alLtrim(Str(con_des)),8))+'.xml'
  // 16/Mar/2012 Se aumenta posicion 13 en delante de la referencia en el nombre del xml a generar
  // arc_cfd=dir_com+'\'+IIF(LEFT(m.nem_pge,8)='LECHE 19' and substr(vi_lla1_doc.ref_doc,13,8)>'        ' ,ALLTRIM(substr(vi_lla1_doc.ref_doc,13,8))+'_','')+
  //IIF(m.dge_fim<='  ',vi_lla1_doc.tdo_tdo+RIGHT('0000000'+alLtrim(Str(vi_lla1_doc.ndo_doc)),8),
  //ALLTRIM(m.dge_fim)+RIGHT("0000000"+alLtrim(Str(con_des)),8))+'.xml'
  // arc_md5=Sys(2023)+'\'+SUBSTR(SYS(2015), 3)+'.TMP'
  // archivo encriptado con MD5
  let lla_pem = Sys(2023) + '\'+substr(Sys(2015),3)+'.TMP'
  // llave privada
  let fir_dig = Sys(2023) + '\'+substr(Sys(2015),3)
  // fima digital
  let sello_dig = dir_com + '\'+allTrim(vi_lla1_doc.tdo_tdo)+lTrim(str(vi_lla1_doc.ndo_doc,8))+'.b64'
  // archivo donde quedara el sello digital
  // nombre donde quedara la firma
  ins_dos = 'openssl\bin\openssl pkcs8 -passin pass:' + pas_cer + ' -inform DER -in ' + key_cer + ' ' + ' -out ' + lla_pem
  // encriptamos en MD5
  // 1 ----    ins_dos='C:\OpenSSL\bin\openssl dgst -md5 -binary -out '+arc_md5+' '+arc_cad
  // 2 -----   Do runme With ins_dos               && && se esta utilizando run de gostscript
  //openssl pkcs8 -passin pass:<Password segun certificado> -inform DEM -in llave.key -out llave.pem
  //                ins_dos='openssl pkcs8 -inform DEM -in '+key_cer+' '+' -out '+lla_pem  &&Pide password
  // cambiamos el formato del certificado a DEM
  //ins_dos='C:\openssl\bin\openssl pkcs8 -passin pass:XXXXXXX -inform DEM -in '+key_cer+' '+' -out '+lla_pem
  //original
  //ins_dos='C:\openssl\bin\openssl pkcs8 -passin pass:'+pas_cer+' -inform DEM -in '+key_cer+' '+' -out '+lla_pem
  await runme(ins_dos)
  // openssl dgst -sign $key $cadena | openssl enc -base64 -A > C:WEB_SATsello.txt"
  // se esta utilizando run de gostscript


  // openssl rsautl -sign -inkey '+lla_pem+' -in '+arc_md5+' -out '+fir_dig
  // generamos el sello digital segun el archivo obtenido md5
  // 3 -----   ins_dos='C:\openssl\bin\openssl rsautl -sign -inkey '+lla_pem+' -in '+arc_md5+' -out '+fir_dig
  //---- nuevas instruciones -------------------------------------------------------
  // revizar esta rutina  posible se nesecitar encriptar en base64
  // openssl dgst -md5 -sign AAA010101AAA.key.pem | openssl enc -base64 -A
  // -sha1
  // ins_dos='OpenSSL\bin\openssl dgst -md5 -sign '+lla_pem+' -out '+arc_md5+' '+arc_cad     && anterior md5
  if (position.Left(m.cad_ori, 5) >= '||3.3') {
    // posterior a ver 3.2 utiliza sha256
    ins_dos = 'OpenSSL\bin\openssl dgst -sha256 -sign ' + lla_pem + ' -out ' + arc_md5 + ' ' + arc_cad
  } else {

    ins_dos = 'OpenSSL\bin\openssl dgst -sha1 -sign ' + lla_pem + ' -out ' + arc_md5 + ' ' + arc_cad
  } // End If 

  await runme(ins_dos)
  // se esta utilizando run de gostscript

  let arc = Fopen(lla_pem, 2)
  // openssl dgst -sha256 -verify publickey.pem \ -signature signature.sign
  //ins_dos='OpenSSL\bin\openssl dgst -sha256 -verify .\cer_prueba\Cert_Sellos\30001000000300023708.pem -signature '+arc_md5+' '+arc_cad
  //-------------------------------------------------------------------------------
  // 4 -- Do runme With ins_dos       && se esta utilizando run de gostscript
  Fwrite(arc, replicateString('0', 256))
  // rellenamos de ceros la llave privada
  Fclose(arc)
  ins_dos = 'Delete File ' + lla_pem
    // borra archivos temporales
    & ins_dos
  m.sel_dig = Filetostr(arc_md5)
  m.sel_dig = Strconv(m.sel_dig, 13)
  // convierte a b64
  ins_dos = 'Delete File ' + fir_dig
    // se sustituyeron por funcion de VFP
    // ins_dos='Delete File '+arc_md5
    // &ins_dos
    // se convierte el sello a base 64
    //4 -----ins_dos='C:\openssl\bin\openssl base64 -A -in '+fir_dig+' -out '+sello_dig
    //ins_dos='OpenSSL\bin\openssl enc -base64 -A  -in '+arc_md5+' -out '+sello_dig
    //Do runme With ins_dos       && se esta utilizando run de gostscript
    //m.sel_dig=Filetostr(sello_dig)
    & ins_dos

  // genera XML
  ////////////////////                  && se aumenta m.rfi_xml "regimen fiscal" +m.rfi_xml
  if (position.Left(m.cad_ori, 5) == '||3.2') {
    m.cad_XML = m.cad_XML + ' sello="' + m.sel_dig + '">' + m.emi_xml + m.rec_xml + m.con_xml + "</Conceptos>" + m.tra_xml
  } else {

    m.cad_XML = m.cad_XML + ' Sello="' + m.sel_dig + '">' + m.glo_xml + rel_xml + m.emi_xml + m.rec_xml + m.con_xml + "</Conceptos>" + m.tra_xml
    // 20/Feb/2022 .- Se aumenta m.glo_xml
  } // End If 

  let a = m.cad_XML
  let num_arc = Fcreate(arc_cfd, 0)
  // abrimos el archivo donde quedo el sello
  if (num_arc > 0) {
    Fwrite(num_arc, m.cad_XML, len(m.cad_XML))
    // Grabamos
    Fclose(num_arc)
  } else {

    await MessageBox('No se pudo generar archivo XML de su comprobante fiscal digital')

  } // End If 

  key_cer = '*******************************************************************'
  pas_cer = '*******************************************************************'
  ins_dos = 'Delete File ' + arc_md5
    & ins_dos
  ins_dos = 'Delete File ' + sello_dig
    & ins_dos
  ins_dos = 'Delete File ' + arc_cad
    & ins_dos
  if (m.dge_fim <= '  ') {
    m.tdo_tdo = vi_lla1_doc.tdo_tdo
    m.ndo_doc = vi_lla1_doc.ndo_doc
  } else {

    m.tdo_tdo = m.dge_fim
    m.ndo_doc = con_des
  } // End If 

  m.cad_XML = strtran(m.cad_XML, "'", "'+CHAR(39)+'")
  if (m.sta_doc != 'T' && !gen_tim) {
    // si ya esta firmado no graba el xml o si es un timbrado es un CFD Simple
    if (Public.value.ndb_emp == 4) {
      // si es portgres
      // Set Textmerge On 

      let variable = `DO $$\
-- SET TEXTSIZE 524288\
DECLARE M_key_pri  int ;\
DECLARE M_TDO_TDO  CHAR(3);\
DECLARE M_NDO_DOC  INT;\
DECLARE M_STA_DOC  CHAR(1);\
DECLARE M_fec_doc  TIMESTAMP(3);\
BEGIN\
M_TDO_TDO='${M.TDO_TDO}';\
M_NDO_DOC=${ALLTRIM(STR(m.ndo_doc))};\
M_STA_DOC='${m.sta_doc}';\
M_FEC_DOC='${dateToString(m.fec_doc)}';\
M_key_pri=0;\
SELECT M_key_pri=ISNULL(key_pri,0) from man_comexml  where tdo_tdo=M_tdo_tdo AND ndo_doc=M_ndo_doc;\
IF M_key_pri is null OR M_key_pri=0 THEN\
INSERT INTO man_COMEXML (tdo_tdo,ndo_doc,CFD_XML,STA_DOC) VALUES (M_tdo_tdo,M_ndo_doc,'${m.cad_xml}',M_STA_DOC);\
ELSE\
IF M_STA_DOC<>'C' THEN\
UPDATE man_COMEXML SET CFD_XML='${m.cad_xml}',STA_DOC=M_STA_DOC WHERE key_pri=M_key_pri;\
END IF\
IF M_STA_DOC='C' THEN\
UPDATE man_COMEXML SET CFD_XML='${m.cad_xml}' , STA_DOC='C' WHERE key_pri=M_key_pri;\
END IF\
END IF;\
END;\
$$;\
		`
      // EndText

    } else {

      // MSSQL y SYBASE
      // Set Textmerge On 

      let variable = `SET TEXTSIZE 524288\
DECLARE @key_pri as int\
DECLARE @TDO_TDO AS CHAR(3)\
DECLARE @NDO_DOC AS INT\
DECLARE @STA_DOC AS CHAR(1)\
DECLARE @fec_doc as DATETIME\
SET @TDO_TDO='${M.TDO_TDO}'\
SET @NDO_DOC=${ALLTRIM(STR(m.ndo_doc))}\
SET @STA_DOC='${m.sta_doc}'\
SET @FEC_DOC='${dateToString(m.fec_doc)}'\
SET @key_pri=0\
BEGIN tran\
SELECT @key_pri=ISNULL(key_pri,0) from man_comexml  where tdo_tdo=@tdo_tdo AND ndo_doc=@ndo_doc\
IF @key_pri is null OR @key_pri=0\
INSERT INTO man_COMEXML (tdo_tdo,ndo_doc,CFD_XML,STA_DOC) VALUES (@tdo_tdo,@ndo_doc,'${m.cad_xml}',@STA_DOC)\
ELSE\
begin\
IF @STA_DOC<>'C'\
UPDATE man_COMEXML SET CFD_XML='${m.cad_xml}',STA_DOC=@STA_DOC WHERE key_pri=@key_pri\
IF @STA_DOC='C'\
UPDATE man_COMEXML SET CFD_XML='${m.cad_xml}', STA_DOC='C' WHERE key_pri=@key_pri\
end\
commit tran\
		`
      // EndText

    } // End If 

    a = ins_sql
      = iif(await SQLExec(ins_sql)
        // Grabanos el xml en la base de datos
        > 0, true, err_sql())
  } // End If 

  await select(are_tra)
  // recuperamos area de trabajo

  return m.sel_dig

}   // Fin Procedure
// ----------- Genera cfdi --------------------------------------------------


// empresa timbradora, usuario, password y sitio web del timbrado
export async function gen_cfdi(emp_tim: any, usu_tim: any, pas_tim: any, web_tim: any, PARAM5: any, PARAM6: any) {
  let m = {}   // inicializamos m
  // Private area_tra , tot_pagado , sw_tim 

  let num_par = Parameters()
  let area_tra = await select()

  if (len(m.sel_dig) < 10) {
    await select('timbrado')
    //  borramos el temporal de timbraddo para generar codigo de barras

    // Set Safety Off 

    Zap
    await MessageBox('No hay sello digital. No se puede timbrar', 16, 'Error ')

    await select(area_tra)
    // seleccionamos el area de trabajo actual

    return 'Error :No hay sello digital. No se puede timbrar'

  } // End If 

  if (at('CFDI', upper(arc_cfd)) == 0) {
    // no se ha asignado el cfd a cfdi
    let tipo_doc = iif(m.dge_fim <= '  ', vi_lla1_doc.tdo_tdo, allTrim(m.dge_fim))
    let arc_cfdi = position.Left(arc_cfd, rat(allTrim(tipo_doc), arc_cfd) - 1) + right(arc_cfd, len(arc_cfd) - rat(allTrim(tipo_doc), arc_cfd) + 1)
    //11/01/2017
    // arc_cfdi=Left(arc_cfd,Rat(Alltrim(tipo_doc),arc_cfd)-1)+'CFDI'+Right(arc_cfd,Len(arc_cfd)-Rat(Alltrim(tipo_doc),arc_cfd)+1)
    //19/Jun/2019
  } else {

    arc_cfdi = arc_cfd
  } // End If 

  let ins_sql = [select cfd_xml, UUID, sta_doc  from man_comexml where tdo_tdo = ']+vi_lla1_doc.tdo_tdo+[' and ndo_doc =] + allTrim(str(vi_lla1_doc.ndo_doc))
  // busca si ya esta timbrado
  if (await SQLExec(ins_sql, 'sqlresult')
    < 0) {
    await MessageBox('Error al tratar de obtener datos xml del CFDI')

    return false

  } // End If 

  let sw_tim = false
  if (vi_lla1_doc.sta_doc == 'T') {
    if (await recCount('sqlresult') > 0) {
      // tiene cfdi en xml
      await select('sqlresult')

      m = appendM(m, await scatter(m))// scatter 

      m.ver_xml = obt_cam_xml(m.cfd_xml, 'cfdi:Comprobante', 'Version')
      m.sel_dig = obt_cam_xml(m.cfd_xml, 'cfdi:Comprobante', 'sello')
      m.rfc_emi = obt_cam_xml(m.cfd_xml, 'cfdi:Emisor', 'rfc')
      m.rfc_rec = obt_cam_xml(m.cfd_xml, 'cfdi:Receptor', 'rfc')
      let selloSat = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'selloSAT')
      let selloCFD = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'selloCFD')
      m.sel_dig = iif(len(allTrim(m.sel_dig)) < 2, selloCFD, m.sel_dig)
      let noCertificadoSat = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'noCertificadoSat')
      let FechaTimbrado = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'FechaTimbrado')
      let No_version = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'version')
      // obtiene la version
      let RfcProvCertif = obt_cam_xml(m.cfd_xml, 'tfd:TimbreFiscalDigital', 'RfcProvCertif')
      if (No_version == '1.0') {
        // version del CFDI
        let cad_tfd = '||' + No_version + '|' + UUID + '|' + FechaTimbrado + '|' + selloCFD + '|' + noCertificadoSat + '||'
      } else {

        cad_tfd = '||' + No_version + '|' + UUID + '|' + FechaTimbrado + '|' + RfcProvCertif + '|' + selloCFD + '|' + noCertificadoSat + '||'
      } // End If 

      if (vi_lla1_doc.sta_doc != 'T') {
        // Inicio replace VFP
        const Recno = await recNo()
        const Alias = await alias()
        await localAlaSql(`update ${Alias} set vi_lla1_doc.sta_doc=?  where recno=${Recno} `, ['T'])

      } // End If 

      m.sta_doc = 'T'
    } else {

      if (vi_lla1_doc.sta_doc == 'T') {
        if (await MessageBox('Posiblemente el CFDI ya se timbró, pero el sistema no recibió su XML correspondiente. Si quiere tratar de timbrarlo otra ves?', 4 + 32)
          != 6) {
          await select(are_tra)

          return false

        } // End If 

      } // End If 

      sw_tim = true
      m.sta_doc = 'P'
    } // End If 

  } // End If 

  if (cad_tfd > '  ' || m.sta_doc == 'T') {
    // si ya se genero el sello digital es una reimpresio
    if (await recCount('TIMBRADO') == 0 || UUID != timbrado.uui_tim) {
      // si es diferente el numero de serie de certificacion se genera un registro nuevo de timbrado
      await select('timbrado')
      //  grabamos el temporal de timbraddo para gnerar codigo de barras

      // Set Safety Off 

      Zap
      await appendBlank()

      m = appendM(m, await scatterBlank(m))// scatter 

      // Inicio replace VFP
      const Recno = await recNo()
      const Alias = await alias()
      await localAlaSql(`update ${Alias} set sel_tim=? , uui_tim=? , cer_tim=? , fec_tim=? , rfc_tim=?  where recno=${Recno} `, [selloSat, UUID, noCertificadoSat, FechaTimbrado, RfcProvCertif])

      let rfc_emi = Public.value.rfc_pge
      // genera codigo de barras bidimencional
      let rfc_rec = vi_lla1_nom.rfc_nom
      if (await select('vi_car_por')
        > 0 && await recCount('vi_car_por') > 0) {
        let numReg = await recNo()
        await select('vi_car_por')

        await goto('TOP')

        let ffsVia = vi_car_por.ffs_via
        // VFP LOCATE For num_ori=0
        let records = await locateFor(` num_ori=0`)

        if (!Found()) {
          await goto('TOP')

        } // End If 

        // VFP LOCATE For num_ori=1
        let records = await locateFor(` num_ori=1`)

        if (!FOUND()) {
          await goto('TOP')

        } // End If 

        ffsVia = vi_car_por.ffs_via
        await goto(numReg)

        gen_cod_bid_cp(vi_car_por.idccp, ffsVia)
      } else {

        gen_cod_bid(rfc_emi, rfc_rec, vi_lla1_doc.imp_doc + vi_lla1_doc.im1_doc + vi_lla1_doc.im2_doc + vi_lla1_doc.im3_doc + iif(Public.value.sw_imp, vi_lla1_doc.im4_doc + vi_lla1_doc.im5_doc, 0), UUID)
      } // End If 

      // Set Safety On 

    } // End If 

    await select(area_tra)

    if (!File(arc_cfdi)) {
      // revisa si existe el archivo xml, y si no existe lo crea en el directorio de comprobantes digitales

      ////////////
      if (Public.value.ndb_emp == 4) {
        // 02/Oct/2018
        let pos = atc('<', m.cfd_xml)
        if (pos > 1) {
          m.cfd_xml = right(m.cfd_xml, len(m.cfd_xml) - pos + 1)
        } else {

          m.cfd_xml = Strconv(m.cfd_xml, 9)
        } // End If 

        Strtofile(m.cfd_xml, arc_cfdi, 4)
        // graba el xml
      } else {

        Strtofile(m.cfd_xml, arc_cfdi)
        //////////
        // graba el xml
      } // End If 

    } // End If 

    if (at('CFDI', upper(arc_cfd)) == 0) {
      // si no se ha asignado, cuando es una reimpresion
      let arc_cfd = arc_cfdi
    } // End If 

    await select(area_tra)
    // seleccionamos el area de trabajo actual

    return cad_tfd

  } // End If 


  // Verifica que se pueda timbrar
  if (await select('vi_cap_pag')
    > 0) {
    // si es timbrado de pagos
    await select('vi_cap_pag')

    let tot_pagado = await localAlaSql("select  Sum ( mon_pag ) From vi_cap_pag")
    // anterior <>

    tot_pagado(1) = Nvl(tot_pagado(1), 0)
    if (Round(tot_pagado(1), 2) + 0.99 < Round(vi_lla1_doc.imp_doc + vi_lla1_doc.im0_doc + vi_lla1_doc.im1_doc + vi_lla1_doc.im2_doc + vi_lla1_doc.im3_doc + vi_lla1_doc.im4_doc + vi_lla1_doc.im5_doc, 2)) {
      await MessageBox('No se puede timbrar porque no esta totalmente asignado el importe del pago con los documentos pagados', 16, 'Error', 5000)

      await select(are_tra)

      return

    } // End If 

  } // End If 

  await select('timbrado')
  //  borramos el temporal de timbraddo para generar codigo de barras

  // Set Safety Off 

  Zap
  m.cfd_xml = ''
  let ARC_XML = Filetostr(arc_cfd)
  // dir_com=m.dir_cfd+"\"+Ltrim(Str(Year(vi_lla1_doc.fec_doc)))
  // dir_com=dir_com+'\'+CMONTH(vi_lla1_doc.fec_doc)+'\'+ALLTRIM(vi_lla1_doc.cod_nom)  && se aumenta la carpeta del cliente
  // obtenemos el archivo original xml
  // arc_cfd=dir_com+'\'+IIF(m.dge_fim<='  ',vi_lla1_doc.tdo_tdo+RIGHT('0000000'+alLtrim(Str(vi_lla1_doc.ndo_doc)),8),
  //ALLTRIM(m.dge_fim)+RIGHT("0000000"+alLtrim(Str(con_des)),8))+'.xml'
  // leemos archivo xml antes de timbrar
  pos = at('>', ARC_XML)
  // buscamos la primer etiqueta  >
  let pri_eti = position.Left(ARC_XML, pos)
  // obtenemos la primer etiqueta
  ARC_XML = right(ARC_XML, len(ARC_XML) - pos)
  ARC_XML = strtran(ARC_XML, "<", "<cfdi:")
  // aumentamos cfdi:
  ARC_XML = strtran(ARC_XML, "<cfdi:/", "</cfdi:")
  let eti_pag = 'pago10:'
  // complemento de pago
  if (cometdo.dba_tdo == 'PG4') {
    eti_pag = 'pago20:'
  } // End If 


  // eti_pag='pago'+ALLTRIM(STR(VAL(ver_xml)//10),2)+':'
  if (atc(eti_pag, ARC_XML) > 0) {
    // es un pago , quita etiquetas
    ARC_XML = strtran(ARC_XML, "cfdi:" + eti_pag, eti_pag)
    ARC_XML = strtran(ARC_XML, "<cfdi:Impuestos  >  </cfdi:Impuestos>", "")
  } // End If 


  //If Atc('pago10',ARC_XML)>0    && es un pago , quita etiquetas
  // ARC_XML=Strtran(ARC_XML,"cfdi:pago10:", "pago10:")
  // ARC_XML=Strtran(ARC_XML,"<cfdi:Impuestos  >  </cfdi:Impuestos>","")
  //ENDIF
  // 25/03/2021 Fernando Cuadras
  // Quita cfdi: del complemento de detallista
  if (atc('detallista', ARC_XML) > 0) {
    ARC_XML = strtran(ARC_XML, "cfdi:detallista:", "detallista:")
  } // End If 

  ARC_XML = strtran(ARC_XML, "<cfdi:cartaporte20", "<cartaporte20")
  // quitamos cfd en carta porte
  ARC_XML = strtran(ARC_XML, "</cfdi:cartaporte20", "</cartaporte20")
  ARC_XML = strtran(ARC_XML, "<cfdi:cartaporte30", "<cartaporte30")
  // quitamos cfd en carta porte
  ARC_XML = strtran(ARC_XML, "</cfdi:cartaporte30", "</cartaporte30")
  ARC_XML = strtran(ARC_XML, "<cfdi:cartaporte31", "<cartaporte31")
  // quitamos cfd en carta porte
  ARC_XML = strtran(ARC_XML, "</cfdi:cartaporte31", "</cartaporte31")

  // Incluye el complemento
  //ARC_XML=Strtran(ARC_XML,'</cfdi:Comprobante>',+m.enc_com+m.det_com+m.pie_com+'</cfdi:Comprobante>')
  // quita espacios dobles
  while (at(ARC_XML, '  ') > 0) {
    ARC_XML = strtran(ARC_XML, '  ', ' ')
  } // End while 

  await select('vi_lla1_doc')
  // Marcamos como timbrado el documento

  m = appendM(m, await scatter(m))// scatter 

  let variable = `BEGIN ;\
SELECT 1* case\
when sta_doc='T' then 1\
else\
0\
END  as sw_timbrado\
from man_comedoc  where tdo_tdo='${m.tdo_tdo}' AND ndo_doc=${ALLTRIM(STR(m.ndo_doc))} ;`
  //// 10/Jun/2022  Se comenta todo ya que el estatus se pone desde el trigger de comexml
  // Ponemos el estatus del documento en actualizacion y queda bloqueada la base de datos para protegerla
  //!// If m.ndb_emp<4   && si no es Postgres
  //!// && la transaccion debe ser independiente para que al momento de actualizar man_comedoc no de error de transacciones.
  //!//  =Iif(SQLExec(num_dbs,'BEGIN TRANSACTION')<0,err_sql(),'')
  //!//  TEXT TO ins_sql NOSHOW TEXTMERGE PRETEXT 1+2
  //!//        UPDATE  man_comedoc SET TIMESTAMP=CAST(?m.timestamp as timestamp) ,sta_doc='T' where tdo_tdo='<<m.tdo_tdo>>' AND ndo_doc=<<ALLTRIM(STR(m.ndo_doc))>> 
  //  ENDTEXT
  //!// Endif
  //!// If m.ndb_emp=4   && Si es Postgres
  //!//  Set Textmerge On
  //!//  TEXT TO ins_sql NOSHOW TEXTMERGE PRETEXT 1+2
  //!//      --    BEGIN 
  //                from man_comedoc  where tdo_tdo='<<m.tdo_tdo>>' AND ndo_doc=<<ALLTRIM(STR(m.ndo_doc))>> 
  //
  //!//          UPDATE  man_comedoc SET TIMESTAMP=?m.timestamp ,sta_doc='T' where tdo_tdo=?m.tdo_tdo AND ndo_doc=?M.ndo_doc 
  //  ENDTEXT
  //!// Endif
  let ins_ver_sql = iif(Public.value.ndb_emp != 4, strtran(ins_ver_sql, 'BEGIN ;', ''), ins_ver_sql)
  if (await SQLExec(ins_ver_sql, 'resultado')
    < 0) {
  // si hay error al grabar
      =err_sql()
      = iif(await SQLExec(ins_sql)
        // ins_sql="ROLLBACK TRANSACTION ; "
        < 0, err_sql(), 0)
    await MessageBox('No se pudo timbrar el CFDI ya que posiblemente se este utilizando por otra persona ', 16)

    // Set Safety On 

    return false

  } // End If 

  if (resultado.sw_timbrado == 1 && !sw_tim) {
    // si ya se timbro o el sw_tim nos indica pide que no se vuelva a timbrar
    if (Public.value.ndb_emp == 4) {
      ins_sql = "ROLLBACK TRANSACTION ; "
        = iif(await SQLExec(ins_sql)
          < 0, err_sql(), 0)
    } // End If 

    await MessageBox('No se pudo timbrar el CFDI ya que se timbro anteriormente', 16)

    releaseUse() // use 

    await select('vi_lla1_doc')

    await requery()

    // Set Safety On 

    return false

  } // End If 

  releaseUse() // use 

  await select('vi_lla1_doc')
  ////////////////////////////////////////////////////////////////////// 16/Jun/2022 //////////////////////////////
  //If SQLExec(num_dbs,ins_ver_sql,'resultado')<0  && si hay error al grabar
  // =err_sql()
  // ins_sql="ROLLBACK TRANSACTION ; "
  // =Iif(SQLExec(num_dbs,ins_sql)<0,err_sql(),0)
  // Messagebox('No se pudo timbrar el CFDI ya que posiblemente se este utilizando por otra persona ',16)
  // Set Safety On
  // Return .F.
  //Endif
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  m = appendM(m, await scatter(m))// scatter 

  // Inicio replace VFP
  //&
  const Recno = await recNo()
  const Alias = await alias()
  await localAlaSql(`update ${Alias} set vi_lla1_doc.sta_doc=?  where recno=${Recno} `, ['X'])

    =gra_reg()
  let a = ins_sql
  await select(area_tra)
  // seleccionamos el area de trabajo actual

  let pro_tim = 'timbrado\'+allTrim(emp_tim)
  // Set Procedure To ( pro_tim ) Additive 
  // indicamos cual el procedimiento de la empresa de timbrado

  let UUID = ''
  switch (true) {
    //########
    case num_par == 4:
      let ret = timbrado(usu_tim, pas_tim, web_tim)
      // mandamos timbrar
      break
    case num_par == 5:
      ret = timbrado(usu_tim, pas_tim, web_tim, PARAM5)
      // mandamos timbrar
      break
    case num_par == 6:
      ret = timbrado(usu_tim, pas_tim, web_tim, PARAM5, PARAM6)
    // mandamos timbrar
  } // End case 

  //VFP  Procedure Procedure ( pro_tim )
  // liberamos el procedure


  // El resultado viene en la variable ARC_XML
  if (UUID > ' ') {
    // Si se timbro y si hay identificador, graba en la base de datos y genera codigo bidimencional

    // //////////  16/Jun/2022 para mssql no se necesita commit Transaction
    if (Public.value.ndb_emp < 4) {

      //  =Iif(SQLExec(num_dbs,'commit TRANSACTION')<0,err_sql(),'')
    } else {
        
        =iif(await SQLExec('commit ;')
      < 0, err_sql(), '')
    } // End If 

    m.tdo_tdo = vi_lla1_doc.tdo_tdo
    //////////////////////////////////////////
    m.ndo_doc = vi_lla1_doc.ndo_doc
    m.sta_doc = 'T'
    if (inc_ade == false && len(allTrim(m.enc_add)) > 2) {
      // no esta incluida la addenda
      m.enc_add = strtran(m.enc_add, 'Addenda>', 'cfdi:Addenda>')
      m.pie_add = strtran(m.pie_add, 'Addenda>', 'cfdi:Addenda>')
      ARC_XML = strtran(ARC_XML, '</cfdi:Comprobante>', allTrim(m.enc_add + m.det_add + m.pie_add) + '</cfdi:Comprobante>')
      Strtofile(ARC_XML, arc_cfdi)
      // graba fisicamente el xml con adenda
      m.enc_add = ''
      m.det_add = ''
      m.pie_add = ''
    } // End If 

    let xml_env = strtran(ARC_XML, "'", "''")
    // generamos instruccion para actualizar el MSSQL
    m.UUID = UUID
    m.emp_tim = emp_tim
    m.xml_env = xml_env

    // Nov/2021 se revizo
    if (Public.value.ndb_emp == 4) {
      // 02/Oct/2018
      pos = atc('<', m.xml_env)
      if (pos > 1) {
        m.xml_env = right(m.xml_env, len(m.xml_env) - pos + 1)
      } // End If 

      m.xml_env = Strconv(m.xml_env, 11)
      // convierte a UTF para guardarlo en Postgres
    } // End If 


    // 12/Jul/2019
    if (await select('vi_imp_pag')
      > 0) {
      let res = await localAlaSql("INSERT INTO doc_timbrados select tdo_tdo , ndo_doc From vi_imp_pag Group By tdo_tdo , ndo_doc")

    } else {

      let res = await localAlaSql("INSERT INTO doc_timbrados select tdo_tdo , ndo_doc From vi_lla1_doc")

    } // End If 

    await select('doc_timbrados')

    m.cuu_xml = 0
    // iniciamos contador de UUID
    if (Public.value.ndb_emp == 1) {
      ins_sql = 'set TEXTSIZE 524288; '
    } else {

      ins_sql = ''
    } // End If 

    // VFP SCAN 
    while (!eof()) {
      let tdo_act = "'" + doc_timbrados.tdo_tdo + "'"        let ndo_act = allTrim(str(doc_timbrados.ndo_doc))        let cuu_act = allTrim(str(m.cuu_xml))        // Set Textmerge On 
      // obtenemos los documentos que tiene que actualizar
      let variable = `		   INSERT INTO man_COMEXML (tdo_tdo,ndo_doc,CFD_XML,STA_DOC,UUID,emt_xml) VALUES (${tdo_act},${ndo_act},?m.xml_env,'T',?m.UUID,?m.emp_tim);\
		`
      // EndText
      ins_sql = ins_sql + src_sql        m.cuu_xml = m.cuu_xml + 1
      // generamos toda la cadena de actualizacion
      skip()
    } // End while 

    releaseUse() // use 

    await select('vi_lla1_doc')


    //!//  If m.ndb_emp=4    && postgres
    //!//   ins_sql=ins_sql+' commit ;'
    //!//  Endif
    // grabamos en la base de datos
    if (await SQLExec(ins_sql)
      < 0) {
        =err_sql()
      await MessageBox('Error al grabar el XML del CFDI en la base de datos', 16, 'Error de SQL')

      ret = 'error'
      await select(area_tra)
      // seleccionamos el area de trabajo actual

      a = ins_sql
      Cancel
    } // End If 

    if (!File(arc_cfdi)) {
      // revisa si existe el archivo xml, y si no existe lo crea en el directorio de comprobantes digitales
      m.cfd_xml = m.xml_env
      if (Public.value.ndb_emp == 4) {
        // 02/Oct/2018
        pos = atc('<', m.cfd_xml)
        if (pos > 1) {
          m.cfd_xml = right(m.cfd_xml, len(m.cfd_xml) - pos + 1)
        } else {

          m.cfd_xml = Strconv(m.cfd_xml, 9)
        } // End If 

        Strtofile(m.cfd_xml, arc_cfdi, 4)
        // graba el xml
      } else {

        Strtofile(m.cfd_xml, arc_cfdi)
        // graba el xml
      } // End If 

    } // End If 

    // Set Safety Off 

    await select('timbrado')

    await appendBlank()

    m = appendM(m, await scatterBlank(m))// scatter 
    // insertamos los datos nuevos

    // Inicio replace VFP
    const Recno = await recNo()
    const Alias = await alias()
    await localAlaSql(`update ${Alias} set sel_tim=? , uui_tim=? , cer_tim=? , fec_tim=? , rfc_tim=?  where recno=${Recno} `, [selloSat, UUID, noCertificadoSat, FechaTimbrado, RfcProvCertif])

    rfc_emi = Public.value.rfc_pge
    // genera codigo de barras bidimencional
    rfc_rec = vi_lla1_nom.rfc_nom
    if (await select('vi_car_por')
      > 0 && await recCount('vi_car_por') > 0) {
      numReg = await recNo()
      await select('vi_car_por')

      await goto('TOP')

      ffsVia = vi_car_por.ffs_via
      // VFP LOCATE For num_ori=0
      let records = await locateFor(` num_ori=0`)

      if (!Found()) {
        await goto('TOP')

      } // End If 

      // VFP LOCATE For num_ori=1
      let records = await locateFor(` num_ori=1`)

      if (!FOUND()) {
        await goto('TOP')

      } // End If 

      ffsVia = vi_car_por.ffs_via
      await goto(numReg)

      gen_cod_bid_cp(vi_car_por.idccp, ffsVia)
    } else {

      gen_cod_bid(rfc_emi, rfc_rec, vi_lla1_doc.imp_doc + vi_lla1_doc.im1_doc + vi_lla1_doc.im2_doc + vi_lla1_doc.im3_doc + iif(Public.value.sw_imp, vi_lla1_doc.im4_doc + vi_lla1_doc.im5_doc, 0), UUID)
    } // End If 

  } else {


    // si no se pudo timbrar, quita el estatus y lo pone como posible timbrado
    if (Public.value.ndb_emp == 4) {
      ins_sql = "ROLLBACK ; "
        = iif(await SQLExec(ins_sql)
          < 0, err_sql(), 0)
    } // End If 

    await MessageBox('El servicio de timbrado termino sin resultado ', 16)

    let nom_tim = dir_com + '\timb' + iif(m.dge_fim <= '  ', allTrim(vi_lla1_doc.tdo_tdo) + right('0000000' + allTrim(str(vi_lla1_doc.ndo_doc)), 8), allTrim(m.dge_fim) + right("0000000" + allTrim(str(con_des)), 8)) + '.xml'
    await select('vi_lla1_doc')

    await requery()


    //IF vi_lla1_doc.sta_doc<>'T'
    if (File(nom_tim)) {
      // si hay error de timbrado lo ponemos en proceso
      // Inicio replace VFP
      const Recno = await recNo()
      const Alias = await alias()
      await localAlaSql(`update ${Alias} set sta_doc=?  where recno=${Recno} `, ['P'])

    } else {

      // Inicio replace VFP
      const Recno = await recNo()
      const Alias = await alias()
      await localAlaSql(`update ${Alias} set sta_doc=?  where recno=${Recno} `, ['X'])

    } // End If 

      =gra_reg()
    // Set Safety On 

    return ret

  } // End If 

  // Set Safety On 

  arc_cfd = arc_cfdi
  await select('vi_lla1_doc')
  //Select (are_tra)                   && seleccionamos el area de trabajo actual
  // actualizamos sus datos ya timbrados

  await tableUpdate()

  await requery()

  await select(area_tra)
  // seleccionamos el area de trabajo actual

  return ret

}   // Fin Procedure
//==============================< llamada a web service >======================================================
//  URL='https://dev.facturacfdi.mx:8081/WSTimbrado/WSForcogsaService?wsdl'
// pFileRequest=FILETOSTR('request_autenticar.xml')
// =EjecutaWS(URL, pFileRequest , 'token.xml','','','')
// LLamadas Post a Web Services

export async function EjecutaWS() {
  let m = {}   // inicializamos m
    (pURL_WSDL, pFileRequest, pFileResponse, User, Password, CERTIFICADO)
  let sw_err = false
  try {
    let oHTTP = Createobject('Msxml2.ServerXMLHTTP.6.0')
    //
  }
  catch (error) {
    sw_err = true
  } // End Try

  if (sw_err) {
    await MessageBox('error :No tiene instalado el MSXML server')

    return 'error :No tiene instalado el MSXML server'

  } // End If 

  if (len(User) < 2) {
    oHTTP.Open("POST", pURL_WSDL, false)
  } else {

    oHTTP.Open("POST", pURL_WSDL, false, User, Password)
  } // End If 

  let envelope = pFileRequest
  let lon_pFileRequest = len(envelope)
  oHTTP.setRequestHeader("Content-Length", '"' + allTrim(str(lon_pFileRequest)) + '"')
  //set the length of the content
  oHTTP.setRequestHeader("Content-Type", "text/xml; charset=utf-8")

  // El path es el oath donde esta en el register   "LOCAL_MACHINE\My\my certificate"
  if (len(CERTIFICADO) > 1) {
    oHTTP.SETOPTION(3, allTrim(CERTIFICADO))
  } // End If 

  let resultado = 0
  //       oHTTP.Send("username=htbasaran&password=somepassword")
  try {
    oHTTP.Send(envelope)            resultado = oHTTP.Status
  }
  catch (error) {
    resultado = 9999
  } // End Try

  await deleteLocalSql(File)
  // 4/jun/2018 borramos la respuesta para asegurarnos que esta vacio y no tome datos de otro timbre

  if (resultado == 200) {
    let res_xml = Strconv(oHTTP.responsetext, 9)
    Strtofile(res_xml, pFileResponse)
    // res_xml=oHTTP.responsexml.xml
  } else {


    // error al tratar de timbrar
    if (resultado != 9999) {
      Strtofile(oHTTP.responsetext, pFileResponse)
      let err_wes = oHTTP.responsetext
    } else {

      err_wes = 'Error en Internet'
    } // End If 

    //VFP  oHTTO oHTTO

    return 'error:' + err_wes

  } // End If 

  //VFP  oHTTO oHTTO

  return ''

}   // Fin Procedure


//!// 'CADENA ORIGINAL DEL COMPLEMENTO DE CERTIFICACION DIGITAL DEL SAT : '+cad_tfd+CHR(13)+
//        'SELLO DIGITAL DEL SAT : '+selloSat+CHR(13)+
//        'FOLIO FISCAL DEL SAT :'+UUID+CHR(13)+
//        'No DE SERIE DEL CERTIFICADO DE SELLO DIGITAL DEL SAT :'+noCertificadoSAT+CHR(13)+
//        'FECHA Y HORA DE CERTIFICACION :'+FechaTimbrado
//---------------------< Genera codigo de barras dimencional para CFDI >--------------------
export async function gen_cod_bid() {
  let m = {}   // inicializamos m
    (rfc_emi, rfc_rec, tot_doc, UUID)

  // quitamos espacios en blanco
  if (let res = await localAlaSql("select ('timbrado') = 0")
) {
    return false

  } // End If 

  let rfc_emi = allTrim(rfc_emi)
  let rfc_rec = allTrim(rfc_rec)
  let UUID = allTrim(UUID)
  let imp_doc = allTrim(str(tot_doc, 10, 6))

  //SET  STEP on
  if (m.ver_xml == '3.2') {
    let lcDato = [?re =] + rfc_emi + [& rr=] + rfc_rec + [& tt=] + imp_doc + [& id=] + UUID
  } else {

    lcDato = [https://verificacfdi.facturaelectronica.sat.gob.mx/default.aspx?id=]+UUID+[&re=]+rfc_emi+[&rr=]+rfc_rec+[&tt=]+imp_doc+[&fe=]+allTrim(right(m.sel_dig,8))
    } // End If 

  let lcImagen = Sys(2023) + '\'+substr(Sys(2015),3)+'.bmp'
  //lcDato = strtran(lcDato,'&','%26')
  cod_bid(lcDato, lcImagen)
  //XAXX010101000&rr=XAXX010101000&tt=1234567890.123456&id=ad662d33-6934-459c-a128-BDf0393f0f44]
  // llama al generador de codigo de barras
  await select('timbrado')

  if (!_wine) {
    await append(Generaltimbrado.bid_timFrom(lcImagen))

  } // End If 

  // Inicio replace VFP
  const Recno = await recNo()
  const Alias = await alias()
  await localAlaSql(`update ${Alias} set arc_bid=?  where recno=${Recno} `, [lcImagen])

  return true

}   // Fin Procedure


//---------------------< Genera codigo de barras dimencional para cartaPorte  >--------------------
//!// -------- Ejemplo --------------------------------------
//!// https://verificacfdi.facturaelectronica.sat.gob.mx/verificaccp/default.aspx?
//!// &IdCCP=CCC3EB8D-81CD-4557-8719-26632D2FA434&FechaOrig=2023-02-10T10:30:21
//!// &FechaTimb=2023-02-10T10:32:21
export async function gen_cod_bid_cp() {
  let m = {}   // inicializamos m
    (UUID, fecOri)

  // quitamos espacios en blanco
  if (let res = await localAlaSql("select ('timbrado') = 0")
) {
    return false

  } // End If 

  let UUID = 'idCCP=' + UUID
  // Se quito '&' CHR(38)'idCCP='+UUID carta porte 3.1
  let FechaOrig = char(38) + 'FechaOrig=' + TTOC(fecOri, 3)
  let FechaTimbrado = char(38) + 'FechaTimb=' + timbrado.fec_tim
  let lcDato = [https://verificacfdi.facturaelectronica.sat.gob.mx/verificaccp/default.aspx?]+UUID+FechaOrig+fechaTimbrado
    let lcImagen = Sys(2023) + '\'+substr(Sys(2015),3)+'.bmp'
  //lcDato = strtran(lcDato,'&','%26')
    cod_bid(lcDato, lcImagen)
  //XAXX010101000&rr=XAXX010101000&tt=1234567890.123456&id=ad662d33-6934-459c-a128-BDf0393f0f44]
  // llama al generador de codigo de barras
    await select('timbrado')

    if (!_wine) {
    await append(Generaltimbrado.bid_timFrom(lcImagen))

  } // End If 

  // Inicio replace VFP
  const Recno = await recNo()
  const Alias = await alias()
  await localAlaSql(`update ${Alias} set arc_bid=?  where recno=${Recno} `, [lcImagen])

  return true

}   // Fin Procedure


//!// IF GoogleQR(lcDato,'300x300',lcImagen) == 0
//!//    RETURN lcImagen
//!// ELSE
//!//     MESSAGEBOX('Error en la generacion del Codigo QR',0+16,'GoogleQR')
//!//     RETURN ''
//!// ENDIF

// Genera cod bidimensional por medio de dll
export async function cod_bid(lcDato: any, lcImagen: any) {
  let m = {}   // inicializamos m
    // Declare SetConfiguration In BarCodeLibrary.Dll As Configura Integer , Integer 

    // Declare GenerateFile In BarCodeLibrary.Dll As GeneraBi String , String 

    = Configura(6, 0)
    //   4-6=TamaÃ±o   0=bmp,1=jpg,2=png
    = GeneraBi(lcDato, lcImagen)
  // lcDato=datos para generar el codigo, LcImagen=archivo donde quedara la imagen
  // Clear Dlls Configura , GeneraBi 

  return

}   // Fin Procedure

export async function GoogleQR() {
  let m = {}   // inicializamos m
    (pDato, pDimensiones, pImagen)
  // Genera cod bidimensional por medio de google
  await MessageBox("Generando y descargando Código QR, espere por favor..."Nowait)

  // Declare Long URLDownloadToFile In "urlmon" Long pCaller , String szURL , String szFileName , Long dwReserved , Long lpfnCB 

  let sURL = "https://chart.googleapis.com/chart?cht=qr&chs=" + pDimensiones + "&chld=Q&chl=" + strtran(pDato, '&', '%26')
  let nRetVal = URLDownloadToFile(0, sURL, pImagen, 0, 0)

  return nRetVal

}   // Fin Procedure


//=====================< Pasea unavariable con xml >===========================================
// par_XML('D:/Desarrollo/Sistemas/Come_VIII/Timbre/PAC_Kit/CFDI.XML','cfdi:Comprobante','certificado')
// parametros var_xml : variable con contenido  a parsear
//            nod_xml : Nodo buscado
//            atr_xml : Atributo
// regresa  : El valor del atributo
export async function par_xml(var_xml: string, nod_xml: any, atr_xml: any) {
  let m = {}   // inicializamos m
  // Local xdoc 
  // AS MSXML2.DOMDocument

  let var_xml = strtran(var_xml, '<cfdi:Comprobante', '<archivo><cfdi:Comprobante')
  // Aumentamos variable atributo
  var_xml = strtran(var_xml, '/cfdi:Comprobante>', '/cfdi:Comprobante></archivo>')
  let xdoc = Createobject("Msxml2.DOMDocument.6.0")
  //!// Creamos un objeto basado en MSXML
  let par_xml = Sys(2023) + '\'+substr(Sys(2015),3)+'.TMP'
  //xdoc=CREATEOBJECT('MSXML2.DOMdocument')
  //!// Cargamos el archivo XML a procesar
  // Creamos el xml temporal
  Strtofile(var_xml, par_xml)
  // grabamos el archivo
  xdoc.Load(par_xml)

  //!// Llamamos a la función LeerNodos pasÃ¡ndole el nodo raÃ­z
  if (xdoc.XML > ' ') {
    return LeeNodos(xdoc.documentElement.childNodes, nod_xml, atr_xml)

  } // End If 

  return ''

}   // Fin Procedure

export async function LeeNodos(rootAsMSXML2: any.IXMLDOMNode: any, nom_nod: string, atr_nod: string | number | undefined) {
  let m = {}   // inicializamos m
  // Local Child As MSXML2.IXMLDOMNode 

  for (const Child of root) {


    //    ? 'NODO '+CHILD.nodeName
    if (upper(Child.nodeName) == upper(nom_nod) && atr_nod > ' ') {
      for (const Item of Child.Attributes) {

        if (upper(Item.basename) == upper(atr_nod)) {
          return Item.nodeValue

        } // End If 

      } // End For;
      //        ?  '         Atributo '+item.basename+' Valor '+item.nodeValue

    } else {

      if (upper(Child.nodeName) == upper(nom_nod)) {
        return Child.Text

      } // End If 

    } // End If 

    if (Child.hasChildNodes) {
      let val_res = LeeNodos(Child.childNodes, nom_nod, atr_nod)
      if (val_res > ' ') {
        return val_res

      } // End If 

    } // End If 

  } // End For; 

  return ''

}   // Fin Procedure


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////// definicion de variables que recibe:
////// var_xml : variable donde se va a hacer la busqueda de los elementos
////// dat_etq : etiqueta a buscar
////// dat_atr : atributo a buscar
////// numero de etiquetas a buscar
export async function obt_cam_xml(var_xml: string | Promise<string>, dat_etq: string, dat_atr: string, num_ele: number | undefined) {
  let m = {}   // inicializamos m
  switch (true) {
    case Parameters() == 3:
      let num_ele = 1
      break
    case Parameters() == 2:
      num_ele = 1
      let dat_atr = ' '
      break
    case Parameters() == 1:
      return ' '

  } // End case 

  if (num_ele == 0) {
    num_ele = 1
  } // End If 

  m.par_sel = var_xml
  //m.par_sel=STRTRAN(var_xml,'  ',' ')     && elimina dobles espacios,
  //m.par_sel=STRTRAN(m.par_sel,' =','=')    && elimina espacios entre el =,
  //m.par_sel=STRTRAN(m.par_sel,'= ','=')    && elimina espacios entre el =,
  //m.par_sel=STRTRAN(m.par_sel,'< / ','</')   && elimina espacios entre el </,
  //m.par_sel=STRTRAN(m.par_sel,'<  ','< ')    && elimina espacios entre el <
  //m.par_sel=STRTRAN(m.par_sel,' >','>')    && elimina espacios entre el <
  let dat_sal = ' '
  let pet_ini = 1
  let pet_fin = len(m.par_sel)
  let pet_fin1 = 0
  if (len(allTrim(dat_etq)) > 0) {
    let var_bus = '<' + allTrim(dat_etq)
    // buasca la etiqueta con teminacion etiqueta
    pet_ini = atc(var_bus, m.par_sel, num_ele)
    pet_ini = iif(len(allTrim(dat_etq)) == 0, 1, pet_ini)
    if (pet_ini > 0 && substr(m.par_sel, pet_ini + len(allTrim(var_bus)), 1) == '>') {
      let lon_etq = len(allTrim(var_bus)) + 1
      m.par_sel = allTrim(substr(m.par_sel, pet_ini + lon_etq, len(allTrim(m.par_sel)) - lon_etq - pet_ini + 1))
      var_bus = '</' + allTrim(dat_etq) + '>'
      // buasca la etiqueta con teminacion etiqueta
      pet_fin = atc(var_bus, m.par_sel, 1)
      lon_etq = len(allTrim(var_bus))
      pet_fin1 = 0
    } else {

      lon_etq = len(allTrim(var_bus))
      m.par_sel = allTrim(substr(m.par_sel, pet_ini + lon_etq, len(allTrim(m.par_sel)) - lon_etq - pet_ini + 1))
      let dat_bus = '</' + allTrim(dat_etq) + '>'
      pet_fin = atc(dat_bus, m.par_sel, 1)
      pet_fin1 = atc('/>', m.par_sel, 1)
      lon_etq = len(allTrim(dat_etq))
      let lon_etq1 = 2
    } // End If 

  } // End If 

  if (pet_ini > 0) {
    pet_ini = 1
    // if 1    si encuentra la etiqueta, obtiene los datos
    if (pet_fin == 0) {
      pet_fin = pet_fin1
      lon_etq = 2
    } // End If 

    if ((pet_fin != 0 && pet_fin1 != 0) && (pet_fin > pet_fin1)) {
      pet_fin = pet_fin1
      lon_etq = 2
    } // End If 

    if (pet_fin > 0) {
      // if 2
      m.par_sel = ' ' + allTrim(substr(m.par_sel, pet_ini, pet_fin - 1))
      // obtiene etiqueta
      if (len(allTrim(dat_atr)) > 0) {
        // if 3        si hay atributo a buscar,
        let atr_bus = ' ' + allTrim(dat_atr) + '='
        //         atributo a buscar.
        let lon_tot = len(M.par_sel)
        let pos_ini = atc(atr_bus, m.par_sel, 1)
        let pos_fin = 0
        if (pos_ini > 0) {
          // if 4          si se encuentra el atributo,
          pos_ini = pos_ini + len(atr_bus) + 1
          //   obtiene la ubicacion inicial
          m.par_sel = substr(m.par_sel, pos_ini, lon_tot - pos_ini + 1)
          // corta la variable donde se busca a partir de donde s encontro el atr
          pos_fin = atc('"', m.par_sel, 1) - 1
          // obtiene la posicion final del atributo
        } // End If 

        // end 4
        dat_sal = iif(pos_fin > 0, substr(m.par_sel, 1, pos_fin), ' ')
        // obtiene el atributo buscado, en caso de no encontrarlo envia un blanco
      } else {

        // en caso de encontrar la etiqueta y no hay atributo
        if (position.Left(m.par_sel, 1) == '>') {
          //            si en la pos. inicial de la etiqueta aparece '>', se elimina
          m.par_sel = substr(m.par_sel, 2, len(m.par_sel) - 1)
        } // End If 

        if (right(m.par_sel, 1) == '<') {
          //            si en la pos. final de la etiqueta aparece '<', se elimina
          m.par_sel = substr(m.par_sel, 1, len(m.par_sel) - 1)
        } // End If 

        dat_sal = m.par_sel
        //     se asigna a la variable de return el valor de la etiqueta
      } // End If 

      // end 3
    } else {

      dat_sal = ' '
      //   se envia un blanco en caso de no encontrar la etiqueta
    } // End If 

    // end 2
  } // End If 

  // end 1
  dat_sal = strtran(dat_sal, "&lt;", "<")
  // remplaza token
  dat_sal = strtran(dat_sal, "&gt;", ">")
  // remplaza token
  dat_sal = strtran(dat_sal, "&quot;", '"')
  // remplaza token
  dat_sal = strtran(dat_sal, "&amp;", '&')
  // remplaza token
  return allTrim(dat_sal)
  //    regresa el resultado

}   // Fin Procedure


// ---------------< Remplaso por caracteres validos >------------------------------
// parametros : str_rem Strin a remplazar por caracteres validos
// En el caso del & se deberÃ¡ usar la secuencia &amp
// En el caso del â€œ se deberÃ¡ usar la secuencia &quot
// En el caso del < se deberÃ¡ usar la secuencia &lt
// En el caso del > se deberÃ¡ usar la secuencia &gt
// En el caso del â€˜ se deberÃ¡ usar la secuencia &#36
//---------------------------------------------------------------------------------

//string a remplazar
export async function rem_car(str_rem: string) {
  let m = {}   // inicializamos m
  let str_rem = allTrim(str_rem)
  // quitamos los espacios a la dereche e izquierda
  let ocu = 1
  let pos = at('&', str_rem, ocu)

  while (pos > 0) {
    str_rem = position.Left(str_rem, pos - 1) + '&amp;' + right(str_rem, len(str_rem) - pos)      ocu = ocu + 1      pos = at('&', str_rem, ocu)
  } // End while 

  ocu = 1
  pos = at('"', str_rem)

  while (pos > 0) {
    str_rem = position.Left(str_rem, pos - 1) + '&quot;' + right(str_rem, len(str_rem) - pos)      ocu = ocu + 1      pos = at('"', str_rem)
  } // End while 

  ocu = 1
  pos = at('<', str_rem)

  while (pos > 0) {
    str_rem = position.Left(str_rem, pos - 1) + '&lt;' + right(str_rem, len(str_rem) - pos)      ocu = ocu + 1      pos = at('<', str_rem)
  } // End while 

  ocu = 1
  pos = at('>', str_rem)

  while (pos > 0) {
    str_rem = position.Left(str_rem, pos - 1) + '&gt;' + right(str_rem, len(str_rem) - pos)      ocu = ocu + 1      pos = at('>', str_rem)
  } // End while 

  ocu = 1
  pos = at('â€˜', str_rem)

  while (pos > 0) {
    str_rem = position.Left(str_rem, pos - 1) + '&#36;' + right(str_rem, len(str_rem) - pos)      ocu = ocu + 1      pos = at('â€˜', str_rem)
  } // End while 

  ocu = 1
  pos = at('  ', str_rem)

  while (pos > 0) {
    str_rem = position.Left(str_rem, pos - 1) + ' ' + right(str_rem, len(str_rem) - pos - 1)      ocu = ocu + 1      pos = at('  ', str_rem)
  } // End while 

  str_rem = Strconv(str_rem, 9)
  // convierte a UTF-8 por requerimiento del SAT
  return str_rem

}   // Fin Procedure
// Remplazo de caracteres para generar el CFDI


// remplaza caracteres que no estan permitidos en la cadena original
export async function mod_car(str_rem: string) {
  let m = {}   // inicializamos m
  let str_rem = allTrim(str_rem)
  // quitamos los espacios a la derecha e izquierda
  str_rem = allTrim(strtran(str_rem, char(13), ' '))
  str_rem = allTrim(strtran(str_rem, char(10), ' '))
  str_rem = allTrim(strtran(str_rem, char(9), ' '))
  let pos = at('  ', str_rem)

  while (pos > 0) {
    str_rem = allTrim(strtran(str_rem, '  ', ' '))      pos = at('  ', str_rem)
  } // End while 

  return str_rem
  //!// ocu=1
  //!// pos=At(Chr(13),str_rem)    && remplazamos RT
  //!// Do While pos>0
  //!//  str_rem=Left(str_rem,pos-1)+' '+Right(str_rem,Len(str_rem)-pos)
  //!//  ocu=ocu+1
  //!//  pos=At(Chr(13),str_rem)
  //!// Enddo
  //!// ocu=1
  //!// pos=At(Chr(10),str_rem) && remplazamos LF
  //!// Do While pos>0
  //!//  str_rem=Left(str_rem,pos-1)+' '+Right(str_rem,Len(str_rem)-pos)
  //!//  ocu=ocu+1
  //!//  pos=At(Chr(10),str_rem)
  //!// Enddo
  //!// ocu=1                && quita espacios vacios
  //!// pos=At('  ',str_rem)
  //!// Do While pos>0
  //!//  str_rem=Left(str_rem,pos-1)+' '+Right(str_rem,Len(str_rem)-pos-1)
  //!//  ocu=ocu+1
  //!//  pos=At('  ',str_rem)
  //!// Enddo
  //!// ocu=1                && signo de grados centigrados
  //!// pos=At('Âº',str_rem)
  //!// Do While pos>0
  //!//    str_rem=Left(str_rem,pos-1)+'g.'+Right(str_rem,Len(str_rem)-pos)
  //!//    ocu=ocu+1
  //!//    pos=At('Âº',str_rem)
  //!// enddo

}   // Fin Procedure
// ---------- < Rellena a ceros las codigos de clientes o proveedores >-----------
// Fecha 19/May/2014

export async function jus_cer(m: { cop_nom: string; cod_nom: string }.cod_nom: any, m: any.cop_nom: any) {
  let m = {}   // inicializamos m
  // Private lon_cta 

  // Dimension niv_cap ( 5 ) 

  switch (true) {
    case m.cop_nom == 'C':
      let ima_cap = Public.value.icl_pge
      break
    case m.cop_nom == 'P':
      ima_cap = Public.value.ipr_pge
      break
    case m.cop_nom == 'E':
      // presupuesto
      ima_cap = Public.value.ipg_pge
  } // End case 

  for (let i = 1; i < 5; i++) {
    niv_cap(i) = 0
    let pos = at('-', ima_cap)
    // busca primera posición
    if (pos == 0) {
      pos = len(allTrim(ima_cap)) + 1
    } // End If 

    if (pos > 1) {
      niv_cap(i) = pos - 1
      ima_cap = right(ima_cap, len(ima_cap) - pos)
    } // End If 

  } // End For; 

  m.cod_nom = strtran(m.cod_nom, ' ', '')
  // Quita los espacios
  let lon_cta = len(m.cod_nom)
  i = 1
  // checa cta. y si necesario rellena el ultimo nivel a ceros
  // contador de niveles
  let posIni = 1
  // posicion inicial
  let cod_pas = ''
  // subniveles antes de rellenarse a ceros
  let subCta = ''
  // subcta. analizandose
  let sw_sal = true

  while (sw_sal) {
    if (niv_cap(i) > 0) {
      subCta = rTrim(substr(m.cod_nom, posIni, niv_cap(i)))
      //niv_cta
      if (len(subCta) < niv_cap(i)) {
        subCta = '000000000' + subCta
        subCta = right(subCta, niv_cap(i))
      } // End If 

      cod_pas = cod_pas + subCta
      if (len(cod_pas) >= lon_cta) {
        // salida de rutina
        sw_sal = false
      } // End If 

      posIni = len(cod_pas) + 1
      i = i + 1
    } else {

      sw_sal = false
    } // End If 
  } // End while 

  return cod_pas

}   // Fin Procedure
// ---------------------< Impresion de reporte ya sea de la base de datos o del directorio de reportes >-----------------------


// direcrorio del reporte, nombre del reporte , sal_impresion
export async function imp_reporte(dir_reporte: any, nom_reporte: string, sal_impresion: string, imp_etiqueta: any, arc_salida: string | number, imp_salida: number) {
  let m = {}   // inicializamos m
  // Private dir_reporte , nom_reporte , sal_impresion , imp_etiqueta , arc_salida , imp_salida , mail_to , m_nom_frx , sw_gra 

  let mail_to = ''
  // cuando se utiliza FOXY, el arc_salida es la direcion de envio del email
  if (Parameters() == 5) {
    mail_to = arc_salida
  } // End If 

  if (Parameters() == 3) {
    let imp_etiqueta = false
  } // End If 

  let set_impresora = iif(Parameters() == 6 && imp_salida > 'A ', true, false)
  // Set Textmerge Off 

  // Set Talk Off 

  let sta_con =// Set ( "CONSOLE" ) 

    // Set Console Off 

    let sw_rep_sql = true
  let are_tra = await select()

  m.nom_frx = allTrim(nom_reporte)
  let nom_rep = m.nom_frx + Sys(2015) + '.frx'
  if (await select('reportefrx')
    > 0) {
    await select('reportefrx')

    releaseUse() // use 

  } // End If 

  try {

    // trata de obtener el reporte desde la base de datos
    if (let res = await localAlaSql("select ('vi_cap_frx') = 0 OR ( Select ( 'vi_cap_frx' ) > 0 AND ALLTRIM ( vi_cap_frx.nom_frx ) != LOWER ( m.nom_frx ) )")
) {
      if (await select('vi_cap_frx')
        > 0) {
        await select('vi_cap_frx')

      } else {

        await select('0')

      } // End If 

      await use('vi_cap_frx', m) // use vi_cap_frx vi_cap_frx

    } else {

      await select('vi_cap_frx')

    } // End If 
    await goto('TOP')
    await MessageBox(WindowsNowait'recuperando reporte desde SQL SERVER ')
    if (await recCount('vi_cap_frx') == 0) {
      // no esta el reporte en la base de datos
      await select('vi_cap_frx')

      releaseUse() // use 

      sw_rep_sql = false
      let for_rep = dir_reporte + nom_reporte
      await MessageBox(WindowsNowaitfor_rep + 'recuperando reporte localmente ')

    } else {

      let res = await localAlaSql("INSERT INTO reportefrx select * , _unique As Unique , _order As Order , _user As User , _double As Double , _top As style.top , _offset As OFFSET From vi_cap_frx Where Upper ( nom_frx ) = Upper ( m.nom_frx ) Order By ord_frx")

      await select('reportefrx')

    } // End If 
  }
  catch (error) {

    // si no se han subido los reporte a la base de datos
    await MessageBox(WindowsNowait'recuperando reporte localmente ')
    sw_rep_sql = false            for_rep = dir_reporte + nom_reporte
  } // End Try

  if (sw_rep_sql) {
    // si hay reporte desde la base de datos
    let ubi_reporte = Sys(2023) + '\'+nom_rep
    // ubi_reporte='reportessql\'+nom_rep   && ubicacion del reporte
    //+SYS(2015)
    await select('0')

    // Set Safety Off 
    // USE reportessql\reporte    && tabla base del reporte

    await use('comefrx', m) // use comefrx comefrx

    // Copy To ( ubi_reporte ) 
    // lo copiamos al directorio donde va quedar el reporte

    await select('comefrx')

    await use((ubi_reporte), m) // use ( (
    // abrimos el reporte destino

    let sel_ubi = await select()

    await select('reportefrx')

    await goto('TOP')
    // leemos registo por registro el reporte traido del mssql

    // VFP SCAN 
    while (!eof()) {
      m = appendM(m, await scatter(m))// scatter 
      m.TIMESTAMP = 0        await select(sel_ubi)
      //   m.tag2=''
      // nos posicionamos en el reporte destino
      await appendBlank()
      await gatherFrom(m)
      //  IF m.tag2 is null
      //     m.tag2=''
      //  endif
      // insertamos el registro
      await select('reportefrx')

      skip()
    } // End while 

    releaseUse() // use 

    await select(sel_ubi)

    await goto('TOP')

    if (sal_impresion == 'TXT') {
      if (!style.top) {
        // Inicio replace VFP
        const Recno = await recNo()
        const Alias = await alias()
        await localAlaSql(`update ${Alias} set style.top=? , style.width=?  where recno=${Recno} `, [true, style.width + 2334])

      } // End If 

    } // End If 

    if (sal_impresion == 'XLS') {
      if (style.top) {
        // Inicio replace VFP
        const Recno = await recNo()
        const Alias = await alias()
        await localAlaSql(`update ${Alias} set style.top=? , style.width=?  where recno=${Recno} `, [false, style.width - 2334])

      } // End If 

    } // End If 

    releaseUse() // use 

    for_rep = ubi_reporte
    // Set Safety On 

  } else {

    ubi_reporte = for_rep
  } // End If 

  let sw_pdf_pre = false
  // regresamos la ubicacion donde quedo el reporte
  if (sal_impresion == 'PDF_PREVIEW') {
    let sal_impresion = 'PDF'
    sw_pdf_pre = true
  } // End If 

  if ((position.Left(sal_impresion, 3) == 'PDF' || sal_impresion == 'TXT' || sal_impresion == 'HTML') && arc_salida < ' ') {
    // no hay archivo de salida
    let arc_salida = Putfile('Nombre del archivo:', Sys(2003), lower(sal_impresion))
  } // End If 

  await select(are_tra)

  switch (true) {
    case sal_impresion == 'FOXY':
      // FoxyPreviiewer
      await foxypreview\foxypreview(mail_to)

      break
    case position.Left(sal_impresion, 3) == 'PAN':
      // Pantalla
      if (imp_etiqueta) {
        // ejecura el reporte
        // Label Form ( for_rep ) Preview 

      } else {

        // Report Form ( for_rep ) Preview 

      } // End If 

      break
    case sal_impresion == 'SILENCIO':
      // 12/Nov/2014
      let reporte = Createobject('ReportListener')
      reporte.ListenerType = -1
      // salida por 1=pantalla 5=HTML
      reporte.PrintjobName = for_rep
      // nombre que tendra en los jobs de impresion
      reporte.Quietmode = false
      // Quita el avance del reporte
      // Report Form ( for_rep ) Object reporte 
      //nowait

      //VFP  reporte reporte

      break
    case sal_impresion == 'IMP':
      // Impresora
      if (imp_etiqueta) {
        // Label Form ( for_rep ) Noconsole To Printer Prompt 
        //nowait

      } else {

        if (set_impresora) {
          // si se pide impresion con una impresora predefinida
          // Set Printer To prop.Name ( imp_salida ) 
          // direccionamos impresora

          // Report Form ( for_rep ) Noconsole To Printer 
          //nowait

        } else {

          // Report Form ( for_rep ) Noconsole To Printer Prompt 
          //nowait

        } // End If 

      } // End If 

      break
    case position.Left(sal_impresion, 3) == 'PDF':
      // Impresion PDF
      let arc_ori = allTrim(arc_salida)
      if (!File(arc_ori) || (len(arc_ori) > 5 && File(arc_ori) && await MessageBox('El archivo ' + arc_ori + ' ya existe. Lo sobreescribimos ', 4 + 32, 'Advertencia')
        == 6)) {
        let arc_imp = position.Left(rTrim(arc_salida), len(arc_salida) - 3) + 'ps'
        // Set Printer To prop.Name PDF 

        let ps_temp = Sys(2023) + '\'+Sys(2015)+'.ps'
        //       report form (for_rep) NOCONSOLE to file Rtrim((nom_arc))   && generamos archivo postscript
        // Report Form ( for_rep ) Noconsole To File Rtrim ( ( ps_temp ) ) 
        // generamos archivo postscript


        //       if file(nom_arc) AND ps2pdf(nom_arc,ps_temp)        && convertimos a archivo pdf
        if (!File(ps_temp)) {
          await MessageBox('No se pudo generar el archivo Post Script. Verifique que tenga definida una impresora con driver PS', 16, 'Error')

          // Set Printer To Default 

          // Set Console &sta_con 

          await select(are_tra)

          return

        } // End If 

        if (File(ps_temp) && ps2pdf(arc_imp, ps_temp)) {
          // convertimos a archivo pdf
          if (sw_pdf_pre && await MessageBox('Abrimos el archivo ' + arc_ori, 4 + 32 + 256)
            == 6) {
            let ins_fox = 'RUN /N Explorer.Exe ' + arc_ori
              & ins_fox
          } // End If 

        } else {

          await MessageBox('Error al generar archivo ')
          //           thisform.mod_rep=.f.

        } // End If 

      } // End If 

      // Set Printer To Default 

      if (sal_impresion == 'PDFMAIL') {
        try {
          const router = useRouter();
          router.push({ name: 'formas/correos_pdf', params: { Param1: arc_ori, Param2: sw_imp_for } })
        }
        catch (error) {
          const router = useRouter();
          router.push({ name: 'formas/correos_pdf', params: { Param1: arc_ori, Param2: false } })

        } // End Try

      } // End If 

      break
    case sal_impresion == 'TXT':
      // Impresion TXT
      let _Asciirows = 1
      let _Asciicols = 240
      // Report Form ( for_rep ) Noeject Noconsole To File Rtrim ( arc_salida ) Ascii 
      //  nowait

      await MessageBox('Archivo generado')

      break
    case sal_impresion == 'HTML':
      // Impresion HTML
      let loListener = Null
      // Set Console Off 

      await _ReportOutput(5, loListener)

      loListener.TargetFileName = lower(rTrim((arc_salida)))
      // Set Console Off 
      //         loListener.QuietMode = .T.

      // Report Form ( for_rep ) Object loListener 

      let nom_arc = '"' + rTrim((arc_salida)) + '"'
      // nombre del archivo a generar en su caso
      if (type("oShell") == "O" && !isNull(oShell)) {

        // Object exists
      } else {

        let oShell = Createobject("wscript.shell")
      } // End If 
      // Object  does not exist

      oShell.Run(arc_salida)
      break
    //  MESSAGEBOX("El archivo se ha exportado a  "+nom_arc,64+0+0,"Aviso")
    //  DO FORM formas\cor_exp WITH nom_arc    && ejecuta el explorador
    case sal_impresion == 'XLS':
      // Impresion a Excel
      reporte = Newobject('excel_listener', 'frxpreview\report_listeners.vcx')
      // Report Form ( for_rep ) Noconsole Object reporte 
      //nowait

      break
    case sal_impresion == 'MODI':
      // modifica reporte
      if (imp_etiqueta) {
        Modify// Label ( ubi_reporte ) 

      } else {

        Modify// Report ( ubi_reporte ) 

      } // End If 

      this.Form.prop.key = Lastkey()
      if (sw_rep_sql && this.Form.prop.key != 27) {
        // si hay reporte desde la base de datos volverlo a subir ya modificado
        await MessageBox(WindowsNowait'Subiendo el reporte a la base de datos')

        let con_id = 0
        await select('vi_cap_frx')

        await useNodata('vi_cap_frxaliasrep_nuevo') // use vi_cap_frx vi_cap_frx Nodata

        m = appendM(m, await scatterBlank(m))// scatter 
        // Inicializamos variables

        let time_stamp = m.TIMESTAMP
        m.nom_frx = allTrim(nom_reporte) + '.nue'
        await select('0')
        // abrimos reporte fuente

        await use((ubi_reporte), m) // use ( (

        await goto('TOP')

        // VFP SCAN 
        while (!eof()) {
          let sw_gra = 0          m = appendM(m, await scatter(m))// scatter 
          m.TIMESTAMP = time_stamp          m._user = m.user          m._double = m.double          m._top = m.style.top          m._unique = m.unique          m._order = m.order          m._offset = m.OFFSET          m.ord_frx = await recNo()                    try {
            // 10/Mar/2021
            await select('rep_nuevo')
            await appendBlank()
            await gatherFrom(m)
            await select(ubi_reporte)
            sw_gra = 1
          }
          catch (error) {
            // Set Step On 
            await tableRevert()
            await MessageBox('Error al grabar el reporte en la base de datos')

          } // End Try
          if (sw_gra == 0) {
            return

          } // End If 

          skip()
        } // End while 

        releaseUse() // use 

        await select('rep_nuevo')

        releaseUse() // use 

        m.nom_frx = allTrim(nom_reporte)
        switch (true) {
          case Public.value.ndb_emp == 1:
            // Set Textmerge On 

            let variable = `BEGIN TRANSACTION\
if exists(select key_pri from man_comefrx  WHERE nom_frx='${m.nom_frx}'+'.nue')\
begin\
while exists(select key_pri from man_comefrx  WHERE nom_frx='${m.nom_frx}')\
DELETE top (1) from man_comefrx  WHERE nom_frx='${m.nom_frx}'\
while exists(select key_pri from man_comefrx  WHERE nom_frx='${m.nom_frx}'+'.nue')\
update top (1) man_comefrx SET nom_frx='${m.nom_frx}'  WHERE nom_frx='${m.nom_frx}'+'.nue'\
end\
commit tran\
			`
            // EndText

            break
          case Public.value.ndb_emp == 4:
            // Set Textmerge On 

            let variable = `BEGIN TRANSACTION ;\
DELETE from man_comefrx  WHERE nom_frx='${m.nom_frx}' ;\
update man_comefrx SET nom_frx='${m.nom_frx}' WHERE nom_frx='${m.nom_frx}'||'.nue' ;\
commit TRANSACTION ;\
			`
          // EndText

        } // End case 


        let a = ins_sql
        if (await SQLExec(ins_sql)
          < 0) {
          await MessageBox(Windows'Error al actualizar el reporte en la base de datos')

          =err_sql()
        } // End If 

      } // End If 

    // si es reporte sql
  } // End case 

  //VFP  reporte reporte

  //VFP  rep_htm rep_htm

  if (sw_rep_sql) {
    // si hay reporte sql , borraos su temporal
    await deleteLocalSql(File)
    // borramos archivos del reporte

    ubi_reporte = strtran(ubi_reporte, 'frx', 'FRT')
    await deleteLocalSql(File)

  } // End If 

  // Set Printer To Default 

  // Set Console &sta_con 
  //   SET REPORTBEHAVIOR 90

  await select(are_tra)

  return

}   // Fin Procedure
//////////////////////////// Procedimiento para revisar seg por documentos >-------


////////////////////////////////////////////
export async function rev_seg_doc() {
  let m = {}   // inicializamos m
  await select('cometdo')
  // selecciona que documentos se pueden utilizar

  return

}   // Fin Procedure
/////////////////////////////////// Procedimientos para archivos ////////////////////////////////////////
// --------------< Procedimiento para generar archivos >-------
// Este procedimiento genera un archivo dbf desde el diccionario de
// datos
// Parametros de entrada :
//     a) nom_arc. Nombre del archivo a generar
//     b) dir_arc. Directorio donde se encontrara el archivo
// -------------------------------------------------------------
// --------------< Procedimiento para generar indices >-------
// Este procedimiento genera los indices del los archivos
// del diccionario de datos
// Parametros de entrada :
//     a) nom_arc. Nombre del archivo a generar
//     b) dir_arc. Directorio donde se encontrara el archivo
//     c) solo inicializa los archivos sin incluir funciones de validación
// -------------------------------------------------------------

export async function gen_ind(nom_arc: string, dir_arc: string, ini_arc: any, ini_seg: any) {
  let m = {}   // inicializamos m
  if (Parameters() < 3) {
    let ini_seg = false
  } // End If 

  if (Parameters() == 2) {
    let ini_arc = false
  } // End If 

  let nom_arc = upper(rTrim(nom_arc))
  let dir_arc = upper(rTrim(dir_arc))
  let sw_sal = false
  let sw_tab_nue = false
  let ins_sql = 'Select comedat.*,vis_tab,tri_msq,tri_pos From comedat join cometab on comedat.nom_tab=cometab.nom_tab Where upper(cometab.nom_tab)=?nom_arc order by con_dat'
  //ins_sql='Select comedat.*,vis_tab,man_tab,tri_msq,tri_pos From comedat join cometab on comedat.nom_tab=cometab.nom_tab Where upper(cometab.nom_tab)=?nom_arc order by con_dat'
  if (await SQLExec(ins_sql, 'est_tab')
    < 0) {
    // si esta el diccionario de datos en la base de datos
    let res = await localAlaSql("INSERT INTO est_tab select * From comedat Where position.Left ( arc_dat , 3 ) = Right ( Rtrim ( nom_arc ) , 3 )")

    let res = await localAlaSql("INSERT INTO tabla select nom_tab , vis_tab , tri_msq , tri_pos From cometab Where nom_tab = Upper ( nom_arc )")

  } // End If 

  if (await recCount() == 0) {
    // no hay tabla
    releaseUse() // use 

    return

  } // End If 

  m = appendM(m, await scatter(m))// scatter 

  let sql_campos = ' '
  let sql_view = ' '
  let sw_bin = true
  // switch de borrado indices
  const tabla = [];// VFP Dime tabla(5)

  // On Error 

  // Set Safety Off 

  // Set Talk Off 

  if (Public.value.ndb_emp == 4) {
    // Si es PostgreSQL
    sql_view = 'create view public.man_' + lower(nom_arc) + ' ('
    let dro_view = 'drop view IF EXISTS public.man_' + lower(nom_arc)
  } else {

    sql_view = 'create view man_' + lower(nom_arc) + ' ('
    // sql_view='create view dbo.man_'+LOWER(nom_arc)+' ('
    dro_view = 'drop view man_' + lower(nom_arc)
  } // End If 

  if (ini_arc) {
    // reviza si cambio de estructura
    MessageBox('Revisando estructura del archivo:  ' + nom_arc)

    if (Public.value.sql_emp == 'S') {
      // si es sql
      ins_sql = 'SELECT min(KEY_PRI) from ' + nom_arc
      // reviza  si la tabla en la base de datos
      if (await SQLExec(ins_sql)
        < 0) {
        // si no existe el archivo
        if (await MessageBox("El archivo " + nom_arc + " No existe deseas crearlo", 4 + 32)
          == 6) {

          await cre_tab(nom_arc)
          // ,dir_arc

          sw_tab_nue = true
        } // End If 

      } // End If 

      if (Public.value.ndb_emp == 3) {
        // Si es Sybase
        let ins_fox = 'use vi_lla1_' + right(nom_arc, 3) + ' alias estructura nodata'
          & ins_fox
      } else {

        ins_fox = upper('create sql view estructura REMOTE CONNECTION SIAVCOM SHARE as select * from ' + nom_arc)
          // se declara una vista sin datos para poder traerse su estructura
          & ins_fox
        // crea la vista remota
        await select('est_tab')

        await goto('TOP')

        // VFP SCAN 
        while (!eof()) {
          if (tip_dat == 'X' || tip_dat == 'M') {
            DBSetProp("estructura." + des_dat, "Field", "DataType", "M")
          } // End If 

          skip()
        } // End while 

        await useNodata('estructura') // use estructura estructura Nodata

      } // End If 

      let ele_tab =const est_vie = afields()

      // reviza estructura
      for (let i = 1; i < ele_tab; i++) {
        // alen(est_vie)/4   && arregla tipos numericos
        if (est_vie(i, 2) == 'N') {
          est_vie(i, 3) = est_vie(i, 3) - 2
        } // End If 

        if (est_vie(i, 2) == 'T') {
          // se cambia el tipo de datos de date a time
          est_vie(i, 2) = 'D'
        } // End If 

        if (est_vie(i, 2) == 'M') {
          est_vie(i, 3) = 10
        } // End If 

      } // End For; 

    } else {
        
        =const est_vie = afields()

      // reviza estructura
    } // End If 

    await select('estructura')

    releaseUse() // use 

    let dic_dat = position.Left(nom_arc, 4) + 'dat'
    // define el diccionario de datos
    let dic_ind = position.Left(nom_arc, 4) + 'ind'
    // define el diccionario de indices
    dic_dat = 'comedat'
    // define el diccionario de datos
    dic_ind = 'comeind'
    // define el diccionario de indices
    ins_sql = "Select * From comedat Where nom_tab=?nom_arc Order By con_dat"
    await select('0')

    if (await SQLExec(ins_sql, 'diccionario')
      < 0) {
      // si esta el diccionario de datos en la base de datos
      let res = await localAlaSql("INSERT INTO diccionario select * From ( dic_dat ) Where position.Left ( Upper ( arc_dat ) , 3 ) = Right ( Upper ( nom_arc ) , 3 ) AND Right ( arc_dat , 3 ) != '000' AND des_dat != 'Borrado' Order By arc_dat")

      await select(dic_dat)

      releaseUse() // use 

    } // End If 

    await select('0')

    ins_sql = "Select * From COMEIND Where Upper(nom_tab)=Upper(?nom_arc)"
    if (await SQLExec(ins_sql, 'indices')
      < 0) {
      // si esta el diccionario de datos en la base de datos
      let res = await localAlaSql("INSERT INTO indices select * From ( dic_ind ) Where Upper ( nom_arc ) = Upper ( dbf_ind )")

    } // End If 

    await select('diccionario')
    // Select // From (dic_ind) Where Upper(nom_arc)=Upper(dbf_ind) 
    //  into Cursor indices

    let sw_dat = false
    // switch de cambio de Estructura
    ins_fox = 'alter table ' + nom_arc + ' '
    ins_sql = 'alter table ' + nom_arc + ' '
    // 19/Feb/2009 se pone esta opcion para poder Hacer un alter  sp_dboption "select into/bulkcopy", true
    sql_campos = ' '
    if (Public.value.ndb_emp == 3) {
      // si es Sybase sp_dboption "select into/bulkcopy", true
      ins_sql = '  alter table ' + nom_arc + ' '
    } // End If 

    let num_ele = Alen(est_vie) / 18
    //     num_ele=alen(est_vie)/16 &&  calcula el número de elementos de la estructura vieja
    // 7/FEB/2007 se cambia la divicion entre 18
    //  calcula el número de elementos de la estructura vieja
    // VFP SCAN 
    while (!eof()) {
      // recorre campo por campo y reviza su estructura
      sql_campos = sql_campos + allTrim(des_dat) + ','
      // si es Postgres, no aumenta el campo TIMESTAMP
      //        IF m.ndb_emp=4 AND  upper(des_dat)='TIMESTAMP'
      //           reg=0
      //        else
      if (allTrim(des_dat) == upper('OFFSET')) {
        // aumenta comillas a campos especiales
        sql_campos = strtran(sql_campos, ',OFFSET', ',"OFFSET"')
      } // End If 
      let reg = ascan(est_vie, allTrim(upper(des_dat)))
      // busca el nombre del campo
      //       endif
      if (Public.value.ndb_emp == 2 && upper(des_dat) == 'TIMESTAMP') {
        reg = ascan(est_vie, allTrim('TIMEST'))
        // busca el nombre del campo
      } // End If 
      if (reg > 0) {

        // si existe el campo pero es diferente la estructura
        // Si es MSSQL7
        if ((Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3 || Public.value.ndb_emp == 4) && ((allTrim(tip_dat) != allTrim(est_vie(reg + 1)) && tip_dat != 'V') || (lon_dat != est_vie(reg + 2) && tip_dat != 'I' && tip_dat != 'G' && tip_dat != 'V' && tip_dat != 'B') || dec_dat != est_vie(reg + 3))) {
          if (position.Left(upper(des_dat), 6) != 'TIMEST' && upper(des_dat) != 'KEY_PRI'.And.upper(des_dat) != 'USU_CRE'.And.upper(des_dat) != 'TIE_CRE'.And.upper(des_dat) != 'TIE_UAC' && est_vie(reg + 1) != 'M' && est_vie(reg + 1) != 'X' && est_vie(reg + 1) != 'G') {

            //SET STEP ON
            if (await MessageBox('Se cambia el campo:' + des_dat + ' Tipo anterior=' + est_vie(reg + 1) + ' Tipo nuevo=' + tip_dat + ' Longitud anterior=' + str(est_vie(reg + 2)) + ',' + str(est_vie(reg + 3), 2) + ' Longitud nueva=' + str(lon_dat) + ',' + str(dec_dat, 2), 4 + 32)
              == 6) {

              sw_dat = true
              if (Public.value.sql_emp == 'S') {
                // si es SQL genera instruccion de modificación
                switch (true) {
                  case Public.value.ndb_emp == 1:
                    ins_sql = ins_sql + iif(Public.value.ndb_emp == 1, 'alter column ', ' modify ') + upper(des_dat) + ' ' + obt_tip(tip_dat) + ' '
                    break
                  case Public.value.ndb_emp == 4:
                    ins_sql = ins_sql + 'alter column ' + upper(des_dat) + ' SET DATA TYPE ' + obt_tip(tip_dat) + ' '
                } // End case 

                let ins_nue = ins_sql
                // 17/FEB/2009
                ins_sql = '  '
                // se quita 'Begin transaction'                    && comienza la trsansaccion

                //      =iif(sqlexec(num_dbs,ins_sql)>0,0,err_sql())   && ejecuta instruccion sql
                if (sw_bin) {
                  ins_sql = 'drop view man_' + nom_arc
                  // si no se han borrado indices
                  if (Public.value.ndb_emp == 4) {
                    // si es postgres borra la vista de mantenimiento
                    ins_sql = 'drop view if exists ' + 'man_' + nom_arc + ' CASCADE; '
                  } // End If 

                    =await SQLExec(ins_sql)

                  // borra vistas de mantenimiento
                  await select('indices')
                  // seleccionamos indices para borrarlos

                  await goto('TOP')

                  // VFP SCAN 
                  while (!eof()) {
                    // borra los indices de la tabla
                    ins_sql = 'drop index ' + nom_arc + '.' + nom_ind                      =await SQLExec(ins_sql)

                    // ejecuta instruccion sql
                    skip()
                  } // End while 

                  sw_bin = false
                } // End If 

                await select('diccionario')

                ins_sql = ins_nue
                // asigna la instruccion de modificación de estructura
                if (!iif(await SQLExec(ins_sql)
                  > 0, true, err_sql())) {
                  // ejecuta instruccion sql
                  let a = ins_sql
                  if (await MessageBox('Continuamos', 4)
                    != 6) {
                    Cancel
                  } // End If 

                } else {

                  ins_sql = 'Commit transaction'
                  // terminamos la transaccion
                } // End If 
                //   =iif(sqlexec(num_dbs,ins_sql)>0,0,err_sql())   && ejecuta instruccion sql

                sw_dat = false
                ins_sql = 'alter table ' + nom_arc + ' '
              } // End If 

            } // End If 

          } // End If 

        } // End If 

      } else {

        // si hay un campo nuevo
        if (position.Left(upper(des_dat), 6) != 'TIMEST') {

          // en Postgres siempre va faltar el campo TIMESTAMP. No lo debe generar
          sw_dat = true
          if (await MessageBox('Agregamos el campo :' + des_dat + ' ' + rTrim(ref_dat), 4)
            == 6) {
            ins_nue = ins_sql
            // 17/FEB/2009
            ins_sql = '  '
            // se quita 'Begin transaction'                    && comienza la trsansaccion

            //      =iif(sqlexec(num_dbs,ins_sql)>0,0,err_sql())   && ejecuta instruccion sql
            if (sw_bin) {
              // si no se han borrado indices
              ins_sql = 'drop view man_' + nom_arc
              if (Public.value.ndb_emp == 4) {
                // si es postgres borra la vista de mantenimiento
                ins_sql = 'drop view if exists ' + 'man_' + nom_arc + ' CASCADE; '
              } // End If 

              if (await SQLExec(ins_sql)
                < 0) {
                // crea trigger de mantenimiento
                a = ins_sql
                err_sql()
              } // End If 
              // cancel

              await select('indices')
              //      =SQLExec(num_dbs,ins_sql)   && borra vistas de mantenimiento
              // seleccionamos indices para borrarlos

              await goto('TOP')

              // VFP SCAN 
              while (!eof()) {
                // borra los indices de la tabla
                ins_sql = 'drop index ' + nom_arc + '.' + nom_ind                  =await SQLExec(ins_sql)

                // ejecuta instruccion sql
                skip()
              } // End while 

              sw_bin = false
            } // End If 

            await select('diccionario')

            ins_sql = ins_nue
            // asigna la instruccion de modificación de estructura
            ins_sql = ins_sql + 'add ' + des_dat + ' ' + obt_tip(tip_dat, true)
            if (!iif(await SQLExec(ins_sql)
              > 0, true, err_sql())) {
              // ejecuta instruccion sql
              return

            } // End If 

          } // End If 

          sw_dat = false
          ins_sql = 'alter table ' + nom_arc + ' '
        } // End If 

      } // End If 

      skip()
    } // End while 

    if (sw_dat && Public.value.sql_emp == 'S') {
      ins_nue = ins_sql
      if (sw_bin) {
        // si no se han borrado indices
        ins_sql = 'drop view man_' + nom_arc
        if (Public.value.ndb_emp == 4) {
          // si es postgres borra la vista de mantenimiento
          ins_sql = 'drop view if exists ' + 'man_' + nom_arc + ' CASCADE; '
        } // End If 

        if (await SQLExec(ins_sql)
          < 0) {
          a = ins_sql
          err_sql()
          // crea trigger de mantenimiento
          cancel
        } // End If 

        await select('indices')
        //=SQLExec(num_dbs,ins_sql)   && borra vistas de mantenimiento
        // seleccionamos indices para borrarlos

        await goto('TOP')

        // VFP SCAN 
        while (!eof()) {
          // borra los indices de la tabla
          ins_sql = 'drop index ' + nom_arc + '.' + nom_ind            =iif(await SQLExec(ins_sql)
            > 0, 0, err_sql())
          // ejecuta instruccion sql
          skip()
        } // End while 

        await select('diccionario')

        sw_bin = false
      } // End If 

      ins_sql = ins_nue
      // asigna la instruccion de modificación de estructura
      a = ins_sql
      if (!iif(await SQLExec(ins_sql)
        > 0, true, err_sql())) {
        // ejecuta instruccion sql
        return

      } // End If 

      if (Public.value.ndb_emp == 2) {
        // Sqlcommit ( Public.value.num_dbs ) 

        await SQLExec("commit work;")

      } // End If 

      sw_dat = false
    } // End If 

    ins_fox = 'alter table ' + nom_arc + ' '
    ins_sql = 'alter table ' + nom_arc + ' '
    for (let i = 1; i < num_ele; i++) {
      // reviza si existen todos los elementos viejos
      // VFP LOCATE For upper(des_dat)=est_vie(i,1)
      let records = await locateFor(` upper(des_dat)=est_vie(i,1)`)

      if (Eof() && await MessageBox('Desapareció el campo :' + est_vie(i, 1) + ' del diccionario de datos.Â¿Borramos el campo?', 4)
        == 6) {
        sw_dat = true
        // SET ORDER TO 1
        ins_sql = ins_sql + iif(Public.value.ndb_emp == 3, ' drop ', ' drop column ') + est_vie(i, 1)
        let ins_bor = ins_sql
        // instrucciomn de borrado de columna
        let num_int = 0

        while (await SQLExec(ins_bor)
          < 0 && num_int < 3) {
          if ((Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3)) {
            // ejecuta instruccion sql
            Aerror(men_err)
            // asignamos al arreglo de errores
            let men = men_err(1, 3)
            let pos = atc("'", men, 2)
            men = position.Left(men, pos - 1)
            pos = atc("'", men, 1)
            men = right(men, len(men) - pos)
            ins_sql = 'alter table ' + nom_arc + ' DROP CONSTRAINT [' + men + '] '
            if (await SQLExec(ins_sql)
              < 0) {
              ins_sql = 'DROP INDEX ' + men + ' ON ' + nom_arc
              if (await SQLExec(ins_sql)
                < 0) {
                err_sql()
                a = ins_sql
              } // End If 

            } // End If 

          } // End If 
          num_int = num_int + 1
        } // End while 

        sw_dat = false
        ins_sql = 'alter table ' + nom_arc + ' '
      } // End If 
      //   Endif

    } // End For; 

    if (sw_dat && Public.value.sql_emp == 'S') {
      ins_nue = ins_sql
      if (sw_bin) {
        // si no se han borrado indices
        await select('indices')
        // seleccionamos indices para borrarlos

        await goto('TOP')

        // VFP SCAN 
        while (!eof()) {
          // borra los indices de la tabla
          m.sum_ind = 1                        switch (true) {
            // reviza si existe el indice
            case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
              // Si es MSSQL7
              ins_sql = "SELECT count(name) as sum_ind FROM sysindexes where name = '" + nom_ind + "'"
              break
            case Public.value.ndb_emp == 2:
              // Si es Firebird
              ins_sql = "select count(RDB$INDEX_NAME) as sum_ind FROM RDB$INDICES WHERE RDB$INDEX_NAME='" + upper(nom_ind) + "'"
              break
            case Public.value.ndb_emp == 4:
              // Si es PostgreSQL
              ins_sql = " select COUNT(*) from pg_indexes  where schemaname = 'public' and indexname = '" + upper(nom_ind) + "'"
          } // End case 
  // and tablename = 'COMEADU'
            =iif(await SQLExec(ins_sql)
            > 0, 0, err_sql())            m = appendM(m, await scatter(m))// scatter 
          // ejecuta instruccion sql
          if (m.sum_ind > 0) {
            switch (true) {
              case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
                // Si es MSSQL7
                ins_sql = 'drop index ' + nom_arc + '.' + nom_ind
                break
              case Public.value.ndb_emp == 2:
                // Si es Firebird
                ins_sql = 'drop index ' + upper(nom_ind)
                break
              case Public.value.ndb_emp == 4:
                // Si es PostgreSQL
                ins_sql = 'drop index ' + upper(nom_ind)
            } // End case 

              =iif(await SQLExec(ins_sql)
              > 0, 0, err_sql())
            // ejecuta instruccion sql
          } // End If 
          ins_sql = 'drop view vi_man_' + nom_arc
          // borramos vista de mantenimiento
          if (Public.value.ndb_emp == 4) {
            // si es postgres borra la vista de mantenimiento
            ins_sql = 'drop view if exists ' + 'man_' + nom_arc + ' CASCADE; '
          } // End If 
            =iif(await SQLExec(ins_sql)
            > 0, 0, err_sql())
          // ejecuta instruccion sql
          if (Public.value.ndb_emp == 2) {
            // Si es Firebird
            // Sqlcommit ( Public.value.num_dbs ) 
            //*******        =iif(sqlexec(num_dbs,'commit')>0,0,err_sql())   && ejecuta instruccion sql

            await SQLExec("commit work;")

          } // End If 

          skip()
        } // End while 

        await select('diccionario')

        sw_bin = false
      } // End If 

      ins_sql = ins_nue
      // asigna la instruccion de modificación de estructura

      //          messagebox(ins_sql)
      //=Iif(SQLExec(num_dbs,ins_sql)>0,.T.,err_sql())   && ejecuta instruccion sql
      if (await SQLExec(ins_sql)
        < 0) {
        a = ins_sql
        err_sql()
        // crea trigger de mantenimiento
        cancel
      } // End If 

      if (Public.value.ndb_emp == 2) {
        // Sqlcommit ( Public.value.num_dbs ) 
        //**           =iif(sqlexec(num_dbs,'commit')>0,0,err_sql())   && ejecuta instruccion sql

        await SQLExec("commit work;")

      } // End If 

      sw_dat = false
    } // End If 

    await select('diccionario')

    releaseUse() // use 

    if (await select('indices')
      > 0) {
      await select('indices')

      releaseUse() // use 

    } // End If 

  } // End If 

  sql_campos = allTrim(sql_campos)
  // 19/May/2014 ****************   generacion de vistas actualizables
  ////////////////////////////////////////////////////////////////////////////////// Verificar en PostGreSQL
  sql_campos = position.Left(sql_campos, len(sql_campos) - 1)
  let nom_tab = lower(allTrim(nom_tab))
  let are_tra = await select()

  if (Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3) {
    // Set Textmerge On 

    let variable = `IF EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS\
WHERE TABLE_NAME = 'man_${nom_tab}' )\
	    SELECT 'EXISTE' as resultado\
ELSE\
SELECT 'NO EXISTE' as resultado\
	`
    // EndText

  } // End If 

  if (Public.value.ndb_emp == 4) {
    // PostgreSql
    // Set Textmerge On 

    let variable = `select case\
WHEN  EXISTS(select viewname from pg_views where viewname= 'man_${nom_tab}' ) THEN 'EXISTE'\
else 'NO EXISTE'\
END\
as resultado ;\
	`
    // EndText

  } // End If 

  let val_remplazo = sql_campos
  //IF PARAMETERS()=3  && genera vista de mantenimiento
  //   sql_campos=sql_campos+',TIMESTAMP'
  //!//    DO CASE
  //!//       case m.ndb_emp=1 OR m.ndb_emp=2  && MSSQL o Sybase
  //!//           sql_campos=sql_campos+',TIMESTAMP'
  //!//       case m.ndb_emp=4  && PostgreSql
  //!//           sql_campos=sql_campos+',XMIN AS TIMESTAMP'
  //!//    ENDCASE
  //+' WITH CHECK OPTION'  &&+' where f_seg_tab('+nom_tab+')>0     '
  //!// SELECT sql_scr,pos_scr,rem_scr from comescript WHERE nom_scr='F_VAL_VIS_'+UPPER(nom_tab)  INTO cursor fun_scr
  //!// If Reccount()>0
  //!//  Scatter Memvar Memo
  //!//  Use
  //!//  If (m.ndb_emp=1 Or  m.ndb_emp=3) And Len(Alltrim(m.sql_scr))>1 && MSSL
  //!//   ins_sql="DELETE FUNCTION "+'F_VAL_VIS_'+nom_tab
  //!//   SQLExec(num_dbs,ins_sql) && borra la funcion
  //!//   SQLExec(num_dbs,m.sql_scr) && crea la funcion
  //!//  Endif
  //!//  If (m.ndb_emp=4) And Len(Alltrim(m.pos_scr))>1 && POSTGRESQL
  //!//   If Len(Alltrim(m.rem_scr))>0  && hay remplazos
  //!//    pos=At('>>',m.rem_scr)
  //!//    Do While pos>0
  //!//     var_rem=Left(m.rem_scr,pos-1)
  //!//     m.rem_scr=Right(m.rem_scr,Len(m.rem_scr)-pos-1)
  //!//     pos=At('<<',m.rem_scr)
  //!//     por_var=Left(m.rem_scr,pos-1)
  //!//     m.rem_scr=Right(m.rem_scr,Len(m.rem_scr)-pos-1)
  //!//     m.pos_scr=Strtran(N.pos_scr,var_rem,por_var)
  //!//     pos=At('>>',m.rem_scr)
  //!//    Enddo
  //!//   Endif
  //!//   SQLExec(num_dbs,m.pos_scr) && crea la funcion
  //!//  Endif
  //!// Endif
  // sql_view=sql_view+Upper(sql_campos)+') as select '+Iif(m.ndb_emp=4,Strtran(sql_campos,'TIMESTAMP','xmin'),sql_campos)+' from '+nom_tab+' '
  // remplazo de variables en sql_campos para valores iniciales
  sql_view = sql_view + upper(sql_campos) + ') as select ' + iif(Public.value.ndb_emp == 4, strtran(sql_campos, 'TIMESTAMP', '(xmin::text)::integer'), sql_campos) + ' from ' + nom_tab + ' '
  // Si es postgres genera su TinmeStamnp
  if (upper(nom_tab) == 'COMEFRX' && Public.value.ndb_emp == 4) {
    sql_view = strtran(sql_view, '(xmin::text)::integer', 'NULL::bytea')
  } // End If 

  sql_view = sql_view + iif(ini_seg && len(m.vis_tab) > 0, m.vis_tab, '')
  //   +IIF(nom_tab='comefrx',' WITH CHECK OPTION','')
  // Genera la condicion where de la vista de mantenimiento
  if (upper(nom_tab) == 'COMEUSU') {
    let val_pas = ''
    if (ini_seg) {
      // Set Textmerge On 

      let variable = `case\
when dbo.f_key_usu()>1 then '************'\
else pas_usu\
end\
		`
      // EndText
      sql_view = strtran(sql_view, 'PAS_USU', val_pas, 2, 1)
    } // End If 

  } // End If 

  if (Public.value.ndb_emp == 4) {
    // PostgreSql quita el dbo
    sql_view = strtran(sql_view, 'dbo.', '')
  } // End If 
  //      cancel

  if (await SQLExec(ver_view)
    > 0) {
    // verifica si existe la vista
    await select('sqlresult')

    m = appendM(m, await scatter(m))// scatter 


    //      IF  m.ndb_emp=4  && PostgreSql tenemos que borrar el temporal donde esta el resultado
    //          =iif(sqlexec(num_dbs,'drop table datos;')>0,0,err_sql())
    //      endif
    if (m.resultado == 'EXISTE') {
      if (Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3) {
        // MSSQL
        ins_sql = 'drop trigger T_man_' + nom_tab + iif(Public.value.ndb_emp != 4, '', ' on man_' + nom_tab)
        // si existe la vista de mantenimiento la borra
        await SQLExec(ins_sql)

        // ejecuta instruccion sql
      } // End If 

      ins_sql = 'drop view ' + 'man_' + nom_tab
      // si existe la vista de mantenimiento la borra
      if (Public.value.ndb_emp == 4) {
        // PostgreSql aumenta CASACADE
        ins_sql = ins_sql + ' CASCADE'
      } // End If 

      await SQLExec(ins_sql)

      // ejecuta instruccion sql
    } // End If 

      =iif(await SQLExec(sql_view)
      > 0, 0, err_sql())
    // ejecuta instruccion sql
    let sql_update = 'SET '
    //  IF m.ndb_emp=4
    //     ins_sql=STRTRAN(ins_sql,'dbo.','') && quitamos el dbo
    //     ins_sql=STRTRAN(ins_sql,'getdate()','CURRENT_TIMESTAMP') && substituimos la funcion
    //!//  sql_values='inserted.'+Strtran(sql_campos,',', ',inserted.')
    //!//  sql_values=Strtran(sql_values,',inserted.USU_USU','')
    //!//  sql_values=Strtran(sql_values,'inserted.USU_USU,','')
    //!//  sql_values=Strtran(sql_values,',inserted.TIE_UAC','')
    //!//  sql_values=Strtran(sql_values,',inserted.TIMESTAMP','')
    //!//  sql_values=Strtran(sql_values,',inserted.KEY_PRI','')
    sql_campos = strtran(sql_campos, ',TIE_UAC', '')
    sql_campos = strtran(sql_campos, ',USU_USU', '')
    sql_campos = strtran(sql_campos, ',KEY_PRI', '')
    sql_campos = strtran(sql_campos, ',TIMESTAMP', '')
    sql_campos = strtran(sql_campos, ',USU_CRE', '')
    sql_campos = strtran(sql_campos, ',TIE_CRE', '')
    sql_campos = strtran(sql_campos, ',,', ',')
    sql_campos = strtran(sql_campos, 'TIE_UAC,', '')
    sql_campos = strtran(sql_campos, 'USU_USU,', '')
    sql_campos = strtran(sql_campos, 'KEY_PRI,', '')
    sql_campos = strtran(sql_campos, 'TIMESTAMP,', '')
    sql_campos = strtran(sql_campos, 'USU_CRE,', '')
    sql_campos = strtran(sql_campos, 'TIE_CRE,', '')
    sql_campos = strtran(sql_campos, ',,', ',')
    sql_campos = strtran(sql_campos, ',tie_uac', '')
    sql_campos = strtran(sql_campos, ',usu_usu', '')
    sql_campos = strtran(sql_campos, ',key_pri', '')
    sql_campos = strtran(sql_campos, ',timestamp', '')
    sql_campos = strtran(sql_campos, ',usu_cre', '')
    sql_campos = strtran(sql_campos, ',tie_cre', '')
    sql_campos = strtran(sql_campos, ',,', ',')
    let sql_valores = sql_campos
    pos = at(',', sql_valores)

    while (pos > 0) {
      let campo = position.Left(sql_valores, pos - 1)        sql_update = sql_update + campo + '=inserted.' + campo + ','        sql_valores = right(sql_valores, len(sql_valores) - pos)        pos = at(',', sql_valores)
    } // End while 

    campo = sql_valores
    sql_update = sql_update + campo + '=inserted.' + campo + ','
    let val_tri = ''
    //////////////////////////////////////////////////////////////////////
    // Genera la condicion de grabado si es que tiene una funcion de validacion
    if (len(allTrim(m.tri_msq)) > 0 && Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3) {
      // si es MSSQL
      let variable = `if @sw_tri>1  -- Es una actualizacion o borrado\
begin\
${tri_msq}\
begin\
	                 raiserror('No se tiene privilegios para actualizar el registro',16,1)\
	                 ROLLBACK TRAN\
	                 return\
	              END\
	          end\
		`
      // EndText

    } // End If 

    if (len(allTrim(m.tri_pos)) > 0 && Public.value.ndb_emp == 4) {
      // si es postgre
      let variable = `IF (TG_OP='UPDATE' OR TG_OP='DELETE)' THEN  -- Es una actualizacion o borrado\
<tri_pos} THEN\
	         RAISE EXCEPTION 'No se tiene privilegios para actualizar el registro';\
RETURN NULL;\
	           END IF;\
	     END IF;\
		`
      // EndText

    } // End If 


    //////////////////////////////////////////////////////////////////
    ////////////////////////  MSSQL ////////////////////////
    //////////////////////////////////////////////////////////////////
    if (Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3) {
      // si es MSSQL
      let ins_set = ' '
      let set_sql = sql_campos
      let pos_cam = at(',', set_sql)
      let f_key_usu = 'dbo.f_key_usu()'
      //  f_key_usu=Iif(ini_seg,'dbo.f_key_usu()','0')

      while (pos_cam > 0) {
        campo = position.Left(set_sql, pos_cam - 1)          let variable = `			-- Actualizacion campo por campo\
if update(${campo})\
UPDATE ${nom_tab} SET ${campo}=inserted.${campo},USU_USU=@KEY_USU,TIE_UAC=@TIE_UAC from ${nom_tab} join inserted on ${nom_tab}.key_pri=inserted.key_pri\
			`
        // EndText
        ins_set = ins_set + ins_sql          set_sql = right(set_sql, len(set_sql) - pos_cam)          pos_cam = at(',', set_sql)
      } // End while 

      campo = set_sql
      let variable = `		\
if update(${campo})\
UPDATE ${nom_tab} SET ${campo}=inserted.${campo},USU_USU=@KEY_USU,TIE_UAC=@TIE_UAC  from ${nom_tab} join inserted on ${nom_tab}.key_pri=inserted.key_pri\
--  UPDATE ${nom_tab}  set USU_USU=${f_key_usu},TIE_UAC=GETDATE() WHERE key_pri=@key_pri\
		`
      // EndText
      ins_set = ins_set + ins_sql
      // Set Textmerge On 
      //!//   CAM_CRE='USU_USU ,TIE_UAC  ,USU_CRE,TIE_CRE'
      //!//   VAL_CRE='@key_usu,@TIE_UAC ,@KEY_USU,@TIE_UAC'
      //!//
      //!//
      //!//   If At('USU_CRE',sql_campos)>0 OR At('usu_cre',sql_campos)>0
      //!//    sql_campos=Strtran(sql_campos,',usu_cre','')
      //!//    sql_campos=Strtran(sql_campos,',tie_cre','')
      //!//
      //!//    sql_campos=Strtran(sql_campos,',USU_CRE','')
      //!//    sql_campos=Strtran(sql_campos,',TIE_CRE','')
      //!// //  sql_campos=STRTRAN(sql_campos,',,',',')
      //!//    CAM_CRE=',USU_CRE,TIE_CRE'
      //!//    VAL_CRE=',@KEY_USU,@FECHA'
      //!//   Endif

      let variable = `	       create trigger T_man_${nom_tab}\
	       on man_${nom_tab}\
	       instead of insert,delete,update\
	       as\
	         DECLARE @sw_tri as int\
	         DECLARE @KEY_PRI AS INT\
	         DECLARE @KEY_USU as int\
	         DECLARE @TIE_UAC as datetime\
	\
	\
	         SET @KEY_USU=dbo.f_key_usu()\
	         SET @TIE_UAC=GETDATE()\
	\
	\
	         SET @sw_tri=0\
	         IF EXISTS(SELECT * FROM DELETED)\
	            SET @sw_tri=@sw_tri+1\
	        IF EXISTS(SELECT * FROM INSERTED)\
	            SET @sw_tri=@sw_tri+2\
${val_tri}  -- Funcion de validacion de seguridad del trigger\
	        IF @sw_tri=1    --  deleted\
	           DELETE FROM ${nom_tab} where key_pri=(select deleted.key_pri FROM deleted)\
	        IF @sw_tri=2   -- inserted\
	           insert into ${nom_tab} (${sql_campos},USU_USU ,TIE_UAC  ,USU_CRE ,TIE_CRE )\
	                      SELECT        ${sql_campos},@key_usu,@TIE_UAC ,@KEY_USU,@TIE_UAC FROM inserted\
	        IF @sw_tri=3   -- updated\
	           begin\
	           	  SELECT @KEY_PRI=KEY_PRI FROM inserted\
	              IF (select inserted.TIMESTAMP from inserted)<>(select  ${nom_tab}.TIMESTAMP from ${nom_tab} WHERE ${nom_tab}.KEY_PRI=@KEY_PRI)\
	                 begin\
	                   raiserror('Registro actualizado por otro usuario',16,1)\
	                   ROLLBACK TRAN\
	                   return\
	                  end\
				 ${ins_set}\
	           end\
		`
      // EndText

    } // End If 


    //////////////////////////////////////////////////////////////////////
    //////////////////// Postgres //////////////////////////
    ////////////////////////////////////////////////////////////////////
    if (Public.value.ndb_emp == 4) {
      // si es ppotgres
      let sql_campos_pos = strtran('NEW.' + sql_campos, ',', ',NEW.')
      sql_update = strtran(sql_update, 'inserted', 'NEW')
      f_key_usu = 'f_key_usu()'
      //>>>>>>>  f_key_usu=Iif(ini_seg,'f_key_usu()','0')
      if (at('USU_CRE', sql_campos) > 0) {
        sql_campos_pos = strtran(sql_campos_pos, 'NEW.USU_CRE', 'f_key_usu()')
        sql_campos_pos = strtran(sql_campos_pos, 'NEW.TIE_CRE', 'current_timestamp')
        a = sql_update
        sql_update = strtran(sql_update, ',TIE_CRE=NEW.TIE_CRE', '')
        sql_update = strtran(sql_update, ',USU_CRE=NEW.USU_CRE', '')
      } // End If 

      let variable = `	       CREATE OR REPLACE FUNCTION public.T_man_${nom_tab}() RETURNS TRIGGER AS $$\
DECLARE M_KEY_PRI  INT;\
begin\
${val_tri}  -- Funcion de validacion de seguridad del trigger\
IF TG_OP='DELETE' THEN   --  deleted\
		           DELETE FROM ${nom_tab} where key_pri=OLD.key_pri ;\
RETURN OLD;\
END IF ;\
IF TG_OP='INSERT' THEN   -- inserted\
insert into ${nom_tab} (${sql_campos},USU_USU,TIE_UAC)\
SELECT  ${sql_campos_pos},${F_KEY_USU},current_timestamp ;\
RETURN NEW;\
END IF;\
		        IF TG_OP='UPDATE' THEN   -- updated\
		           --Tablas diferentes a COMEFRX\
		           IF NEW.TIMESTAMP<>(select (${nom_tab}.xmin::text)::integer   from ${nom_tab} WHERE ${nom_tab}.KEY_PRI=NEW.KEY_PRI) then\
		               RAISE EXCEPTION 'Registro actualizado por otro usuario';\
RETURN NULL;\
	               END IF;\
--Fin Tablas diferentes a COMEFRX\
		           UPDATE ${nom_tab} ${sql_update}USU_USU=${F_KEY_USU},TIE_UAC=current_timestamp WHERE ${nom_tab}.key_pri=NEW.key_pri ;\
return NEW;\
		        END IF;\
	         end ;\
$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER ;\
DROP TRIGGER  IF EXISTS  TRIGGER_man_${nom_tab} ON man_${nom_tab};\
CREATE TRIGGER  TRIGGER_man_${nom_tab}  INSTEAD OF INSERT OR UPDATE  OR DELETE ON  man_${nom_tab} FOR EACH ROW EXECUTE PROCEDURE T_man_${nom_tab}();\
		`
      // EndText

    } // End If 

    if (nom_tab == 'comefrx') {
      ins_sql = strtran(ins_sql, '--Tablas diferentes a COMEFRX', '/* Se quita en tabla COMFRX solamente')
      ins_sql = strtran(ins_sql, '--Fin Tablas diferentes a COMEFRX', '*/')
    } // End If 

    a = ins_sql
    if (await SQLExec(ins_sql)
      < 0) {
      err_sql()
      // crea trigger de mantenimiento
      a = ins_sql
    } // End If 

    Public.value.nru_pge = Nvl(Public.value.nru_pge, 'siavcom')
    if (type('m.nru_pge') == 'L') {
      Public.value.nru_pge = 'siavcom'
    } // End If 

    if (Public.value.ndb_emp == 4) {
      // si es postgres
      ins_sql = 'REVOKE ALL ON table ' + m.nom_arc + ' FROM public ;'
  // quitamos los permisos de las tablas
        =iif(await SQLExec(ins_sql)
        > 0, true, err_sql())
      // ejecuta instruccion sql
      ins_sql = 'REVOKE ALL ON table ' + m.nom_arc + ' FROM ' + Public.value.nru_pge + ';'
  // quitamos los permisos de las tablas
        =iif(await SQLExec(ins_sql)
        > 0, true, err_sql())
      // ejecuta instruccion sql
    } // End If 

    if (allTrim(m.nom_arc) != 'COMEUSU' && allTrim(m.nom_arc) != 'COMEUSU' && allTrim(m.nom_arc) != 'COMEGRU' && allTrim(m.nom_arc) != 'COMESEG' && allTrim(m.nom_arc) != 'COMEFRX' && allTrim(m.nom_arc) != 'COMEPRG' && M.nom_tab != 'COMECER' && M.nom_tab != 'COMEPGE' && M.nom_tab != 'COMETDO') {
      ins_sql = 'grant select,insert,delete,update on man_' + m.nom_arc + ' to ' + Public.value.nru_pge
  // antes SIAVCOM
        =iif(await SQLExec(ins_sql)
        //  ins_sql=Iif(m.ndb_emp=4,Strtran(ins_sql,'dbo.',''),ins_sql)
        > 0, true, err_sql())
      // ejecuta instruccion sql
    } else {

      ins_sql = 'grant SELECT on man_' + m.nom_arc + ' to ' + Public.value.nru_pge
  // antesSIAVCOM'
        =iif(await SQLExec(ins_sql)
        //  ins_sql=Iif(m.ndb_emp=4,Strtran(ins_sql,'dbo.',''),'')
        > 0, true, err_sql())
      // ejecuta instruccion sql
      if (m.nom_arc == 'COMEUSU') {
        ins_sql = 'grant UPDATE on man_comeusu to ' + Public.value.nru_pge
  // antesSIAVCOM'
          =iif(await SQLExec(ins_sql)
          > 0, true, err_sql())
        // ejecuta instruccion sql
        ins_sql = ' DENY UPDATE ON dbo.MAN_COMEUSU (USU_USU,LOG_USU,NOM_USU,PAS_USU,GRU_GRU,ALM_TDA,SUC_PGE,DPM_USU,PMV_USU,ALM_USU,LIC_USU)  to ' + Public.value.nru_pge
        // ins_sql=' revoke update(USU_USU,LOG_USU,NOM_USU,PAS_USU,GRU_GRU,ALM_TDA,SUC_PGE,DPM_USU,PMV_USU) on man_comeusu  to '+M.nru_pge  && antes SIAVCOM'
        // antes SIAVCOM'
        if (Public.value.ndb_emp == 4) {
          // si es ppotgres
          ins_sql = ' revoke update(USU_USU,LOG_USU,NOM_USU,PAS_USU,GRU_GRU,ALM_TDA,SUC_PGE,DPM_USU,PMV_USU,ALM_USU,LIC_USU) on man_comeusu  from group  ' + Public.value.nru_pge
          // antes SIAVCOM'
        } // End If 

          =iif(await SQLExec(ins_sql)
          > 0, true, err_sql())
        // ejecuta instruccion sql
      } // End If 

    } // End If 

  } else {
  //       sql_view=' grant insert,SELECT,delete,update on '+IIF(m.ndb_emp=1 or m.ndb_emp=3,' dbo.','public.')+'man_'+LOWER(nom_arc)+' to SIAVCOM'
  //       =iif(sqlexec(num_dbs,sql_view)>0,0,err_sql())   && ejecuta instruccion sql
      
      =err_sql()
    // ejecuta instruccion sql
  } // End If 

  await select(are_tra)
  //endif

  let ind_arc = position.Left(nom_arc, 4) + 'ind'
  //!// If Select('COMEDAT')>0
  //!//  Select comedat
  //!// Else
  //!//  Select 0
  //!//  Use (dic_dat)               && abre el diccionario de datos
  //!// Endif
  //!// Set Filter To
  // define el diccionario de datos
  let vis_arc = position.Left(nom_arc, 4) + 'vis'
  // define el archivo de vistas
  ind_arc = 'comeind'
  // define el diccionario de datos
  vis_arc = 'comevis'
  // define el archivo de vistas
  ins_sql = 'Select * From comeind Where nom_tab=Upper(?nom_arc) Order By num_ind'
  await select('0')

  if (await SQLExec(ins_sql, 'indices')
    < 0) {
    // si esta el diccionario de datos en la base de datos
    let res = await localAlaSql("INSERT INTO indices select * From ( ind_arc ) Where dbf_ind = Upper ( nom_arc ) Order By num_ind")

    await select(ind_arc)

    releaseUse() // use 

  } // End If 

  await select('indices')
  //Select // From (ind_arc) Where dbf_ind=Upper(nom_arc) Order By num_ind Into Cursor indices

  // VFP SCAN 
  while (!eof()) {
    // lee indice por indice
    MessageBox('Generando Indices del archivo:  ' + nom_arc + ' Indice: ' + nom_ind)
    m = appendM(m, await scatter(m))// scatter 
    m.exp_ind = allTrim(m.exp_ind)      m.nom_ind = allTrim(m.nom_ind)      if (sw_bin) {
      // si no se han borrado indices
      m.sum_ind = 1
      // reviza si existe el indice
      switch (true) {
        case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
          // Si es MSSQL7
          ins_sql = "SELECT count(name) as sum_ind FROM sysindexes WHERE name = '" + nom_ind + "'"
          break
        case Public.value.ndb_emp == 2:
          // Si es Firebird
          ins_sql = "select count(RDB$INDEX_NAME) as sum_ind FROM RDB$INDICES WHERE RDB$INDEX_NAME='" + upper(nom_ind) + "'"
          break
        case Public.value.ndb_emp == 4:
          // PostgreSQL
          ins_sql = "SELECT CAST(count(indexname) as int) as sum_ind FROM pg_indexes where indexname='" + lower(nom_ind) + "' and tablename='" + lower(nom_arc) + "'"
      } // End case 

        =iif(await SQLExec(ins_sql)
        > 0, 0, err_sql())
      // ejecuta instruccion sql
      m = appendM(m, await scatter(m))// scatter 

      if (Public.value.ndb_emp == 2) {
        // Si es Firebird
        // Sqlcommit ( Public.value.num_dbs ) 
        //***           =iif(sqlexec(num_dbs,'commit')>0,0,err_sql())   && ejecuta instruccion sql

        await SQLExec("commit work;")

      } // End If 

      if (m.sum_ind > 0) {
        switch (true) {
          case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
            // Si es MSSQL7
            ins_sql = 'drop index ' + nom_arc + '.' + nom_ind
            break
          case Public.value.ndb_emp == 2:
            // Si es Firebird
            ins_sql = 'drop index ' + upper(nom_ind)
            break
          case Public.value.ndb_emp == 4:
            // Si es Postgres
            ins_sql = 'drop index ' + lower(nom_ind)
        } // End case 

          =iif(await SQLExec(ins_sql)
          > 0, 0, err_sql())
        // ejecuta instruccion sql
        if (Public.value.ndb_emp == 2) {
          // Si es Firebird
          // Sqlcommit ( Public.value.num_dbs ) 
          //***             =iif(sqlexec(num_dbs,'commit')>0,0,err_sql())   && ejecuta instruccion sql

          await SQLExec("commit work;")

        } // End If 

      } // End If 
      // en la siguiente parte de la programacion hace esto
      //          if m.num_ind=1 and m.ndb_emp=1     && Si es MSSQL7 && si es el indice principal
      //             ins_sql='drop index '+nom_arc+'.KEY_PRI'
      //             =iif(sqlexec(num_dbs,ins_sql)>0,0,err_sql())   && ejecuta instruccion sql
      //          endif

    } // End If 
    if (m.num_ind == 1) {
      // si es el indice principal
      m.sum_ind = 0
      // reviza si existe el indice
      switch (true) {
        case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
          // Si es MSSQL7
          ins_sql = "SELECT count(name) as sum_ind FROM sysindexes WHERE name = 'KEY_PRI'"
          break
        case Public.value.ndb_emp == 2:
          // Si es Firebird
          ins_sql = "select count(RDB$INDEX_NAME) as sum_ind FROM RDB$INDICES WHERE RDB$INDEX_NAME='KEY_PRI" + nom_arc + "'"
          break
        case Public.value.ndb_emp == 4:
          // PostgreSQL
          ins_sql = "SELECT CAST(count(indexname) as int) as sum_ind FROM pg_indexes where indexname='" + lower(nom_arc) + "_key_pri' and tablename='" + lower(nom_arc) + "'"
      } // End case 

        =iif(await SQLExec(ins_sql)
        > 0, 0, err_sql())
      // ejecuta instruccion sql
      m = appendM(m, await scatter(m))// scatter 

      if (Public.value.ndb_emp == 2) {
        // Si es Firebird
        // Sqlcommit ( Public.value.num_dbs ) 
        //***           =iif(sqlexec(num_dbs,'commit')>0,0,err_sql())   && ejecuta instruccion sql

        await SQLExec("commit work;")

      } // End If 

      if (m.sum_ind > 0) {
        // si existen indices los borra (En MSSQL el resultado es de muchos indices , ya que
        switch (true) {
          // cada KEY_PRI no es unico como en firebird)
          case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
            // Si es MSSQL
            ins_sql = 'drop index ' + nom_arc + '.KEY_PRI'
            break
          case Public.value.ndb_emp == 2:
            // Si es Firebird
            ins_sql = 'drop index KEY_PRI' + upper(nom_arc)
            break
          case Public.value.ndb_emp == 4:
            // Si es Firebird
            ins_sql = 'alter table  ' + lower(nom_arc) + ' drop CONSTRAINT ' + lower(nom_arc) + '_key_pri'
        } // End case 

          =await SQLExec(ins_sql)

        // ejecuta instruccion sql
        if (Public.value.ndb_emp == 2) {
          // Si es Firebird
          // Sqlcommit ( Public.value.num_dbs ) 
          //***            =iif(sqlexec(num_dbs,'commit')>0,0,err_sql())   && ejecuta instruccion sql

          await SQLExec("commit work;")

        } // End If 

      } // End If 

      switch (true) {
        case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
          // Si es MSSQL
          ins_sql = 'create unique CLUSTERED index KEY_PRI  on ' + nom_arc + ' (KEY_PRI) '
          break
        case Public.value.ndb_emp == 2:
          // Si es Firebird
          ins_sql = 'create unique index KEY_PRI' + nom_arc + ' on ' + nom_arc + ' (KEY_PRI) '
          break
        case Public.value.ndb_emp == 4:
          // Si es  Postgres
          ins_sql = 'alter table ' + lower(nom_arc) + ' ADD CONSTRAINT ' + lower(nom_arc) + '_key_pri primary key(key_pri) '
      } // End case 

        =iif(await SQLExec(ins_sql)
        > 0, 0, err_sql())
      // genera el indice KEY_PRI
      if (Public.value.ndb_emp == 2) {
        // Si es Firebird
        // Sqlcommit ( Public.value.num_dbs ) 
        //***          =iif(sqlexec(num_dbs,'commit')>0,0,err_sql())   && ejecuta instruccion sql

        await SQLExec("commit work;")

      } // End If 

      ins_sql = 'create unique index ' + m.nom_ind + ' on ' + nom_arc + ' (' + m.exp_ind + ') '
        =iif(await SQLExec(ins_sql)
        //       IF   m.ndb_emp=4     && Si es  Postgres
        //       endif
        > 0, 0, err_sql())
      // genera el indice candidato
    } else {

      // with fillfactor=75
      ins_sql = 'create index ' + nom_ind + ' on ' + nom_arc + ' (' + m.exp_ind + ') '
        =iif(await SQLExec(ins_sql)
        > 0, 0, err_sql())
      // genera demas indices
    } // End If 
    if (Public.value.ndb_emp == 2) {
      // Si es Firebird
      // Sqlcommit ( Public.value.num_dbs ) 
      //***        =iif(sqlexec(num_dbs,'commit')>0,0,err_sql())   && ejecuta instruccion sql

      await SQLExec("commit work;")

    } // End If 
    await select('indices')
    // ----------------

    skip()
  } // End while 

  releaseUse() // use 

  if (await select('comedat')
    > 1) {
    await select('comedat')
    // cierra el diccionario de datos

    releaseUse() // use 

  } // End If 

  // Set Safety On 
  //  on error do errores                    && el manejo en caso de errores

  return

}   // Fin Procedure
// --------------< Obtiene tipo de sql  >-------

export async function obt_tip(tip_dat: string, sw_nue: boolean | undefined) {
  let m = {}   // inicializamos m
  if (Parameters() == 1) {
    let sw_nue = false
  } // End If 

  switch (true) {
    case tip_dat == 'I':
      // Asigna el tipo
      // Entero
      switch (true) {
        case Public.value.ndb_emp == 1:
          // Si es MSSQL
          switch (true) {
            case lon_dat == 1:
              let tip_sql = ' TINYINT ' + iif(sw_nue, ' DEFAULT 0 ', ' ')
              break
            case lon_dat == 2:
              tip_sql = ' SMALLINT ' + iif(sw_nue, ' DEFAULT 0 ', ' ')
              break
            case lon_dat == 4:
              tip_sql = ' INT ' + iif(sw_nue, ' DEFAULT 0 ', ' ')
          } // End case 

          break
        case Public.value.ndb_emp == 3:
          // Si es sybase
          switch (true) {
            case lon_dat == 1:
              tip_sql = ' TINYINT '
              break
            case lon_dat == 2:
              tip_sql = ' SMALLINT '
              break
            case lon_dat == 4:
              tip_sql = ' INT '
          } // End case 

          break
        case Public.value.ndb_emp == 4:
          // Si es PostgreSQL
          switch (true) {
            case lon_dat == 1:
              tip_sql = ' SMALLINT '
              break
            case lon_dat == 2:
              tip_sql = ' SMALLINT '
              break
            case lon_dat == 4:
              tip_sql = ' INTEGER '
              break
            case lon_dat == 4:
              tip_sql = ' BIGINT '
          } // End case 

          break
        case Public.value.ndb_emp == 2:
          // Si es Firebird
          if (lon_dat <= 2) {
            tip_sql = ' INT '
          } else {

            tip_sql = ' BIGINT '
          } // End If 

      } // End case 

      break
    case tip_dat == 'N' && (Public.value.ndb_emp == 1 || Public.value.ndb_emp == 4):
      // Numerico
      tip_sql = ' NUMERIC(' + str(lon_dat, 3) + ',' + str(dec_dat, 2) + ') ' + iif(sw_nue, ' DEFAULT 0 ', ' ')
      break
    case tip_dat == 'N' && Public.value.ndb_emp == 3:
      // Numerico Sybase
      tip_sql = ' NUMERIC(' + str(lon_dat, 3) + ',' + str(dec_dat, 2) + ') '
      break
    case tip_dat == 'D' || tip_dat == 'T':
      // Fecha
      switch (true) {
        case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
          tip_sql = ' DATETIME  null '
          break
        case Public.value.ndb_emp == 2:
          tip_sql = ' DATE '
          break
        case Public.value.ndb_emp == 4:
          tip_sql = 'TIMESTAMP(3)'
      } // End case 

      break
    case tip_dat == 'C' && Public.value.ndb_emp == 1:
      // MSSQL
      tip_sql = ' Char(' + str(lon_dat, 4) + ')  ' + iif(sw_nue, "  COLLATE Modern_Spanish_CI_AS DEFAULT '' ", ' ')
      //  COLLATE Modern_Spanish_CI_AS
      break
    case tip_dat == 'C' && (Public.value.ndb_emp == 3 || Public.value.ndb_emp == 4):
      // Sybase
      tip_sql = ' Char(' + str(lon_dat, 4) + ')  ' + iif(sw_nue, '  null  ', ' ')
      //  COLLATE Modern_Spanish_CI_AS
      break
    case tip_dat == 'V' && Public.value.ndb_emp == 1:
      // MSSQL
      if (lon_dat > 0) {
        tip_sql = ' VarChar(' + str(lon_dat, 4) + ')  ' + iif(sw_nue, "  COLLATE Modern_Spanish_CI_AS DEFAULT '' ", ' ')
        //  COLLATE Modern_Spanish_CI_AS
      } else {

        tip_sql = ' VarChar(max)  ' + iif(sw_nue, "  COLLATE Modern_Spanish_CI_AS DEFAULT '' ", ' ')
        //  COLLATE Modern_Spanish_CI_AS
      } // End If 

      break
    case tip_dat == 'V' && (Public.value.ndb_emp == 4):
      // Postgre
      if (lon_dat > 0) {
        tip_sql = ' VarChar(' + str(lon_dat, 4) + ')  ' + iif(sw_nue, '  null  ', ' ')
        //  COLLATE Modern_Spanish_CI_AS
      } else {

        tip_sql = ' Text  ' + iif(sw_nue, '  null  ', ' ')
        //  COLLATE Modern_Spanish_CI_AS
      } // End If 

      break
    case tip_dat == 'L':
      // Logico
      switch (true) {
        case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
          tip_sql = ' BIT '
          break
        case Public.value.ndb_emp == 2:
          tip_sql = ' SMALLINT '
          break
        case Public.value.ndb_emp == 4:
          tip_sql = ' BOOL '
      } // End case 

      break
    case tip_dat == 'M':
      // Memo
      switch (true) {
        case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3 || Public.value.ndb_emp == 4:
          // Si es MSSQL
          tip_sql = ' TEXT '
          break
        case Public.value.ndb_emp == 2:
          // Si es Firebird
          tip_sql = ' VARCHAR (2048)'
      } // End case 

      break
    case tip_dat == 'X':
      // Xml
      switch (true) {
        case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3 || Public.value.ndb_emp == 4:
          // Si es MSSQL
          tip_sql = ' XML null '
          break
        case Public.value.ndb_emp == 2:
          // Si es Firebird
          tip_sql = ' VARCHAR (2048)'
          break
        case Public.value.ndb_emp == 3:
          // Si es Firebird
          tip_sql = ' TEXT '
      } // End case 

      break
    case tip_dat == 'G':
      // Imagen
      switch (true) {
        case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
          // si es MSSQL
          tip_sql = ' IMAGE '
          break
        case Public.value.ndb_emp == 2:
          // si es Firebird 6
          tip_sql = ' BLOB SUB_TYPE 0 SEGMENT SIZE 4096'
          break
        case Public.value.ndb_emp == 4:
          // si es PosgreSQL
          tip_sql = ' BYTEA '
      } // End case 

      break
    case tip_dat == 'B':
      // Var Binary
      if (Public.value.ndb_emp == 4) {
        // si es PosgreSQL
        tip_sql = 'BYTEA'
      } else {

        if (lon_dat == 9999) {
          tip_sql = ' VARBINARY(max) null '
        } else {

          tip_sql = ' VARBINARY(' + str(lon_dat, 4) + ') null '
        } // End If 

      } // End If 

  } // End case 

  return tip_sql

}   // Fin Procedure
// --------------< Crea una tabla en SQL Server >-----------------------
// Este procedimiento creara una tabla nueva en una base de datos SQL
// ------------------------------------------------------------------------

export async function cre_tab(tabla: string, arc_cre: undefined) {
  let m = {}   // inicializamos m
  let no_par = Parameters()
  let dic_dat = position.Left(tabla, 4) + 'dat'
  // seleccciona los datos del diccionario
  let ins_sql = "Select * From comedat Where nom_tab=Upper(?tabla) " + iif(Public.value.ndb_emp == 4, " and Upper(des_dat)<>'TIMESTAMP'", '') + "order By con_dat"
  if (await SQLExec(ins_sql, 'dic_tmp')
    < 0) {
    let res = await localAlaSql("INSERT INTO dic_tmp select * From ( dic_dat ) Where position.Left ( arc_dat , 3 ) = Upper ( Right ( tabla , 3 ) ) AND Right ( arc_dat , 3 ) != '000' AND des_dat != 'Borrado' AND iif ( Public.value.ndb_emp = 4 , Upper ( des_dat ) != 'TIMESTAMP' , true ) order By arc_dat Readwrite")

  } // End If 

  ins_sql = ''
  if (Public.value.ndb_emp == 2 && no_par == 1) {
    // si es Firebird
    ins_sql = " DELETE FROM RDB$GENERATORS WHERE RDB$GENERATOR_NAME = '" + upper(tabla) + "' "
  // creamos un generador de numero unico
      =iif(await SQLExec(ins_sql)
      > 0, 0, err_sql())
    // ejecuta instruccion sql
    ins_sql = 'CREATE GENERATOR ' + tabla + ';'
  //+chr(13)+'COMMIT;'
      =iif(await SQLExec(ins_sql)
      > 0, 0, err_sql())
    // ejecuta instruccion sql
    // Sqlcommit ( Public.value.num_dbs ) 

  } // End If 

  ins_sql = 'CREATE TABLE ' + iif(Public.value.ndb_emp == 4, 'public.', ' ') + lower(iif(no_par == 1, tabla, arc_cre)) + '('
  // si es postgresql se aumenta el schema public
  await select('dic_tmp')

  await goto('TOP')

  // VFP SCAN 
  while (!eof()) {
    let tip_sql = 'No asignado'      let dat_sql = des_dat            switch (true) {
      // descripcion del dato
      case upper(dat_sql) == upper('KEY_PRI'):
        switch (true) {
          case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
            tip_sql = ' INT IDENTITY '
            // fluctua hasta 2,147,483,647
            break
          case Public.value.ndb_emp == 2:
            tip_sql = ' INT '
            break
          case Public.value.ndb_emp == 4:
            // Postgres
            tip_sql = ' SERIAL UNIQUE '
        } // End case 

        break
      case upper(dat_sql) == upper('TIMESTAMP'):
        switch (true) {
          case Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3:
            tip_sql = ' '
            break
          case Public.value.ndb_emp == 2:
            dat_sql = 'TIMEST '
            tip_sql = 'INT'
            break
          case Public.value.ndb_emp == 4:
            // Como en POstgreSQL ya hay un campo que remplaza a TIMESTAMP con xmin, no se hace nada
            dat_sql = ''
            tip_sql = ''
        } // End case 

        break
      case dat_sql == 'TIE_UAC' && (Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3):
        // MSSQL
        dat_sql = 'TIE_UAC DATETIME DEFAULT getdate()'
        tip_sql = ' '
        break
      case dat_sql == 'TIE_UAC' && Public.value.ndb_emp == 4:
        //  PostgressSQL
        dat_sql = 'TIE_UAC TIMESTAMP(3) DEFAULT CURRENT_TIMESTAMP'
        tip_sql = ' '
        break
      case dat_sql == 'TIE_UAC' && Public.value.ndb_emp == 2:
        tip_sql = 'TIMESTAMP'
        break        default: tip_sql = obt_tip(tip_dat, true)
    } // End case 
    if (dat_sql == 'OFFSET') {
      // OR dat_sql<>'KEY_PRI'
      dat_sql = '"' + allTrim(dat_sql) + '"'
    } // End If 
    ins_sql = ins_sql + allTrim(dat_sql) + ' ' + tip_sql + ', '
    skip()
  } // End while 

  releaseUse() // use 

  if (await select('dic_dat')
    > 0) {
    await select(dic_dat)

    releaseUse() // use 
    // cierra diccionario de datos

  } // End If 

  ins_sql = position.Left(ins_sql, len(ins_sql) - 2)
  // le quitamos la ultima coma
  ins_sql = ins_sql + ')'
  let a = ins_sql
    = iif(await SQLExec(ins_sql)
      > 0, 0, err_sql())
  // Crea la tabla
  if (Public.value.ndb_emp == 2 && no_par == 1) {
    // si es Firebird genera triggers para datos
    ins_sql = ' CREATE TRIGGER KEY_PRI_' + tabla + ' FOR ' + tabla + RT_LF + ' BEFORE INSERT POSITION 0 ' + RT_LF + ' AS ' + RT_LF + ' BEGIN ' + RT_LF + ' NEW.KEY_PRI = GEN_ID(' + tabla + ', 1); ' + RT_LF + ' NEW.TIMEST = NEW.KEY_PRI; ' + RT_LF + ' NEW.TIE_UAC= CURRENT_TIMESTAMP;' + RT_LF + ' END '
  // que se llenaran automaticamente al momento de
  // insertarse o actualizarse
      =iif(await SQLExec(ins_sql)
      > 0, 0, err_sql())
    // ejecuta instruccion sql
    ins_sql = ' CREATE TRIGGER TIMESTAMP_' + tabla + ' FOR ' + tabla + RT_LF + ' BEFORE UPDATE ' + RT_LF + ' AS ' + RT_LF + ' BEGIN ' + RT_LF + ' NEW.TIMEST = NEW.TIMEST+1; ' + RT_LF + ' NEW.TIE_UAC= CURRENT_TIMESTAMP;' + RT_LF + ' END '
      =iif(await SQLExec(ins_sql)
      > 0, 0, err_sql())
    // ejecuta instruccion sql
    // Sqlcommit ( Public.value.num_dbs ) 

  } // End If 

  return

}   // Fin Procedure
// ----------------------------------< Generación de vistas >--------------------------------------

export async function gen_vis(nom_arc: string, ini_arc: any) {
  let m = {}   // inicializamos m
  let nom_arc = allTrim(nom_arc)
  if (Parameters() == 1) {
    let ini_arc = false
  } // End If 

  let ins_sql = "Select CAST(Count(key_pri) as int) as num_reg From comedat Where nom_tab=Upper('" + nom_arc + "')"
  await select('0')

  m.num_reg = 0
  if (await SQLExec(ins_sql)
    > 0) {
    // si esta el diccionario de datos en la base de datos
    m = appendM(m, await scatter(m))// scatter 

    if (await recCount() == 0 || m.num_reg == 0 && noexistelatablaquesequieregenerarlasvistas) {
      return

    } // End If 

  } else {

    let num_reg = await localAlaSql("select  Count ( nom_arc ) From cometab Where nom_tab = Upper ( nom_arc )")

  } // End If 

  ins_sql = 'SELECT min(KEY_PRI) from ' + nom_arc
  //Select Count(nom_arc) From cometab Where nom_tab=nom_arc Into Array num_reg
  // 26/Nov/2008
  // reviza primero si existe el archivo
  if (await SQLExec(ins_sql)
    < 0) {
    // no existe el archivo
    return

  } // End If 

  // Set Safety Off 
  //ins_sql='SELECT top 1 // from man_'+nom_arc   && reviza primero si existe el archivo
  //If m.ndb_emp=4 && Si es PostgreSQL
  // ins_sql='SELECT // from man_'+nom_arc+' limit 1'
  //Endif
  //If SQLExec(num_dbs,ins_sql,'campos_sql')<0 && no existe la vista man_come
  // gen_ind(nom_arc,m.dir_emp,.T.)
  //Endif

  const tabla: never[] | ((arg0: number) => string) = [];// VFP Dime tabla(5)

  let dic_dat = position.Left(nom_arc, 4) + 'dat'
  // define el diccionario de datos
  let ind_arc = position.Left(nom_arc, 4) + 'ind'
  // define el diccionario de datos
  let vis_arc = position.Left(nom_arc, 4) + 'vis'
  // define el archivo de vistas
  let tab = lower(nom_arc)
  // lee los campos de la tabla
  ins_sql = " Select des_dat,tip_dat,val_dat,lon_dat,dec_dat From comedat Where lower(nom_tab)='" + tab + "' Order By con_dat"
  await select('0')

  if (await SQLExec(ins_sql, 'valores')
    < 0) {
    // si esta el diccionario de datos en la base de datos
    let res = await localAlaSql("INSERT INTO valores select des_dat , tip_dat , val_dat , lon_dat , dec_dat From ( dic_dat ) Where position.Left ( arc_dat , 3 ) = Upper ( Right ( nom_arc , 3 ) ) AND Right ( arc_dat , 3 ) != '000' AND des_dat != 'Borrado' Order By arc_dat")

  } // End If 

  m = appendM(m, await scatter(m))// scatter 

  if (await select(dic_dat)
    > 0) {
    await select(dic_dat)

    releaseUse() // use 

  } // End If 

  ins_sql = 'Select * From comeind Where nom_tab=Upper(?nom_arc) Order By num_ind'
  // lee los indices de la tabla
  await select('0')
  // reviza primero si existe el archivo

  if (await SQLExec(ins_sql, 'indices_vis')
    < 0) {
    //
    let res = await localAlaSql("INSERT INTO indices_vis select * From ( ind_arc ) Where dbf_ind = Upper ( nom_arc ) Order By num_ind")

    await select(ind_arc)

    releaseUse() // use 

  } // End If 

  ins_sql = 'Select * From comevis Where nom_tab=Upper(?nom_arc)'
  // lee las vistas a generar
  await select('0')

  if (await SQLExec(ins_sql, 'vistas')
    < 0) {
    // si esta el diccionario de datos en la base de datos
    let res = await localAlaSql("INSERT INTO vistas select * From ( vis_arc ) Where dbf_vis = Upper ( nom_arc )")

    await select(vis_arc)

    releaseUse() // use 

  } // End If 

  await select('indices_vis')
  //Select // From (vis_arc) Where dbf_vis=Upper(nom_arc) Into Cursor vistas

  // VFP SCAN 
  while (!eof()) {
    // lee indice por indice
    MessageBox('Generando Vistas del archivo:  ' + nom_arc)
    m = appendM(m, await scatter(m))// scatter 
    m.exp_ind = allTrim(m.exp_ind)      m.nom_ind = allTrim(m.nom_ind)      if (Public.value.sql_emp == 'S') {
      // si es una tabla SQL Server

      // generacion de vistas unicamente por su llave principal
      if (upper(position.Left(m.nom_ind, 4)) == 'LLA1') {
        let nom_vis = lower('vi_' + allTrim(m.nom_ind))
        let con_vis = ''
        // genera la expresion de la condicion de la vista
        let exp_exp = m.exp_ind
        let pos_com = at(',', exp_exp)
        // revizar vistas

        while (pos_com > 0) {
          let cam_sep = position.Left(exp_exp, pos_com - 1)
          // campo separado
          con_vis = con_vis + cam_sep + '=?m.' + cam_sep + ' and '            exp_exp = right(exp_exp, len(exp_exp) - pos_com)            pos_com = at(',', exp_exp)
        } // End while 

        con_vis = con_vis + exp_exp + '=?m.' + exp_exp
        let ins_sel = 'select * from man_' + m.nom_arc + ' where con_true'
        // creamos las vistas remotas de llave principal
        if (Public.value.ndb_emp == 4) {
          ins_sel = traduce_tsql(ins_sel)
          ins_sel = strtran(ins_sel, char(13), ' ')
          ins_sel = strtran(ins_sel, char(10), ' ')
        } // End If 

        let vis_sql = ' view ' + nom_vis + ' as ' + strtran(ins_sel, 'WHERE ( con_true  )', '')
        ins_sel = strtran(ins_sel, 'con_true', con_vis)
        let ins_fox = 'create sql view ' + nom_vis + ' REMOTE CONNECTION SIAVCOM SHARE as ' + ins_sel
        ins_sql = 'SELECT min(KEY_PRI) from man_' + m.nom_arc
        //     'select // from man_'+m.nom_arc+' where '+con_vis)
        if (await SQLExec(ins_sql)
          < 0) {
          // si no existe el archivo
          return
          // se sale

        } // End If 

        try {
                        & ins_fox
        }
        // =IIF(SQLEXEC(num_dbs,vis_sql)<0,err_sql(),.t.)
        //=CURSORSETPROP("Buffering", 5, nom_vis )  && Enable table buffering
        catch (error) {
          await MessageBox('No se pudo generar la vista ' + m.nom_vis, 2000)
          let a = ins_fox                        // Set Step On 

        } // End Try

        DBSetProp(nom_vis, 'View', 'FetchMemo', true)
        // ponemos propiedad para que no se traiga memos
        DBSetProp(nom_vis, 'View', 'MaxRecords', -1)
        DBSetProp(nom_vis, 'View', 'FetchSize', -1)
        // ponemos propiedad para que no se traiga todos los registros
        await select('valores')
        //      CURSORSETPROP('FetchSize',-1)  && trae todos los renglones de una consulta por medio de una vista remota

        await goto('TOP')

        // VFP SCAN 
        while (!eof()) {
          m = appendM(m, await scatter(m))// scatter 
          try {
            let nom_cam = lower(allTrim(nom_vis) + '.' + allTrim(m.des_dat))                            if (m.val_dat > '   ') {
              // si el valor es diferente a espacios
              DBSetProp(nom_cam, 'Field', 'DefaultValue', rTrim(m.val_dat))
            } // End If 
            if (m.tip_dat == 'D') {
              if (upper(nom_cam) == 'VI_LLA1_DOC.FEL_DOC' || upper(nom_cam) == 'VI_LLA1_VIA.FEC_VIA' || upper(nom_cam) == 'VI_LLA1_VIA.FLL_VIA') {
                // si el tipo de datos es asignamos a date en la vista
                DBSetProp(nom_cam, 'Field', 'DataType', 'T')
              } else {

                DBSetProp(nom_cam, 'Field', 'DataType', 'D')
              } // End If 

            } // End If 

            // asignamos el valor de los campos numericos*******************
            if (m.tip_dat == 'N') {
              // si el tipo de datos es numerico
              DBSetProp(nom_cam, 'Field', 'DataType', 'N(' + str(lon_dat, 2) + ',' + str(dec_dat, 2) + ')')
            } // End If 

            // >>>>>>>>>>>>>> 9/Ene/2021
            if (m.tip_dat == 'C') {
              // si el tipo de datos es caracter
              if (lon_dat < 255) {
                DBSetProp(nom_cam, 'Field', 'DataType', 'C(' + str(lon_dat, 3) + ')')
              } else {

                DBSetProp(nom_cam, 'Field', 'DataType', 'M')
              } // End If 

            } // End If 
            if (m.tip_dat == 'X' || tip_dat == 'M') {
              // si el tipo de datos es xml
              DBSetProp(nom_cam, 'Field', 'DataType', 'M')
            } // End If 
            if (m.tip_dat == 'L') {
              // si el tipo de datos es logico
              DBSetProp(nom_cam, 'Field', 'DataType', 'L')
            } // End If 
            if (m.tip_dat == 'V') {
              // varchar
              if (m.lon_dat > 0) {
                DBSetProp(nom_cam, 'Field', 'DataType', 'M')
                //DBSetProp(nom_cam,'Field','DataType','V('+Alltrim(Str(m.lon_dat))+')' )
                //DBSetProp(nom_cam,'Field','DataType','C('+Alltrim(Str(m.lon_dat))+')' )
                // varchar(max)
              } else {

                DBSetProp(nom_cam, 'Field', 'DataType', 'M')
                // varchar(max)
              } // End If 

            } // End If 
            if (nom_cam == 'usu_cre' || nom_cam == 'tie_cre' || nom_cam == 'usu_usu' || nom_cam == 'tie_uac') {
              DBSetProp(nom_cam, 'Field', "Updatable", false)
            } // End If 
          }
          catch (error) {
            await MessageBox('No existe el campo de la vista ' + m.nom_vis + '.' + m.des_dat, 48, 'Problema al generar vista', 2000)

          } // End Try

          skip()
        } // End while 

        let nom_vis2 = 'vi_key_' + right(rTrim(m.nom_ind), 3)

        // crea la vista unicamente por KEY_PRI utilizada unicamente para validación
        if (m.nom_arc != 'COMEFRX') {
          ins_fox = 'create sql view ' + nom_vis2 + ' REMOTE CONNECTION SIAVCOM SHARE as select KEY_PRI,TIMESTAMP from man_' + m.nom_arc + ' where ' + con_vis
        } // End If 

          & ins_fox
        //!//        Do Case
        //!//         Case m.ndb_emp=1 Or m.ndb_emp=3
        //!//          ins_fox='create sql view '+nom_vis2+' REMOTE CONNECTION SIAVCOM SHARE as select KEY_PRI,TIMESTAMP from man_'+m.nom_arc+' where '+con_vis
        //!//         Case m.ndb_emp=2
        //!//          ins_fox='create sql view '+nom_vis2+' REMOTE CONNECTION SIAVCOM SHARE as select KEY_PRI,timest from '+m.nom_arc+' where '+con_vis
        //!//         Case m.ndb_emp=4
        //!//          ins_fox='create sql view '+nom_vis2+' REMOTE CONNECTION SIAVCOM SHARE as select KEY_PRI,xmin from '+m.nom_arc+' where '+con_vis
        //!//
        //!//        Endcase
        DBSetProp(nom_vis, 'View', 'FetchMemo', true)
        // ponemos propiedad para que no se traiga memos
        DBSetProp(nom_vis + '.KEY_PRI', 'Field', 'Keyfield', true)
        // Definimos sus propiedades
        // Definimos la llave de actualizacion de la vista
        DBSetProp(nom_vis + '.KEY_PRI', 'Field', 'Updatable', false)
        // Definimos que la llave de actualización no es actualisable
        DBSetProp(nom_vis, 'VIew', 'SendUpdates', false)
        // Definimos que no es actualizable
        await select('vistas')
        // seleccionamos las vistas a utilizar

        try {
          let dbf_vis = allTrim(dbf_vis)
        }
        catch (error) {
          dbf_vis = allTrim(nom_tab)
          // diccionaro en la base de datos

        } // End Try

        // VFP SCAN 
        while (!eof() && ini_arc) {
          ins_sel = ''            m.vre_vis = 'N'            m = appendM(m, await scatter(m))// scatter 
          m.nom_vis = rTrim(m.nom_vis)            con_vis = ''
          // genera la expresion de la condicion de la vista
          if (Nvl(M.vre_vis, 'N') != 'S') {
            // si no es una vista remota de SQL
            exp_exp = rTrim(m.fil_vis)
            pos_com = at(',', exp_exp)
            // revizar vistas

            while (pos_com > 0) {
              cam_sep = position.Left(exp_exp, pos_com - 1)
              // campo separado
              con_vis = con_vis + 'man_' + rTrim(lower(nom_arc)) + '.' + cam_sep + '=?m.' + cam_sep + ' and '
              //      con_vis=con_vis+'man_'+Rtrim(dbf_vis)+'.'+cam_sep+'=?m.'+cam_sep+' and '
              exp_exp = right(exp_exp, len(exp_exp) - pos_com)                pos_com = at(',', exp_exp)
            } // End while 

            con_vis = iif(len(exp_exp) > 2, con_vis + 'man_' + rTrim(lower(nom_arc)) + '.' + exp_exp + '=?m.' + exp_exp, ' ')
            // con_vis=Iif( Len(exp_exp)>2,con_vis+'man_'+Rtrim(LOWER(dbf_vis))+'.'+exp_exp+'=?m.'+exp_exp,' ')
            m.sql_vis = Nvl(m.sql_vis, '')
            // creamos las vistas remotas
            if (len(rTrim(con_vis)) > 1) {
              con_vis = iif(len(allTrim(m.sql_vis)) < 2, con_vis, con_vis + ' and ' + m.sql_vis)
            } else {

              con_vis = iif(len(allTrim(m.sql_vis)) < 2, con_vis, m.sql_vis)
            } // End If 

            if (Public.value.ndb_emp == 4) {
              con_vis = allTrim(strtran(con_vis, 'dbo.', ' '))
            } // End If 

          } // End If 

          // si tiene campos predeterminados
          // si la tabla es de formatos de reportes
          if (m.dbf_vis == 'COMEFRX' && (Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3)) {
            m.cam_vis = ''
          } // End If 
          m.cam_vis = Nvl(m.cam_vis, ' ')            m.cam_vis = iif(len(allTrim(m.cam_vis)) < 2, ' * ', m.cam_vis)
          //+IIF(m.ndb_emp=4,','+dbf_vis+'.xmin ','')
          if (Nvl(M.vre_vis, 'N') != 'S') {
            // si es una vista remota de VFP
            ins_sel = 'select ' + allTrim(m.cam_vis) + ' from ' + allTrim(m.tab_vis)
            //+' where true'
            if (Public.value.ndb_emp == 4) {
              ins_sel = allTrim(traduce_tsql(ins_sel))
              ins_sel = strtran(ins_sel, ';', ' ')
              ins_sel = strtran(ins_sel, char(13), ' ')
              ins_sel = strtran(ins_sel, char(10), ' ')
            } // End If 

            vis_sql = 'view ' + nom_vis + ' as ' + ins_sel + iif(len(allTrim(m.ord_vis)) > 0, ' order by ' + m.ord_vis, ' ') + ' offset 0 ' + iif(Public.value.ndb_emp == 1, ' row', '')
            // definicion de la vista en SQLSERVER
            con_vis = allTrim(con_vis)
            //ins_sel=Strtran(ins_sel,' where ( true )',Iif(Len(Alltrim(con_vis))>3,' WHERE '+con_vis,' ')+
            ins_sel = allTrim(ins_sel) + ' '
            m.ord_vis = allTrim(m.ord_vis)
            ins_sel = ins_sel + iif(len(con_vis) > 3, ' WHERE ' + con_vis, ' ') + iif(len(m.ord_vis) > 0, ' order by ' + m.ord_vis, ' ')
            ins_fox = 'create sql view ' + allTrim(nom_vis) + ' REMOTE CONNECTION SIAVCOM SHARE as ' + ins_sel
            if (Public.value.ndb_emp == 1 || Public.value.ndb_emp == 3) {
              await SQLExec('SELECT COUNT(name) AS SW_VIS FROM dbo.sysobjects WHERE name = ?nom_vis')

              // si no existe el archivo
              if (sqlresult.SW_VIS == 1) {
                vis_sql = 'ALTER ' + vis_sql
              } else {

                vis_sql = 'create ' + vis_sql
              } // End If 

            } else {

              vis_sql = 'create or replace ' + vis_sql
            } // End If 

            vis_sql = upper(vis_sql)
            a = ins_fox
            ins_fox = upper(ins_fox)
            if (m.nom_vis == 'vi_cap_fot') {
              ins_fox = strtran(ins_fox, 'GENERAL', 'binary')
            } // End If 

            a = ins_fox
            try {
                                & ins_fox                                a = ins_fox                                DBSetProp(nom_vis, 'View', 'FetchSize', -1)                                DBSetProp(nom_vis, 'View', 'MaxRecords', -1)
              // se trae todos los renglones de la vista
              let num_tab = 1
              //          dbsetprop(m.nom_vis,'View','FetchMemo',.f.)   && ponemos propiedad para que no se traiga memos
              // obtiene las tablas de que se compone la vista
              let ult_pos = 0                                for (let i = 1; i < len(allTrim(m.tab_vis)); i++) {
                // calcula cuantos tablas tiene la vista
                if (substr(m.tab_vis, i, 1) == ',') {
                  tabla(num_tab) = position.Left(m.tab_vis, i - 1)
                  ult_pos = i
                  // ultimo lugar donde encontro una coma
                  num_tab = num_tab + 1
                } // End If 

              } // End For; 
              if (ult_pos == 0) {
                // si es una sola tabla la de la vista
                tabla(1) = allTrim(m.tab_vis)
              } else {

                // si no obtiene la ultima tabla
                tabla(num_tab) = rTrim(right(m.tab_vis, len(m.tab_vis) - ult_pos))
              } // End If 
              if (substr(m.nom_vis, 7, 1) == '_') {
                //solo vistas de mantenimiento   'vi_comeisu'
                DBSetProp(m.nom_vis, 'VIew', 'Tables', tabla(1))
                DBSetProp(m.nom_vis + '.KEY_PRI', 'Field', 'Keyfield', true)
                DBSetProp(m.nom_vis + '.KEY_PRI', 'Field', 'Updatable', false)
                // Definimos que la llave de actualización no es actualisable
                DBSetProp(m.nom_vis, 'VIew', 'SendUpdates', false)
                // Definimos que no es actualizable
              } // End If 
              await select('0')
              await useNodata((m.nom_vis)) // use ( ( Nodata
              let ele_vis =const est_vis = afields()

              // obtenemos la estructura de la vista
              releaseUse() // use 
              // cerramos la vista
              await select('valores')
              for (let i = 1; i < ele_vis; i++) {
                // recorremos campos de la vista
                // VFP LOCATE For rTrim(est_vis(i,1))=rTrim(des_dat)
                let records = await locateFor(` rTrim(est_vis(i,1))=rTrim(des_dat)`)

                if (!Eof() && val_dat != '   ') {
  // si el valor es diferente a espacios
                    =DBSetProp(m.nom_vis + '.' + rTrim(des_dat), 'Field', 'DefaultValue', rTrim(val_dat))
                } // End If 

                if (!Eof() && tip_dat == 'D') {
                  // si el tipo de datos es asignamos a date en la vista
                  DBSetProp(nom_vis + '.' + des_dat, 'Field', 'DataType', 'D')
                } // End If 

              } // End For; 
            }
            catch (error) {
              await MessageBox('No se pudo crear la VISTA ' + m.nom_vis, 32, 'Error al generar la vista', 5000)

            } // End Try

          } else {
            //////////////////////////////////////   Genera vistas en la base de datos
            //!//           IF SQLEXEC(num_dbs,vis_sql)<0
            //!//               set step on
            //!//               a=vis_sql
            //!//               do get_scr
            //!//               messagebox('Error al crear la vista en la base de datos SQL'+vis_sql)
            //!//               ins_sql=vis_sql
            //!//               err_sql()
            //!//                         a=vis_sql
            //!//               return
            //!//                     endif
            ////////////////////////////////////////

            ins_sql = 'select ' + m.cam_vis + ' from ' + allTrim(m.tab_vis) + iif(len(allTrim(m.sql_vis)) > 3, ' WHERE ' + m.sql_vis, ' ')
            // si es vista remota de SQL Server

            // Iif(Len(Alltrim(m.ord_vis))>0,' order by '+m.ord_vis,' ')
            if (Public.value.ndb_emp == 4) {
              ins_sql = traduce_tsql(ins_sql)
              ins_sel = strtran(ins_sel, char(13), ' ')
              ins_sel = strtran(ins_sel, char(10), ' ')
              ins_sql = 'CREATE OR REPLACE VIEW ' + nom_vis + '  as ' + ins_sql
            } else {

              ins_sql = 'create view ' + nom_vis + '  as ' + ins_sql
            } // End If 

            if (await SQLExec(ins_sql)
              < 0) {
              ins_sql = strtran(ins_sql, 'create', 'alter')
              // view '+nom_vis+'  as '+ins_sql
              if (await SQLExec(ins_sql)
                < 0) {
                  =err_sql()
              } // End If 

            } else {

              ins_sql = ' grant select on ' + nom_vis + ' to siavcom'
              // asigna los permisos tambien
              if (await SQLExec(ins_sql)
                < 0) {
                ins_sql = 'alter view ' + nom_vis + '  as ' + ins_sql
                  =err_sql()
              } // End If 

            } // End If 

          } // End If 
          await select('vistas')

          skip()
        } // End while 

      } // End If 

    } // End If 
    await select('indices_vis')

    skip()
  } // End while 

  return

}   // Fin Procedure
// ---------< Corta un numero a los decimales dados >

export async function cor_num(num_cor: number, dec_cor: number) {
  let m = {}   // inicializamos m
  // Dimension val_cor ( 1 ) As Int 

  let val_cor = cast('1' + replicateString('0', dec_cor), 'INT')
  let num_cor = Round(num_cor * (val_cor), 0)
  return num_cor / val_cor
  //num_cor=Floor(num_cor//(val_cor))

}   // Fin Procedure
// ---------- < Rellena a ceros las codigos de clientes o proveedores >-----------
// Fecha 19/May/2014

export async function jus_cer(m: { cop_nom: string; cod_nom: string }.cod_nom: any, m: any.cop_nom: any) {
  let m = {}   // inicializamos m
  // Private lon_cta 

  // Dimension niv_cap ( 5 ) 

  switch (true) {
    case m.cop_nom == 'C':
      let ima_cap = Public.value.icl_pge
      break
    case m.cop_nom == 'P':
      ima_cap = Public.value.ipr_pge
      break
    case m.cop_nom == 'E':
      // presupuesto
      ima_cap = Public.value.ipg_pge
  } // End case 

  for (let i = 1; i < 5; i++) {
    niv_cap(i) = 0
    let pos = at('-', ima_cap)
    // busca primera posición
    if (pos == 0) {
      pos = len(allTrim(ima_cap)) + 1
    } // End If 

    if (pos > 1) {
      niv_cap(i) = pos - 1
      ima_cap = right(ima_cap, len(ima_cap) - pos)
    } // End If 

  } // End For; 

  m.cod_nom = strtran(m.cod_nom, ' ', '')
  // Quita los espacios
  let lon_cta = len(m.cod_nom)
  i = 1
  // checa cta. y si necesario rellena el ultimo nivel a ceros
  // contador de niveles
  let posIni = 1
  // posicion inicial
  let cod_pas = ''
  // subniveles antes de rellenarse a ceros
  let subCta = ''
  // subcta. analizandose
  let sw_sal = true

  while (sw_sal) {
    if (niv_cap(i) > 0) {
      subCta = rTrim(substr(m.cod_nom, posIni, niv_cap(i)))
      //niv_cta
      if (len(subCta) < niv_cap(i)) {
        subCta = '000000000' + subCta
        subCta = right(subCta, niv_cap(i))
      } // End If 

      cod_pas = cod_pas + subCta
      if (len(cod_pas) >= lon_cta) {
        // salida de rutina
        sw_sal = false
      } // End If 

      posIni = len(cod_pas) + 1
      i = i + 1
    } else {

      sw_sal = false
    } // End If 
  } // End while 

  return cod_pas

}   // Fin Procedure
// -------------------------------------< Obten la descripción de la familia >-------------------------------------

export async function obt_fam(m: Record<string, never> | undefined.num_fam: number, m: any.cla_isu: any) {
  let m = {}   // inicializamos m
  if (m.num_fam == 1) {
    // obtenemos posiciones para generar la condición
    Public.value.pri_cla = 1
    Public.value.ult_cla = at('-', Public.value.ima_pge)
  } else {

    Public.value.pri_cla = at('-', Public.value.ima_pge, num_fam - 1) + 1
    Public.value.ult_cla = at('-', Public.value.ima_pge, num_fam)
  } // End If 

  if (Public.value.ult_cla == 0) {
    Public.value.ult_cla = len(rTrim(Public.value.ima_pge)) + 1
  } // End If 

  let are_tra = await select()
  // obtenemos la parte de la clave del insumo
  // que identifica la familia

  m.cla_fam = substr(m.cla_isu, Public.value.pri_cla, Public.value.ult_cla - Public.value.pri_cla)
  // obtiene la familia
  await select('vi_lla1_fam')
  // utilizamos la vista de captura de familia para

  m.des_fam = ' '
  // traernos el datos
  await use('vi_lla1_fam', m) // use vi_lla1_fam vi_lla1_fam

  if (await recNo() > 0) {
    m.des_fam = des_fam
  } // End If 

  await select(are_tra)

  return m.des_fam

}   // Fin Procedure
// -------------------------------------< Busca el tipo de documento >-------------------------------------

export async function bus_tdo(tip_doc: any) {
  let m = {}   // inicializamos m
  let are_tra = await select()

  await select('vi_cap_tdo')

  // VFP LOCATE For tdo_tdo=tip_doc
  let records = await locateFor(` tdo_tdo=tip_doc`)

  let res = Found()
  await select(are_tra)

  return res

}   // Fin Procedure
// -----------------------------------< Proteccion de moneda en espaÃ±ol >------------------------

export async function cifra(cantidad: number, cifra: string) {
  let m = {}   // inicializamos m
  if (cantidad >= 100) {
    // miles
    let can = int(cantidad / 100)
    switch (true) {
      case can == 1:
        let cifra = cifra + ' ciento'
        break
      case can == 2:
        cifra = cifra + ' doscientos'
        break
      case can == 3:
        cifra = cifra + ' trescientos'
        break
      case can == 4:
        cifra = cifra + ' cuatrocientos'
        break
      case can == 5:
        cifra = cifra + ' quinientos'
        break
      case can == 6:
        cifra = cifra + ' seiscientos'
        break
      case can == 7:
        cifra = cifra + ' setecientos'
        break
      case can == 8:
        cifra = cifra + ' ochocientos'
        break
      case can == 9:
        cifra = cifra + ' novecientos'
    } // End case 

    let cantidad = cantidad - (can * 100)
  } // End If 

  if (cantidad >= 20) {
    can = int(cantidad / 10)
    switch (true) {
      case can == 2:
        cifra = cifra + ' veinte'
        break
      case can == 3:
        cifra = cifra + ' treinta'
        break
      case can == 4:
        cifra = cifra + ' cuarenta'
        break
      case can == 5:
        cifra = cifra + ' cincuenta'
        break
      case can == 6:
        cifra = cifra + ' sesenta'
        break
      case can == 7:
        cifra = cifra + ' setenta'
        break
      case can == 8:
        cifra = cifra + ' ochenta'
        break
      case can == 9:
        cifra = cifra + ' noventa'
    } // End case 

    cantidad = cantidad - (can * 10)
    if (cantidad >= 1) {
      cifra = cifra + ' y'
    } // End If 

  } // End If 

  if (cantidad >= 10) {
    can = int(cantidad)
    switch (true) {
      case can == 10:
        cifra = cifra + ' diez'
        break
      case can == 11:
        cifra = cifra + ' once'
        break
      case can == 12:
        cifra = cifra + ' doce'
        break
      case can == 13:
        cifra = cifra + ' trece'
        break
      case can == 14:
        cifra = cifra + ' catorce'
        break
      case can == 15:
        cifra = cifra + ' quince'
        break
      case can == 16:
        cifra = cifra + ' dieciseis'
        // diez y seis'
        break
      case can == 17:
        cifra = cifra + ' diecisiete'
        break
      case can == 18:
        cifra = cifra + ' dieciocho'
        break
      case can == 19:
        cifra = cifra + ' diecinueve'
    } // End case 

    cantidad = 0
  } // End If 

  if (cantidad >= 1) {
    can = int(cantidad)
    switch (true) {
      case can == 1:
        cifra = cifra + ' un'
        break
      case can == 2:
        cifra = cifra + ' dos'
        break
      case can == 3:
        cifra = cifra + ' tres'
        break
      case can == 4:
        cifra = cifra + ' cuatro'
        break
      case can == 5:
        cifra = cifra + ' cinco'
        break
      case can == 6:
        cifra = cifra + ' seis'
        break
      case can == 7:
        cifra = cifra + ' siete'
        break
      case can == 8:
        cifra = cifra + ' ocho'
        break
      case can == 9:
        cifra = cifra + ' nueve'
    } // End case 

    cantidad = 0
    return

  } // End If 

  return

}   // Fin Procedure

export async function prot_esp(cantidad: number, moneda: number, mensaje: any) {
  let m = {}   // inicializamos m
  let val_ant = 0
  if (Parameters() == 2) {
    let mensaje = ''
  } // End If 

  let cantidad = Round(cantidad, 2)
  let cifra = ''
  let numero = 1000000

  while (numero >= 1 && cantidad > 0) {
    let cant = int(int(cantidad) / numero)
    // obtiene el entero para identificar
    let can_tot = (int(cantidad) / numero) - 100
    // cantidad total
    if (cant > 0) {
      cantidad = cantidad - (cant * numero)
      let num1 = cant * numero
      let can_ant = cant
      await cifra(cant, cifra)

      if (can_ant == 100 && can_tot < 1) {
        cifra = position.Left(cifra, len(cifra) - 2)
      } // End If 

    } // End If 
    numero = int(numero / 1000)      if ((numero * 1000)) {
        >= 1000000 && numero < 1000000 && len(cifra) > 0
      if (num1 == 1000000) {
        cifra = cifra + " millon "
      } else {

        cifra = cifra + " millones"
      } // End If 

    } // End If 
    if ((numero * 1000)) {
        >= 1000 && numero < 1000 && len(cifra) > 0
      if (val_ant >= 1000) {
        cifra = cifra + " mil"
      } // End If 

    } // End If 
    val_ant = cantidad
  } // End while 

  cifra = cifra + ' ' + rTrim(Public.value.pro_mon1(moneda)) + ' '
  cifra = "(--" + cifra + right('00' + lTrim(str(cantidad * 100)), 2) + "/100 " + iif(moneda == 1, 'M.N.', mensaje) + " --)"
  return cifra

}   // Fin Procedure
// ----------------------< Proteccción de moneda en ingles >-----------------------------------------

export async function prot_ing(cantidad: number, moneda: any) {
  let m = {}   // inicializamos m
  let cantidad = Round(cantidad, 2)
  let cif_ent = int(cantidad)
  cantidad = cantidad - cif_ent
  let cifra = cif_ing(cif_ent)
  cifra = cifra + ' ' + rTrim(Public.value.pro_mon1(moneda)) + ' '
  cifra = "(--" + cifra + lTrim(str(cantidad * 100)) + "/100 --)"
  return cifra

}   // Fin Procedure

export async function cif_ing(ln_n: number) {
  let m = {}   // inicializamos m
  // Private ln_num , lc_ret , ld_minus , ln_d3 , ln_d2 , ln_d1 , lc_y , ln_p 

  // VFP Dime tname
  // VFP Dime ]
  // VFP Dime dname
  // VFP Dime ]
  // VFP Dime ln_num
  const Int = [];// VFP Dime Int(ln_n)

  if (ln_num == 0) {
    return 'Zero'

  } // End If 

  tname[1] = ''
  tname[2] = ' thousand '
  tname[3] = ' million '
  tname[4] = ' billion '
  tname[5] = ' trillion '
  tname[6] = ' quadrillion '
  tname[7] = ' quintillion '
  dname[1] = 'one'
  dname[2] = 'two'
  dname[3] = 'three'
  dname[4] = 'four'
  dname[5] = 'five'
  dname[6] = 'six'
  dname[7] = 'seven'
  dname[8] = 'eight'
  dname[9] = 'nine'
  dname[10] = 'ten'
  dname[11] = 'eleven'
  dname[12] = 'twelve'
  dname[13] = 'thirteen'
  dname[14] = 'fourteen'
  dname[15] = 'fifteen'
  dname[16] = 'sixteen'
  dname[17] = 'seventeen'
  dname[18] = 'eighteen'
  dname[19] = 'nineteen'
  dname[20] = 'twenty'
  dname[21] = 'thirty'
  dname[22] = 'forty'
  dname[23] = 'fifty'
  dname[24] = 'sixty'
  dname[25] = 'seventy'
  dname[26] = 'eighty'
  dname[27] = 'ninety'
  let lc_ret = ''
  if (ln_num < 0) {
    let ld_minus = true
    let ln_num = -ln_num
  } else {

    ld_minus = false
  } // End If 

  let ln_p = 1

  while (ln_num != 0) {
    let ln_d3 = ln_num % 1000      ln_num = int(ln_num / 1000)      if (ln_d3 != 0) {
      let ln_d2 = Mod(ln_d3, 100)
      ln_d3 = int(ln_d3 / 100)
      switch (true) {
        case ln_d2 == 0:
          let lc_y = ''
          break
        case ln_d2 < 20:
          lc_y = dname[ln_d2]
          break          default: let ln_d1 = ln_d2 % 10
          ln_d2 = int(ln_d2 / 10)
          lc_y = dname[18 + ln_d2]
          if (ln_d1 != 0) {
            lc_y = lc_y + '-' + dname[ln_d1]
          } // End If 

      } // End case 

      if (ln_d3 != 0) {
        lc_y = dname[ln_d3] + ' hundred ' + iif(len(lc_y) != 0, '', '') + lc_y
      } // End If 

      lc_ret = lc_y + tname[ln_p] + lc_ret
    } // End If 
    ln_p = ln_p + 1
  } // End while 

  if (ld_minus) {
    lc_ret = 'Minus ' + rTrim(lc_ret)
  } else {

    lc_ret = upper(position.Left(lc_ret, 1)) + rTrim(substr(lc_ret, 2))
  } // End If 

  return lc_ret

}   // Fin Procedure
// ----------------< Procedimiento para encriptar una palabra >-----------

export async function enc_pal(pal_enc: string) {
  let m = {}   // inicializamos m
  // Local pos 

  let pal_enc = upper(pal_enc)
  let clave = ''
  // encripta password
  let lon_pal = len(pal_enc)
  let pos = 1
  for (let j = 1; j < lon_pal; j++) {
    if (asc(substr(pal_enc, j, 1)) == 32) {
      clave = clave + char(asc(substr(pal_enc, j, 1)) + pos)
    } else {

      switch (true) {
        case pos == 1:
          clave = clave + char(asc(substr(pal_enc, j, 1)) + 1)
          break
        case pos == 2:
          clave = clave + char(asc(substr(pal_enc, j, 1)) - 2)
          break
        case pos == 3:
          clave = clave + char(asc(substr(pal_enc, j, 1)) + 3)
          break
        case pos == 4:
          clave = clave + char(asc(substr(pal_enc, j, 1)) - 4)
      } // End case 

    } // End If 

    pos = iif(pos < 4, pos + 1, 1)
  } // End For; 

  return clave

}   // Fin Procedure
// ----------------< Procedimiento para desencriptar una palabra >-----------

export async function des_pal(pal_enc: string) {
  let m = {}   // inicializamos m
  if (isNull(pal_enc)) {
    return ''

  } // End If 

  let clave = ''
  let lon_pal = len(pal_enc)
  let pos = 1
  for (let j = 1; j < lon_pal; j++) {
    if (asc(substr(pal_enc, j, 1)) < 41) {
      clave = clave + ' '
    } else {

      switch (true) {
        case pos == 1:
          clave = clave + char(asc(substr(pal_enc, j, 1)) - 1)
          break
        case pos == 2:
          clave = clave + char(asc(substr(pal_enc, j, 1)) + 2)
          break
        case pos == 3:
          clave = clave + char(asc(substr(pal_enc, j, 1)) - 3)
          break
        case pos == 4:
          clave = clave + char(asc(substr(pal_enc, j, 1)) + 4)
      } // End case 

    } // End If 

    pos = iif(pos < 4, pos + 1, 1)
  } // End For; 

  return clave

}   // Fin Procedure
// ----------------< Procedimiento para encriptar un password >-----------

export async function enc_pas(pal_enc: string) {
  let m = {}   // inicializamos m
  // Local pos 

  let pal_enc = lTrim(pal_enc)
  let lon_pal = len(pal_enc)
  // longitud de la palabra
  let car_pal = ''
  for (let i = 1; i < lon_pal; i++) {
    if (asc(substr(pal_enc, i, 1)) >= 97 && asc(substr(pal_enc, i, 1)) <= 122) {
      let num = int(Rand() * 10)

      while (Mod(num, 2) > 0) {
        num = int(Rand() * 10)
      } // End while 

    } else {

      num = int(Rand() * 10)

      while (Mod(num, 2) == 0) {
        num = int(Rand() * 10)
      } // End while 

    } // End If 

    car_pal = car_pal + allTrim(str(num))
  } // End For; 

  let clave = enc_pal(pal_enc) + car_pal
  return clave

}   // Fin Procedure
// ----------------< Procedimiento para desencriptar password >-----------

export async function des_pas(pal_enc: string | Promise<string>) {
  let m = {}   // inicializamos m
  // Local pos 

  let pal_enc = lTrim(pal_enc)
  let lon_pal = len(pal_enc) / 2
  // longitud de la palabra
  let car_pal = right(pal_enc, lon_pal)
  pal_enc = des_pal(position.Left(pal_enc, lon_pal))
  let pal_des = ''
  for (let i = 1; i < lon_pal; i++) {
    if (Mod(val(substr(car_pal, i, 1)), 2) == 1) {
      pal_des = pal_des + substr(pal_enc, i, 1)
    } else {

      pal_des = pal_des + lower(substr(pal_enc, i, 1))
    } // End If 

  } // End For; 

  return pal_des

}   // Fin Procedure
//-----------------------------------------------------------------------------------------
// Rutina usada para obtener los uuid relacionados de un CFDI 3.3

export async function F_obt_uuid_rel() {
  let m = {}   // inicializamos m
  if (!vi_lla1_doc.tre_sat > '  ') {
    // si no hay relacion
    return ''

  } // End If 

  let are_tra = await select()

  if (cometdo.tip_cfd == 'T') {
    if (tdr_doc > '  ' && ndr_doc > 0) {
      m.tdo_tdo = vi_lla1_doc.tdo_tdo
      m.ndo_doc = vi_lla1_doc.ndo_doc
      let ins_sql = 'select * from vi_imp_uuid_rel where tdo_tdo=?m.tdo_tdo and ndo_doc=?m.ndo_doc'
      if (await SQLExec(ins_sql, 'vi_imp_uuid_rel')
        < 0) {
        let a = ins_sql
          = err_sql()
        await select(are_tra)

        await MessageBox('No se pudo obtener los uuid relacionados de este documento', 16, 'Error', 5000)

        return false

      } // End If 

      await select('vi_imp_uuid_rel')

      let rel_doc = ''
      await goto('TOP')

      // VFP SCAN 
      while (!eof()) {
        rel_doc = rel_doc + UUID + '          Folio Interno:' + vi_imp_uuid_rel.tdo_rel + '   ' + str(vi_imp_uuid_rel.ndo_rel, 12) + char(13)
        skip()
      } // End while 

      releaseUse() // use 

      await select(are_tra)

      return rel_doc

    } // End If 

    m.dre_doc = ''
    if (await select('docxml')
      > 0) {
      try {
        m.dre_doc = Strconv(docxml.dre_doc, 14)
      }
      catch (error) {
        await select(are_tra)
        return ''

      } // End Try

    } // End If 

    if (m.dre_doc > '  ') {
      await localAlaSql(' CREATE TABLE vi_imp_uuid_rel (tdo_tdo CHAR(3),ndo_docint,fec_docdate,tot_doccurrency,uuid CHAR(36),ref_doc CHAR(80))')

      Xmltocursor(m.dre_doc, 'vi_imp_uuid_rel', 8192)
    } else {

      await select(are_tra)

      return ''

    } // End If 

    await select('vi_imp_uuid_rel')

    rel_doc = ''
    await goto('TOP')

    // VFP SCAN 
    while (!eof()) {
      rel_doc = rel_doc + UUID + '          Folio Interno:' + vi_imp_uuid_rel.tdo_tdo + '   ' + str(vi_imp_uuid_rel.ndo_doc, 8) + char(13)
      skip()
    } // End while 

    releaseUse() // use 

    await select(are_tra)

    return rel_doc

  } // End If 

  m.dre_doc = ''
  //////////////////////////////////////////////////////////////////////
  if (await select('docxml')
    > 0) {
    try {
      m.dre_doc = Strconv(docxml.dre_doc, 14)
    }
    catch (error) {
      let sw_dre = false
    } // End Try

  } // End If 

  switch (true) {
    case m.dre_doc > '  ':
      await localAlaSql(' CREATE TABLE vi_imp_uuid_rel (tdo_tdo CHAR(3),ndo_docint,fec_docdate,tot_doccurrency,uuid CHAR(36),ref_doc CHAR(80))')

      Xmltocursor(m.dre_doc, 'vi_imp_uuid_rel', 8192)
      break
    case cometdo.coa_tdo == 'A':
      // si es una pago que salda documentos
      m.tdo_tdo = vi_lla1_doc.tdo_tdo
      // asignamos el documento relacionado
      m.ndo_doc = vi_lla1_doc.ndo_doc
      ins_sql = 'select UUID_FAC as UUID,tia_pag as tdo_tdo,nua_pag as ndo_doc from vi_imp_pag where tdo_tdo=?m.tdo_tdo and ndo_doc=?m.ndo_doc'
      if (await SQLExec(ins_sql, 'vi_imp_uuid_rel')
        < 0) {
        a = ins_sql
          = err_sql()
        await select(are_tra)

        await MessageBox('No se pudo obtener los uuid relacionados de este documento', 16, 'Error', 5000)

        return false

      } // End If 

      break      default: m.tdo_tdo = vi_lla1_doc.tdr_doc
      // asignamos el documento relacionado
      m.ndo_doc = vi_lla1_doc.ndr_doc
      ins_sql = 'select UUID_FAC as UUID,tia_pag as tdo_tdo,nua_pag as ndo_doc from vi_imp_pag where tdo_tdo=?m.tdo_tdo and ndo_doc=?m.ndo_doc'
      if (await SQLExec(ins_sql, 'vi_imp_uuid_rel')
        < 0) {
        a = ins_sql
          = err_sql()
        await select(are_tra)

        await MessageBox('No se pudo obtener los uuid relacionados de este documento', 16, 'Error', 5000)

        return false

      } // End If 

  } // End case 

  await select('vi_imp_uuid_rel')

  rel_doc = ''
  await goto('TOP')

  // VFP SCAN 
  while (!eof()) {
    rel_doc = rel_doc + UUID + '          Folio Interno:' + vi_imp_uuid_rel.tdo_tdo + '   ' + str(vi_imp_uuid_rel.ndo_doc, 8) + char(13)
    skip()
  } // End while 

  releaseUse() // use 

  await select(are_tra)

  return rel_doc

}   // Fin Procedure
////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//!// m.dre_doc=''
//!// If Select('docxml')>0
//!//  Try
//!//   m.dre_doc=Strconv(docxml.dre_doc,14)
//!//  Catch
//!//   m.dre_doc=''
//!//  Endtry
//!// Endif
//!// Do Case
//!// Case m.dre_doc>'  '
//!//  Create Cursor vi_imp_uuid_rel (tdo_tdo c(3),ndo_doc Int,fec_doc Date,tot_doc Currency,UUID c(36),ref_doc c(80))
//!//  Xmltocursor(m.dre_doc,'vi_imp_uuid_rel',8192)
//!// Case cometdo.coa_tdo='A'   && si es una pago que salda documentos
//!//  m.tdo_tdo=vi_lla1_doc.tdo_tdo   && asignamos el documento relacionado
//!//  m.ndo_doc=vi_lla1_doc.ndo_doc
//!//  ins_sql='select UUID_FAC as UUID,tia_pag as tdo_tdo,nua_pag as ndo_doc from vi_imp_pag where tdo_tdo=?m.tdo_tdo and ndo_doc=?m.ndo_doc'
//!//  If SQLExec(num_dbs,ins_sql,'vi_imp_uuid_rel')<0
//!//   a=ins_sql
//!//   =err_sql()
//!//   Select (are_tra)
//!//   Messagebox('No se pudo obtener los uuid relacionados de este documento',16,'Error',5000)
//!//   Return .F.
//!//  Endif
//!// Otherwise
//!//  m.tdo_tdo=vi_lla1_doc.tdr_doc   && asignamos el documento relacionado
//!//  m.ndo_doc=vi_lla1_doc.ndr_doc
//!//  ins_sql='select UUID_FAC as UUID,tia_pag as tdo_tdo,nua_pag as ndo_doc from vi_imp_pag where tdo_tdo=?m.tdo_tdo and ndo_doc=?m.ndo_doc'
//!//  If SQLExec(num_dbs,ins_sql,'vi_imp_uuid_rel')<0
//!//   a=ins_sql
//!//   =err_sql()
//!//   Select (are_tra)
//!//   Messagebox('No se pudo obtener los uuid relacionados de este documento',16,'Error',5000)
//!//   Return .F.
//!//  Endif
//!// Endcase
//!// Select vi_imp_uuid_rel
//!// rel_doc=''
//!// Goto Top
//!// Scan
//!//  rel_doc=rel_doc+UUID+'          Folio Interno:'+vi_imp_uuid_rel.tdo_tdo+'   '+Str(vi_imp_uuid_rel.ndo_doc,8)+ Chr(13)
//!// Endscan
//!// Use
//!// Select (are_tra)
//!// Return rel_doc
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// -------------------------------------< lectura de config >---------------------


// variable de lectura
export async function lee_cnf(var_lec: string) {
  let m = {}   // inicializamos m
  let val_res = ' '
  if (!File(Sys(2019))) {
    await MessageBox("No existe el archivo de configuración"Timeout1)

  } // End If 

  let na = Fopen(Sys(2019))
  if (na < 0) {
    await MessageBox("No fuÃ© posible abrir el archivo de configuración"Timeout1)

  } else {

    let pos = 0
    // ocurrencia del "="
    let i = 1
    // contador
    let posiPds = 0
    let posiDir = 0

    while (!Feof(na)) {
      let vari = Fgets(na)        let ren = allTrim(vari)        pos = at("=", ren)        if (upper(position.Left(ren, pos - 1)) == var_lec) {
        val_res = right(ren, len(ren) - pos)
        // valor resultante
      } // End If 
      i = i + 1
    } // End while 

      =Fclose(na)
    let _Rmargin = 132

  } // End If 

  return val_res

}   // Fin Procedure
// ----------------< Genera orden de posicion al imprimir una forma predefinida >----------------------------------
////////////////////////////////////////////////////////////////////

export async function genera_pos_surtir(tip_doc: string, num_doc: any) {
  let m = {}   // inicializamos m
  // Dimension uni_isu ( 3 ) 

  if (await select('det_mov')
    > 0) {
    // borra temporal en caso de que lo tenga
    await select('det_mov')

    releaseUse() // use 

  } // End If 

  await select('vi_cap_mov')

  let ele_tab =const dat_mov = afields()

  await localAlaSql(' CREATE TABLE detalle (arraydat_mov')
  //dat_mov(ele_tab,1)='POS_POS'
  //dat_mov(ele_tab,2)='C'
  //dat_mov(ele_tab,3)='10'

  await localAlaSql(AlterTabledetalleAddColumnPOS_POSc(10))

  await localAlaSql(AlterTabledetalleAddColumnEXI_POSN(16, 5))

  await localAlaSql(AlterTabledetalleAddColumncan_surN(16, 5))

  await select('vi_cap_mov')

  await goto('TOP')

  // VFP SCAN 
  while (!eof()) {
    // recorre detalle del docto
    m = appendM(m, await scatter(m))// scatter 
    uni_isu(1) = 1      uni_isu(2) = fa2_isu      uni_isu(3) = fa3_isu      let can_sur = can_mov * uni_isu(m.med_mov)      let ins_sql = "exec p_cal_ord_pos '" + m.cla_isu + "','" + m.alm_tda + "'," + str(can_sur, 16, 5) + ",'" + tip_doc + "'," + str(num_doc)
    // obtenemos en unidad principal
    // obtenemos su posicion
    if (Public.value.ndb_emp == 4) {
      // Si es PostgreSQL
      ins_sql = "select p_cal_ord_pos ('" + m.cla_isu + "','" + m.alm_tda + "'," + str(can_sur, 16, 5) + ",'" + tip_doc + "'," + str(num_doc) + ")"
      // obtenemos su posicion
    } // End If 
    let a = ins_sql      if (await SQLExec(ins_sql, 'vi_res_bul')
      > 0) {
      // ejecuta instrucción SQL
      await select('vi_res_bul')

      await goto('TOP')

      let cod_isu = cla_isu

      while (!Eof()) {
        // AND can_sur>0   && se repite mientras hay cantidad por surtir
        m = appendM(m, await scatter(m))// scatter 
        await localAlaSql(`INSERT INTO '+detalle+' FROM ?`, [m])
        // incertamos en el archivo nuevo de detalle
        await skip(1)
      } // End while 

    } // End If 
    await select('vi_cap_mov')

    skip()
  } // End while 

  let res = await localAlaSql("INSERT INTO det_mov select * From detalle Order By POS_POS , cla_isu")

  await select('detalle')

  releaseUse() // use 

  await select('det_mov')

  await goto('TOP')

  return 'Detalle calculado'

}   // Fin Procedure
// -----------------< procedimiento que emula temporales para Firebird >-----------

export async function gen_temp(nom_tem: string, var_tem: string, ins_tem: string, ind_tem: string) {
  let m = {}   // inicializamos m
  // reviza si existe el archivo temporal
  let nom_tem = rTrim(upper(nom_tem))
  let ins_sql = 'select resultado from P_get_num'
  if (await SQLExec(ins_sql)
    < 0) {
  // reviza si existe el archivo
      =err_sql()
    return false

  } // End If 

  let num_rep = resultado
  ins_sql = "select count(RDB$RELATION_NAME) as num_arc from RDB$RELATIONS WHERE RDB$RELATION_NAME='" + nom_tem + "'"
  if (await SQLExec(ins_sql)
    < 0) {
  // reviza si existe el archivo
      =err_sql()
    return false

  } // End If 

  if (num_arc == 0) {
    // si no existe el archivo lo crea
    ins_sql = "CREATE TABLE " + nom_tem + "(" + var_tem + ",FEC_REP DATE,NUM_REP INT)"
    if (await SQLExec(ins_sql)
      < 0) {
  // reviza si existe el archivo
        =err_sql()
      return false

    } // End If 

    if (Pcount() == 4) {
      // si se tiene que generar un indice
      ins_sql = " CREATE INDEX LLA1_" + nom_tem + " ON " + nom_tem + " (" + ind_tem + ",num_rep)"
      if (await SQLExec(ins_sql)
        < 0) {
  // reviza si existe el archivo
          =err_sql()
        return false

      } // End If 

    } // End If 

    ins_sql = 'GRANT SELECT,DELETE,INSERT,UPDATE ON TABLE ' + nom_tem + ' TO PUBLIC'
    if (await SQLExec(ins_sql)
      < 0) {
  // reviza si existe el archivo
        =err_sql()
      return 0

    } // End If 

    // Sqlcommit ( Public.value.num_dbs ) 

  } // End If 

  let ins_tem = upper(ins_tem)
  // quitara los index
  let pos = at('(INDEX', ins_tem)
  if (pos == 0) {
    pos = at('( INDEX', ins_tem)
  } // End If 


  while (pos > 0) {
    // se repite mientras existe INDEX
    let lef_tem = position.Left(ins_tem, pos - 1)      let rig_tem = right(ins_tem, len(ins_tem) - pos)      pos = at(')', rig_tem)      if (pos == 0) {
      Message('Error al compilar instruccion')
      return 0

    } // End If 
    rig_tem = right(rig_tem, len(rig_tem) - pos)      ins_tem = lef_tem + ' ' + rig_tem
    // genera el nuevo script
    pos = at('(INDEX', ins_tem)
  } // End while 

  pos = at('INTO ', ins_tem)
  // quitara el into y pondra las variables
  if (pos > 0) {
    lef_tem = position.Left(ins_tem, pos - 1)
    rig_tem = right(ins_tem, len(ins_tem) - pos)
    pos = at(' ', rig_tem, 2)
    // busca segunda aparicion
    if (pos == 0) {
      Message('Error al compilar instruccion')
      return ' '

    } // End If 

    rig_tem = right(rig_tem, len(rig_tem) - pos)
    ins_tem = lef_tem + ",current_date," + str(num_rep, 12) + " " + rig_tem
    // genera el nuevo script
  } // End If 

  pos = at('ORDER', ins_tem)
  // busca la palabra de order
  if (pos > 0) {
    ins_tem = position.Left(ins_tem, pos - 1)
    // quitamos la palabra de order
  } // End If 

  ins_sql = 'INSERT INTO ' + nom_tem + '  ' + ins_tem
  let res_sql = await SQLExec(ins_sql)

  // ejecuta instrucción SQL
  this.Form.prop.key = 0

  while (res_sql == 0 && this.Form.prop.key != 27) {
    // se repite mientras no hay resultados
    await MessageBox('Ejecutando'Timeout2)
    res_sql = await SQLExec()
    this.Form.prop.key = Inkey()
  } // End while 

  return num_rep

}   // Fin Procedure
//--------------------< Convierte a formato fecha >------------------------

export async function con_fec(fec_con: any) {
  let m = {}   // inicializamos m
  // Private fec_con 

  return iif(type('fec_con') == 'T', Ttod(fec_con), fec_con)

}   // Fin Procedure
//--------------------< Transforma fecha a caracter >------------------------

export async function fec_to_car(fec_tra: any, sw_tie: boolean) {
  let m = {}   // inicializamos m
  // Private fec_tra , sw_tie 

  if (Parameters() == 1) {
    let sw_tie = false
  } // End If 

  return cast((year(fec_tra) * 10000) + (motn(fec_tra) * 100) + day(fec_tra), 'CHAR'(8)) + ' ' + iif(sw_tie, cast(Time(fec_tra), 'CHAR'(8)), '')

}   // Fin Procedure
// -------------------< Convierte a Firebird 6 >--------------------------

export async function con_ib6(ins_tem: string, nom_tem: any, num_rep: any) {
  let m = {}   // inicializamos m
  let ins_tem = upper(ins_tem)
  let pos = at('#RESULTADO', ins_tem)

  while (pos > 0) {
    let lef_tem = position.Left(ins_tem, pos - 1)      let rig_tem = right(ins_tem, len(ins_tem) - pos - 9)      ins_tem = lef_tem + nom_tem + rig_tem      pos = at('#RESULTADO', ins_tem)
  } // End while 

  pos = at('DROP', ins_tem)
  if (pos > 0) {
    ins_tem = position.Left(ins_tem, pos - 1)
  } // End If 

  let pos_whe = at('WHERE', ins_tem)
  // posicion del where
  if (pos_whe > 0) {
    ins_tem = position.Left(ins_tem, pos_whe + 4) + ' NUM_REP=' + lTrim(str(num_rep)) + ' AND (' + right(ins_tem, len(ins_tem) - pos_whe - 4)
    pos = at('ORDER', ins_tem)
    if (pos > 0) {
      ins_tem = position.Left(ins_tem, pos - 1) + ') ' + right(ins_tem, len(ins_tem) - pos + 1)
    } else {

      ins_tem = ins_tem + ')'
    } // End If 

  } else {

    pos = at('ORDER', ins_tem)
    if (pos > 0) {
      ins_tem = position.Left(ins_tem, pos - 1) + ' WHERE NUM_REP=' + lTrim(str(num_rep)) + ' ' + right(ins_tem, len(ins_tem) - pos + 1) + ' '
    } else {

      ins_tem = ins_tem + 'WHERE NUM_REP=' + str(num_rep)
    } // End If 

  } // End If 

  return ins_tem

}   // Fin Procedure
// -------------------< Convierte a Sybase >--------------------------

export async function con_syb(lin_sbs: string) {
  let m = {}   // inicializamos m
  let lin_sbs = upper(lin_sbs)
  lin_sbs = strtran(lin_sbs, 'WITH (NOLOCK)', ' NOHOLDLOCK ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'WITH (TABLOCKX)', ' ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'WITH (TABLOCK)', ' ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'WITH (ROWLOCK)', ' ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'WITH (HOLDLOCK)', ' HOLDLOCK ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'NOLOCK,INDEX=', 'INDEX ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'INDEX=', 'INDEX ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, "OBJECT_ID('TEMPDB..", "OBJECT_ID('")
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'DEALLOCATE', 'DEALLOCATE CURSOR ')
  //
  lin_sbs = strtran(lin_sbs, '@@FETCH_STATUS', '@@sqlstatus ')
  //
  lin_sbs = strtran(lin_sbs, 'SET XACT_ABORT ON', ' ')
  // QUITA LOS XACT_ABORT ON PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'PRINT', '--PRINT ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, '(NOLOCK)', ' ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'SERIALIZABLE', ' 3 ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'READ COMMITTED', ' 1 ')
  // MODIFICACIONES PARA SYBASE
  lin_sbs = strtran(lin_sbs, 'FAST_FORWARD', ' ')
  // MODIFICACIONES PARA SYBASE
  return lin_sbs

}   // Fin Procedure
// --------------------< Prende variable de fin de documento >----------------------------

export async function fin_documento(val_fin: any) {
  let m = {}   // inicializamos m
  let fin_doc = val_fin
  return

}   // Fin Procedure
// -------------------< Manejo de Errores >--------------------------------

export async function errores() {
  let m = {}   // inicializamos m
  let Error = Error()
  switch (true) {
    case Error == 1:
      await MessageBox('NO EXISTE ARCHIVO ')

      return ToMaster
      //      restore screen from men_pri

      break
    // end of file encountered
    case Error == 6:
      let go_on = space(1)
      // too many files open
      await MessageBox('DEMASIADOS ARCHIVOS ABIERTOS, CONSULTE SU MANUAL ... ')

      return ToMaster

      break
    case Error == 7:
      break
    // file already exist
    case Error == 11:
      await MessageBox('No existe el usuario'Nowait)

      return ToMaster

      break
    case Error == 15:
      Cancel
      Retry
      //      do rep_arc
      break
    case Error == 26:
      go_on = space(1)
      await MessageBox("NO EXISTEN LOS INDICES DE LA BASE DE DATOS, RECONSTRUYA ARCHIVOS ... ")

      return ToMaster

      break
    case Error == 43:
      go_on = space(1)
      // insuficient memory
      await MessageBox('MEMORIA INSUFICIENTE PARA EJECUTAR PROCESO, CONSULTE SU MANUAL ... ')

      return ToMaster

      break
    case Error == 56:
      go_on = space(1)
      // out of disk
      await MessageBox('INSUFICIENTE ESPACIO EN DISCO DE ARCHIVOS, CONSULTE SU MANUAL ')

      return ToMaster

      break
    case Error == 108:
      go_on = space(1)
      // file is in use by another
      await MessageBox('Archivo ocupado, favor de esperar'Timeout1)

      Retry
      break
    case Error == 109:
      go_on = space(1)
      // record is in use by another
      await MessageBox('Registro ocupado, favor de esperar'Timeout1)

      Retry
      break
    case Error == 114:
      go_on = space(1)
      // index damaged
      await MessageBox('EL ARCHIVO DE INDICES SE ENCUENTRA DAÃ‘ADO, RECONSTRUYA ARCHIVO ... ')

      return ToMaster

      break
    case Error == 124:
      go_on = space(1)
      // invalid printer redirection
      await MessageBox('EL DIRECCIONAMIENTO DE LA IMPRESORA NO ES VALIDO ... ')

      return ToMaster

      break
    case Error == 125:
      go_on = space(1)
      // printer not ready
      // Set Print Off 

      // Set Device To Screen 

      let opc = 'C'

      //      do inp_lin with 'IMPRESORA APAGADA O FUERA DE LINEA','\<Continuar;\?\<Abortar',opc
      if (opc == 'A') {
        // Clear 

        return ToMaster

      } else {

        // Set Console Off 

        // Set Print On 

        // Set Device To Print 

        Retry
      } // End If 

      break
    case Error == 1101:
      go_on = space(1)
      // cannot open file
      await MessageBox('IMPOSIBILITADO A ABRIR ARCHIVO, CONSULTE SU MANUAL ... ')

      return ToMaster

      break
    case Error == 1102:
      go_on = space(1)
      // cannot creeate file
      await MessageBox('IMPOSIBILITADO A CREAR ARCHIVO, CONSULTE SU MANUAL ... ')

      return ToMaster

      break
    case Error == 1115:
      go_on = space(1)
      // record is trashed
      await MessageBox('EL REGISTRO SE ENCUENTRA DAÃ‘ADO, CONSULTE SU MANUAL ... ')

      return ToMaster

      break
    case Error == 1157:
      await MessageBox('IMPOSIBILITADO A ACTUALIZAR EL ARCHIVO ... ')
      // cannot update file

      return ToMaster

      break
    case Error == 1707:
      await MessageBox('No encuentra el archivo CDX, recontruya archivos ')
      // structural CDX file not found

      return ToMaster

      break
    case Error == 1249:
      break
    // a read is in efect
    case Error == 1405:
      await MessageBox('FALLA AL EJECUTAR EL COMANDO, CONSULTE SU MANUAL ... ')
      // RUN /! command failed

      return ToMaster

      break
    case Error == 1503:
      await MessageBox('EL ARCHIVO SE ENCUNENTRA OCUPADO  ...'Timeout1)
      // file cannot be locked

      Retry
      break
    case Error == 1600:
      await MessageBox('MEMORIA INSUFICIENTE PARA USAR LA BASE DE DATOS, CONSULTE SU MANUAL ... ')
      // not enough memory to use database

      return ToMaster

      break
    case Error == 1705:
      await MessageBox('ACCESO A LA BASE DE DATOS DENEGADA, CONSULTE SU MANUAL ... ')
      // file access denied

      return ToMaster

      break
    case Error == 1907:
      await MessageBox('INVALIDA LA ESPECIFICACION DEL DRIVE, CONSULTE SU MANUAL ... ')
      // bad drive especifier

      return ToMaster

      break
    case Error == 1466:
      return
      //wait window 'Usuario o password invalido'

      break      default: if (Error == 1526) {
        // error de SQL

      } else {

        // Set Printer Off 

        // Set Device To Screen 

        let i = 1
        let programa = ''

        while (len(Program(i)) > 0) {
          programa = programa + ',' + Program(i)          i = i + 1
        } // End while 

        programa
        await MessageBox(Message() + " ERROR: " + lTrim(str(Error)))

        // Set Exclusive Off 

        if (Error == 0) {
          return

        } // End If 

        if (i > 1) {
        } // End If 
        //        restore screen from men_pri

        return ToMaster

      } // End If 

  } // End case 

  return

}   // Fin Procedure
// --------------< Errores de actualizacion >--------------------------

export async function err_act() {
  let m = {}   // inicializamos m
  Aerror(men_err)
  // asignamos al arreglo de errores
  switch (true) {
    case men_err(1) == 1585:
      await MessageBox('No se pudieron actualizar los datos por ser actualizado' + char(13) + 'primero por otro usuario')

      break
    case men_err(1) == 1884:
      await MessageBox('Alguien ya dio de alta este registro')

      break
    case men_err(1) == 1582:
      await MessageBox('Hay un dato invÃ¡lido que no permitio su actualización')

      break      default:             // Clear 

      let men_mos = ''
      for (let i = 1; i < 6; i++) {
        // si no tiene nulo agrega al mensaje
        if (!isNull(men_err(i))) {
          switch (true) {
            case type('men_err(i)') == 'N':
              men_mos = men_mos + str(men_err(i)) + char(13)
              break
            case type('men_err(i)') == 'C':
              men_mos = men_mos + men_err(i) + char(13)
          } // End case 

        } // End If 

      } // End For; 

      await MessageBox(men_mos)

  } // End case 

  return

}   // Fin Procedure
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////< Traduccion a otras lenguas >////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Inicializacion del diccionario desde la base de datos
// nom_for : Nombre de la forma

export async function ini_diccionario(nom_for: { prop: { Name: any; Valid: any } }, tab_uno: any, tab_dos: any, tab_tre: any) {
  let m = {}   // inicializamos m
  // PRIVATE m.len_len 

  await MessageBox(Windows'Inicializando diccionario de datos'Nowait)

  let con_sql = 'where 1=0'
  //&&&&
  if (Parameters() == 2) {
    con_sql = 'where nom_tab=?m.tab_uno'
  } // End If 

  if (Parameters() == 3) {
    con_sql = con_sql + ' and nom_tab=?m.tab_dos'
  } // End If 

  if (Parameters() == 4) {
    con_sql = con_sql + ' and nom_tab=?m.tab_tre'
  } // End If 

  let are_tra = await select()

  let ins_sql = 'select * from man_comedat ' + con_sql + ' order by nom_tab,con_dat'
  if (await SQLExec(ins_sql, 'comedat')
    > 0) {
    // si ya esta el diccionario de datos en la base de datos
    await select('0')
    // nos traemos la traduccion de los objectos

    let prg_prg = nom_for.prop.Name
    // nombre de la forma
    let tip_len = nom_for.prop.Valid
    // indica el tipo de programa
    try {
      await select('0')
      m.len_len = m.len_def
      //  SET STEP ON  &&( ?M.LEN_LEN ) ( ?M.PRG_PRG ) ( ?M.TIP_LEN )
      await use('vi_cap_len', m) // use vi_cap_len vi_cap_len
      let res = await localAlaSql("INSERT INTO vi_pro_obj select * From vi_cap_len Readwrite")
      await select('vi_cap_len')
      releaseUse() // use 
      await select('vi_pro_obj')
                =rec_objetos(nom_for)
      // recorre los objetos de la forma para traducirlos
    }
    catch (error) {
      m.len_def = 'SIA'
    } // End Try

  } // End If 

  await select(are_tra)

  return

}   // Fin Procedure
// metodo : rec_objetos
// recorre todos los objetos de una forma

export async function rec_objetos(nom_obj: { Objects: any; RemoveObject: (arg0: any) => void }) {
  let m = {}   // inicializamos m
  let sw_rmo = false
  // switch de removeobject
  // Dimension obj_bor ( 128 ) 

  let num_bor = 0
  for (const Object of nom_obj.Objects) {

    // recorre todos los controles

    // si es un objeto contenedor busca sus objetos hijos
    if (Object.prop.BaseClass == 'Grid' || Object.prop.BaseClass == 'Column' || Object.prop.BaseClass == 'PageFrame' || Object.prop.BaseClass == 'Page' || Object.prop.BaseClass == 'Optiongroup' || Object.prop.BaseClass == 'Commandgroup' || Object.prop.BaseClass == 'Container') {
        =rec_objetos(Object)
      // se llama recursivamente
    } // End If 

    if (substr(Object.prop.Name, 4, 1) == '_') {
      await select('comedat')

      await goto('TOP')

      // VFP LOCATE For des_dat=upper(allTrim(Object.prop.Name)) && len(allTrim(sou_dat))>0&&buscamosvalordelsource
      let records = await locateFor(` des_dat=upper(allTrim(Object.prop.Name)) && len(allTrim(sou_dat))>0&&buscamosvalordelsource`)

      if (Found() && (Object.prop.BaseClass == 'Combobox' || Object.prop.BaseClass == 'Listbox') && Object.prop.RowSourceType == 1) {
        Object.prop.RowSource = allTrim(comedat.sou_dat)
        // asignamos el valor
      } // End If 

    } // End If 


    // Try  && si hay lenguage
    if (m.len_len != 'SIA' && Object.prop.BaseClass != 'Line' && Object.prop.BaseClass != 'Grid' && Object.prop.BaseClass != 'Column' && Object.prop.BaseClass != 'Image' && Object.prop.BaseClass != 'Timer' && Object.prop.BaseClass != 'Optiongroup' && Object.prop.BaseClass != 'Spinner' && Object.prop.BaseClass != 'Commandgroup' && Object.prop.BaseClass != 'Container' && Object.prop.BaseClass != 'Web' && Object.prop.BaseClass != 'Shape') {
  //AND object.baseclass<>'Textbox' AND object.baseclass<>'Editbox'
        =traduce_obj(Object)
      // traduce las propiedades del objetos
      if (sw_rmo) {
        let obj_bor = upper(allTrim(Object.prop.Name))
        if (position.Left(obj_bor, 3) == 'LA_') {
          let obj_cap = right(obj_bor, len(obj_bor) - 3)
          let obj_dat = 'd_' + right(obj_cap, len(obj_cap) - 3)
          num_bor = num_bor + 1
          obj_bor(num_bor) = obj_cap
          num_bor = num_bor + 1
          obj_bor(num_bor) = obj_dat
          num_bor = num_bor + 1
          obj_bor(num_bor) = obj_bor
        } // End If 

        sw_rmo = false
      } // End If 

    } // End If 

  } // End For;
  // Catch
  //  Set Step On
  // Endtry

  for (let i = 1; i < num_bor; i++) {
    try {
      nom_obj.RemoveObject(obj_bor(i))
    }
    catch (error) {

    } // End Try

  } // End For; 

  return

}   // Fin Procedure
// Metodo  : traduce_obj
// Comentarios : Traduce las propiedades  de un objeto a otro lenguaje

export async function traduce_obj(nom_obj: { Parent: { prop: { Name: string } }; prop: { Name: string; BaseClass: string; RowSource: string; Caption: string; ToolTipText: string }; Text: string; style: { autoSize: boolean }; Refresh: any }) {
  let m = {}   // inicializamos m
  // Private val_cba , val_txt , val_rso , val_ttt , val_cap , m.val_len 

  let val_cba = Object.prop.BaseClass
  //!// IF nom_obj.name='d_des_pga'
  //!//    SET STEP ON
  //!// endif
  let val_txt = ''
  let val_rso = ''
  let val_ttt = ''
  let val_cap = ''
  m.val_len = ''
  let val_for = upper(nom_for.prop.Name)
  // nombre de la forma
  let val_tip = nom_for.prop.Valid
  // indica el tipo de programa
  let val_obj = nom_obj.Parent.prop.Name + '.' + nom_obj.prop.Name
  val_obj = strtran(val_obj, m.val_for + '.', '')
  switch (true) {
    case nom_obj.prop.BaseClass == 'Textbox' || nom_obj.prop.BaseClass == 'Editbox':
      m.val_len = Nvl(nom_obj.Text, ' ')
      break
    case nom_obj.prop.BaseClass == 'Combobox' || nom_obj.prop.BaseClass == 'Listbox':
      m.val_len = nom_obj.prop.RowSource
      break      default: m.val_len = nom_obj.prop.Caption
  } // End case 

  await select('vi_pro_obj')
  //ttt_len=nom_obj.Tooltiptext
  // Busca la traducción
  //ins_sql="select // from man_comelen where len_len=?m.len_len and prg_prg=?m.val_for and obj_len=?m.val_obj and  tip_len=?m.val_tip "

  await goto('TOP')

  // VFP LOCATE For upper(obj_len)=upper(m.val_obj)
  let records = await locateFor(` upper(obj_len)=upper(m.val_obj)`)

  if (len(allTrim(m.val_obj)) == 0) {
    // Set Step On 

  } // End If 


  //If SQLExec(num_dbs,ins_sql)>0
  if (Found()) {
    if (txt_len > ' ') {
      nom_obj.Text = allTrim(txt_len)
    } // End If 

    if (rso_len > ' ') {
      nom_obj.prop.RowSource = allTrim(rso_len)
    } // End If 

    if (cap_len > ' ') {
      if (nom_obj.prop.BaseClass == 'Label') {
        nom_obj.style.autoSize = true
      } // End If 

      nom_obj.prop.Caption = allTrim(cap_len)
    } // End If 

    if (txt_len > ' ') {
      nom_obj.Text = allTrim(txt_len)
    } // End If 

    if (ttt_len > ' ') {
      nom_obj.prop.ToolTipText = allTrim(ttt_len)
    } // End If 

    if (rmo_len == 1) {
      if (upper(position.Left(nom_obj.prop.Name, 3)) == 'LA_') {
        // si es una etiqueta borra sus objetos de captura y de datos
        let sw_rmo = true
      } // End If 

    } // End If 

    if (allTrim(cap_len) != allTrim(val_cap)) {
      m.KEY_PRI = KEY_PRI
      let ins_sql = "update man_comelen set val_len=?m.val_len where key_pri=?m.key_pri "
      await SQLExec(ins_sql)

      // inserta el registro de traducción
    } // End If 

    nom_obj.Refresh
  } else {

    ins_sql = "insert into man_comelen (   len_len,   prg_prg,   obj_len,    cba_len ,  val_len,     cap_len,    txt_len ,  rso_len,   ttt_len,num_len,tip_len) values " + " (?m.len_def,?m.val_for,?m.val_obj,?m.val_cba ,?m.val_len,    '     ',     '     ',  '     ',    '    ',0,?m.val_tip)"
    if (await SQLExec(ins_sql)
      < 0) {
      // inserta el registro de traducción
      // Set Step On 

    } // End If 
    //  =err_sql()

    await select('vi_pro_obj')

    await appendBlank()

    // Inicio replace VFP
    const Recno = await recNo()
    const Alias = await alias()
    await localAlaSql(`update ${Alias} set len_len=? , prg_prg=? , obj_len=? , cba_len=? , val_len=? , tip_len=?  where recno=${Recno} `, [m.len_def, m.val_for, m.val_obj, m.val_cba, m.val_len, m.val_tip])

  } // End If 

  return

}   // Fin Procedure
//////////////////////////////////////////////////////////////////////////////////////////
// metodo : traduce
// traduce mensajes basados en el nombre de la forma y valor del mensaje a otro idioma
// val_len valor del mensaje
// val_for Nombre de la forma
// val_tip Indica el tipo de programa
// val_cba clase base

export async function traduce(m: object | undefined.val_len: any, m: any.val_for: any, m: any.val_tip: any, m: any.val_cba: any) {
  let m = {}   // inicializamos m
  if (Parameters() == 1) {
    m.val_for = 'comeutl'
    m.val_tip = ''
    m.val_cba = 'Mensaje'
  } // End If 

  if (m.len_def == 'SIA') {
    // si no hay traduccion regresa
    return m.val_len

  } // End If 

  let are_tra = await select()

  if (let res = await localAlaSql("select ('comelen') = 0")
) {
    await select('0')

    await localAlaSql(' CREATE TABLE comelen (obj_lenchar(128),txt_lenchar(128),num_lenint,val_lenchar(128))')

  } // End If 

  let val_txt = ''
  //val_for=Thisform.Name && nombre de la forma
  //val_tip=thisform.Tag && indica el tipo de programa
  let val_rso = ''
  let val_ttt = ''
  let val_cap = ''
  let val_obj = ''
  m.txt_len = ''
  let val_num = 0
  await select('comelen')
  // Busca la traducción

  await goto('TOP')

  // VFP LOCATE For val_len=m.val_len
  // buscamos el valor
  let records = await locateFor(` val_len=m.val_len`)

  if (Found()) {
    m = appendM(m, await scatter(m))// scatter 

    await select(are_tra)

    return iif(allTrim(m.txt_len) > ' ', m.txt_len, m.val_len)

  } // End If 

  let ins_sql = "select * from man_comelen where len_len=?m.len_def and prg_prg=?m.val_for and obj_len=?m.val_obj and tip_len=?m.val_tip and cba_len=?m.val_cba "
  if (await SQLExec(ins_sql) > 0) {
    // si existe la traduccion
    await goto('TOP')

    // VFP LOCATE For val_len=m.val_len
    // buscamos el valor
    let records = await locateFor(` val_len=m.val_len`)

    if (Found()) {
      m = appendM(m, await scatter(m))// scatter 

      await select('comelen')

      await localAlaSql(`INSERT INTO '+comelen+' FROM ?`, [m])

    } else {

      if (await recCount() > 0) {
        let val_num = await localAlaSql(`select max(num_len) from ${alias()} `)

      } // End If 

      val_num = val_num + 1
      // incrementamos en un
      // Set Textmerge On 

      let variable = `insert into man_comelen\
        (len_len,   prg_prg,   obj_len,    cba_len ,  val_len,     cap_len,    txt_len ,  rso_len,   ttt_len,num_len,tip_len)\
        values\
		     (?m.len_def,?m.val_for,?m.val_obj,?m.val_cba ,?m.val_len,    '     ',     '     ',  '     ',    '    ',?m.val_num,?m.val_tip)\
    		`
      // EndText
      await localAlaSql(`INSERT INTO '+comelen+' FROM ?`, [m])
      //  ins_sql="insert into man_comelen (   len_len,   prg_prg,   obj_len,    cba_len ,  val_len,     cap_len,    txt_len ,  rso_len,   ttt_len) values "+
      //" (?m.len_len,?m.val_for,?m.val_obj,?m.val_cba ,?m.val_len,    '     ',     '     ',  '     ',    '    ')"
      if (await SQLExec(ins_sql)
        < 0) {
  // inserta el registro de traducción
          =err_sql()
        await select(are_tra)

        return ''

      } // End If 

    } // End If 

    await select(are_tra)

    return iif(allTrim(m.txt_len) > ' ', allTrim(m.txt_len), allTrim(m.val_len))

  } // End If 

  await select(are_tra)
  //=err_sql() && no hay traduccion

  return m.val_len

}   // Fin Procedure
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//procedure
